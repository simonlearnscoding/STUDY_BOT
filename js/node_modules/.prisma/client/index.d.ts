
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model User
 * 
 */
export type User = {
  id: number
  name: string
  nick: string
  timezone: number
  role: role
  levelRole: levelRole
}

/**
 * Model Guild
 * 
 */
export type Guild = {
  id: string
  name: string
  preferenceID: number
}

/**
 * Model GuildPreferences
 * 
 */
export type GuildPreferences = {
  id: number
  guildID: string
}

/**
 * Model Activity
 * 
 */
export type Activity = {
  id: number
  name: string
}

/**
 * Model ActivityRewards
 * 
 */
export type ActivityRewards = {
  activityID: number
  id: number
  rewardMinute: number
  rewardMinuteCam: number
  rewardMinuteLog: number
  RewardStreak: number
  RewardRestart: number
  rewardMin: number
  rewardMax: number
  reward: number
}

/**
 * Model logsNow
 * 
 */
export type logsNow = {
  id: number
  timestamp: Date
  type: ActivityType
  userId: number
  activityId: number
  guildId: string
}

/**
 * Model historicLogs
 * 
 */
export type historicLogs = {
  id: number
  date: Date
  type: ActivityType
  timeframe: Timeframe
  userId: number
  activityId: number
  guildId: string
}

/**
 * Model historicQuickLogs
 * 
 */
export type historicQuickLogs = {
  id: number
  date: Date
  type: ActivityType
  start: Date
  end: Date
  userId: number
  activityId: number
  guildId: string
}

/**
 * Model logsToday
 * 
 */
export type logsToday = {
  id: number
  date: Date
  Type: string
  Timeframe: Timeframe
  minutes: number
  userId: number
  activityId: number
}

/**
 * Model UserActivityLogsToday
 * 
 */
export type UserActivityLogsToday = {
  id: number
  type: ActivityType
  startedAt: Date
  endedAt: Date
  userId: number
  guildId: string
  activityId: number
}

/**
 * Model LevelRole
 * 
 */
export type LevelRole = {
  name: levelRole
  minlevel: number
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const ActivityType: {
  CAM: 'CAM',
  LOG: 'LOG',
  VC: 'VC'
};

export type ActivityType = (typeof ActivityType)[keyof typeof ActivityType]


export const Timeframe: {
  DAY: 'DAY',
  WEEK: 'WEEK',
  MONTH: 'MONTH'
};

export type Timeframe = (typeof Timeframe)[keyof typeof Timeframe]


export const levelRole: {
  GLADIATOR: 'GLADIATOR',
  FREEDMAN: 'FREEDMAN',
  PLEBEIAN: 'PLEBEIAN',
  PATRICIAN: 'PATRICIAN',
  SENATOR: 'SENATOR',
  CONSUL: 'CONSUL',
  EMPEROR: 'EMPEROR'
};

export type levelRole = (typeof levelRole)[keyof typeof levelRole]


export const role: {
  ADMIN: 'ADMIN',
  MODERATOR: 'MODERATOR',
  USER: 'USER'
};

export type role = (typeof role)[keyof typeof role]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>;

  $transaction<R>(fn: (prisma: Prisma.TransactionClient) => Promise<R>, options?: {maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel}): Promise<R>;

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.guild`: Exposes CRUD operations for the **Guild** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Guilds
    * const guilds = await prisma.guild.findMany()
    * ```
    */
  get guild(): Prisma.GuildDelegate<GlobalReject>;

  /**
   * `prisma.guildPreferences`: Exposes CRUD operations for the **GuildPreferences** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GuildPreferences
    * const guildPreferences = await prisma.guildPreferences.findMany()
    * ```
    */
  get guildPreferences(): Prisma.GuildPreferencesDelegate<GlobalReject>;

  /**
   * `prisma.activity`: Exposes CRUD operations for the **Activity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Activities
    * const activities = await prisma.activity.findMany()
    * ```
    */
  get activity(): Prisma.ActivityDelegate<GlobalReject>;

  /**
   * `prisma.activityRewards`: Exposes CRUD operations for the **ActivityRewards** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivityRewards
    * const activityRewards = await prisma.activityRewards.findMany()
    * ```
    */
  get activityRewards(): Prisma.ActivityRewardsDelegate<GlobalReject>;

  /**
   * `prisma.logsNow`: Exposes CRUD operations for the **logsNow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LogsNows
    * const logsNows = await prisma.logsNow.findMany()
    * ```
    */
  get logsNow(): Prisma.logsNowDelegate<GlobalReject>;

  /**
   * `prisma.historicLogs`: Exposes CRUD operations for the **historicLogs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HistoricLogs
    * const historicLogs = await prisma.historicLogs.findMany()
    * ```
    */
  get historicLogs(): Prisma.historicLogsDelegate<GlobalReject>;

  /**
   * `prisma.historicQuickLogs`: Exposes CRUD operations for the **historicQuickLogs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HistoricQuickLogs
    * const historicQuickLogs = await prisma.historicQuickLogs.findMany()
    * ```
    */
  get historicQuickLogs(): Prisma.historicQuickLogsDelegate<GlobalReject>;

  /**
   * `prisma.logsToday`: Exposes CRUD operations for the **logsToday** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LogsTodays
    * const logsTodays = await prisma.logsToday.findMany()
    * ```
    */
  get logsToday(): Prisma.logsTodayDelegate<GlobalReject>;

  /**
   * `prisma.userActivityLogsToday`: Exposes CRUD operations for the **UserActivityLogsToday** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserActivityLogsTodays
    * const userActivityLogsTodays = await prisma.userActivityLogsToday.findMany()
    * ```
    */
  get userActivityLogsToday(): Prisma.UserActivityLogsTodayDelegate<GlobalReject>;

  /**
   * `prisma.levelRole`: Exposes CRUD operations for the **LevelRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LevelRoles
    * const levelRoles = await prisma.levelRole.findMany()
    * ```
    */
  get levelRole(): Prisma.LevelRoleDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.7.1
   * Query Engine version: 272861e07ab64f234d3ffc4094e32bd61775599c
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    User: 'User',
    Guild: 'Guild',
    GuildPreferences: 'GuildPreferences',
    Activity: 'Activity',
    ActivityRewards: 'ActivityRewards',
    logsNow: 'logsNow',
    historicLogs: 'historicLogs',
    historicQuickLogs: 'historicQuickLogs',
    logsToday: 'logsToday',
    UserActivityLogsToday: 'UserActivityLogsToday',
    LevelRole: 'LevelRole'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<PrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    guilds: number
    logsNow: number
    historicLogs: number
    historicQuickLogs: number
    logsToday: number
    UserActivityLogsToday: number
  }

  export type UserCountOutputTypeSelect = {
    guilds?: boolean
    logsNow?: boolean
    historicLogs?: boolean
    historicQuickLogs?: boolean
    logsToday?: boolean
    UserActivityLogsToday?: boolean
  }

  export type UserCountOutputTypeGetPayload<S extends boolean | null | undefined | UserCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (UserCountOutputTypeArgs)
    ? UserCountOutputType 
    : S extends { select: any } & (UserCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof UserCountOutputType ? UserCountOutputType[P] : never
  } 
      : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     * 
    **/
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type GuildCountOutputType
   */


  export type GuildCountOutputType = {
    users: number
    logsNow: number
    historicLogs: number
    historicQuickLogs: number
    UserActivityLogsToday: number
  }

  export type GuildCountOutputTypeSelect = {
    users?: boolean
    logsNow?: boolean
    historicLogs?: boolean
    historicQuickLogs?: boolean
    UserActivityLogsToday?: boolean
  }

  export type GuildCountOutputTypeGetPayload<S extends boolean | null | undefined | GuildCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? GuildCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (GuildCountOutputTypeArgs)
    ? GuildCountOutputType 
    : S extends { select: any } & (GuildCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof GuildCountOutputType ? GuildCountOutputType[P] : never
  } 
      : GuildCountOutputType




  // Custom InputTypes

  /**
   * GuildCountOutputType without action
   */
  export type GuildCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the GuildCountOutputType
     * 
    **/
    select?: GuildCountOutputTypeSelect | null
  }



  /**
   * Count Type ActivityCountOutputType
   */


  export type ActivityCountOutputType = {
    UserActivityLogsToday: number
    logsNow: number
    historicLogs: number
    historicQuickLogs: number
    logsToday: number
  }

  export type ActivityCountOutputTypeSelect = {
    UserActivityLogsToday?: boolean
    logsNow?: boolean
    historicLogs?: boolean
    historicQuickLogs?: boolean
    logsToday?: boolean
  }

  export type ActivityCountOutputTypeGetPayload<S extends boolean | null | undefined | ActivityCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ActivityCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ActivityCountOutputTypeArgs)
    ? ActivityCountOutputType 
    : S extends { select: any } & (ActivityCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ActivityCountOutputType ? ActivityCountOutputType[P] : never
  } 
      : ActivityCountOutputType




  // Custom InputTypes

  /**
   * ActivityCountOutputType without action
   */
  export type ActivityCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ActivityCountOutputType
     * 
    **/
    select?: ActivityCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    timezone: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    timezone: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    name: string | null
    nick: string | null
    timezone: number | null
    role: role | null
    levelRole: levelRole | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    name: string | null
    nick: string | null
    timezone: number | null
    role: role | null
    levelRole: levelRole | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    nick: number
    timezone: number
    role: number
    levelRole: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    timezone?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    timezone?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    nick?: true
    timezone?: true
    role?: true
    levelRole?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    nick?: true
    timezone?: true
    role?: true
    levelRole?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    nick?: true
    timezone?: true
    role?: true
    levelRole?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: Array<UserScalarFieldEnum>
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: number
    name: string
    nick: string
    timezone: number
    role: role
    levelRole: levelRole
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    name?: boolean
    nick?: boolean
    timezone?: boolean
    role?: boolean
    levelRole?: boolean
    guilds?: boolean | GuildFindManyArgs
    logsNow?: boolean | logsNowFindManyArgs
    historicLogs?: boolean | historicLogsFindManyArgs
    historicQuickLogs?: boolean | historicQuickLogsFindManyArgs
    logsToday?: boolean | logsTodayFindManyArgs
    UserActivityLogsToday?: boolean | UserActivityLogsTodayFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }


  export type UserInclude = {
    guilds?: boolean | GuildFindManyArgs
    logsNow?: boolean | logsNowFindManyArgs
    historicLogs?: boolean | historicLogsFindManyArgs
    historicQuickLogs?: boolean | historicQuickLogsFindManyArgs
    logsToday?: boolean | logsTodayFindManyArgs
    UserActivityLogsToday?: boolean | UserActivityLogsTodayFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  } 

  export type UserGetPayload<S extends boolean | null | undefined | UserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? User :
    S extends undefined ? never :
    S extends { include: any } & (UserArgs | UserFindManyArgs)
    ? User  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'guilds' ? Array < GuildGetPayload<S['include'][P]>>  :
        P extends 'logsNow' ? Array < logsNowGetPayload<S['include'][P]>>  :
        P extends 'historicLogs' ? Array < historicLogsGetPayload<S['include'][P]>>  :
        P extends 'historicQuickLogs' ? Array < historicQuickLogsGetPayload<S['include'][P]>>  :
        P extends 'logsToday' ? Array < logsTodayGetPayload<S['include'][P]>>  :
        P extends 'UserActivityLogsToday' ? Array < UserActivityLogsTodayGetPayload<S['include'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserArgs | UserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'guilds' ? Array < GuildGetPayload<S['select'][P]>>  :
        P extends 'logsNow' ? Array < logsNowGetPayload<S['select'][P]>>  :
        P extends 'historicLogs' ? Array < historicLogsGetPayload<S['select'][P]>>  :
        P extends 'historicQuickLogs' ? Array < historicQuickLogsGetPayload<S['select'][P]>>  :
        P extends 'logsToday' ? Array < logsTodayGetPayload<S['select'][P]>>  :
        P extends 'UserActivityLogsToday' ? Array < UserActivityLogsTodayGetPayload<S['select'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof User ? User[P] : never
  } 
      : User


  type UserCountArgs = Merge<
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): PrismaPromise<Array<UserGetPayload<T>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    guilds<T extends GuildFindManyArgs= {}>(args?: Subset<T, GuildFindManyArgs>): PrismaPromise<Array<GuildGetPayload<T>>| Null>;

    logsNow<T extends logsNowFindManyArgs= {}>(args?: Subset<T, logsNowFindManyArgs>): PrismaPromise<Array<logsNowGetPayload<T>>| Null>;

    historicLogs<T extends historicLogsFindManyArgs= {}>(args?: Subset<T, historicLogsFindManyArgs>): PrismaPromise<Array<historicLogsGetPayload<T>>| Null>;

    historicQuickLogs<T extends historicQuickLogsFindManyArgs= {}>(args?: Subset<T, historicQuickLogsFindManyArgs>): PrismaPromise<Array<historicQuickLogsGetPayload<T>>| Null>;

    logsToday<T extends logsTodayFindManyArgs= {}>(args?: Subset<T, logsTodayFindManyArgs>): PrismaPromise<Array<logsTodayGetPayload<T>>| Null>;

    UserActivityLogsToday<T extends UserActivityLogsTodayFindManyArgs= {}>(args?: Subset<T, UserActivityLogsTodayFindManyArgs>): PrismaPromise<Array<UserActivityLogsTodayGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where: UserWhereUniqueInput
  }

  /**
   * User: findUnique
   */
  export interface UserFindUniqueArgs extends UserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     * 
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User: findFirst
   */
  export interface UserFindFirstArgs extends UserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     * 
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     * 
    **/
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     * 
    **/
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     * 
    **/
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     * 
    **/
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     * 
    **/
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     * 
    **/
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
  }



  /**
   * Model Guild
   */


  export type AggregateGuild = {
    _count: GuildCountAggregateOutputType | null
    _avg: GuildAvgAggregateOutputType | null
    _sum: GuildSumAggregateOutputType | null
    _min: GuildMinAggregateOutputType | null
    _max: GuildMaxAggregateOutputType | null
  }

  export type GuildAvgAggregateOutputType = {
    preferenceID: number | null
  }

  export type GuildSumAggregateOutputType = {
    preferenceID: number | null
  }

  export type GuildMinAggregateOutputType = {
    id: string | null
    name: string | null
    preferenceID: number | null
  }

  export type GuildMaxAggregateOutputType = {
    id: string | null
    name: string | null
    preferenceID: number | null
  }

  export type GuildCountAggregateOutputType = {
    id: number
    name: number
    preferenceID: number
    _all: number
  }


  export type GuildAvgAggregateInputType = {
    preferenceID?: true
  }

  export type GuildSumAggregateInputType = {
    preferenceID?: true
  }

  export type GuildMinAggregateInputType = {
    id?: true
    name?: true
    preferenceID?: true
  }

  export type GuildMaxAggregateInputType = {
    id?: true
    name?: true
    preferenceID?: true
  }

  export type GuildCountAggregateInputType = {
    id?: true
    name?: true
    preferenceID?: true
    _all?: true
  }

  export type GuildAggregateArgs = {
    /**
     * Filter which Guild to aggregate.
     * 
    **/
    where?: GuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guilds to fetch.
     * 
    **/
    orderBy?: Enumerable<GuildOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: GuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guilds from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guilds.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Guilds
    **/
    _count?: true | GuildCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GuildAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GuildSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GuildMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GuildMaxAggregateInputType
  }

  export type GetGuildAggregateType<T extends GuildAggregateArgs> = {
        [P in keyof T & keyof AggregateGuild]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuild[P]>
      : GetScalarType<T[P], AggregateGuild[P]>
  }




  export type GuildGroupByArgs = {
    where?: GuildWhereInput
    orderBy?: Enumerable<GuildOrderByWithAggregationInput>
    by: Array<GuildScalarFieldEnum>
    having?: GuildScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GuildCountAggregateInputType | true
    _avg?: GuildAvgAggregateInputType
    _sum?: GuildSumAggregateInputType
    _min?: GuildMinAggregateInputType
    _max?: GuildMaxAggregateInputType
  }


  export type GuildGroupByOutputType = {
    id: string
    name: string
    preferenceID: number
    _count: GuildCountAggregateOutputType | null
    _avg: GuildAvgAggregateOutputType | null
    _sum: GuildSumAggregateOutputType | null
    _min: GuildMinAggregateOutputType | null
    _max: GuildMaxAggregateOutputType | null
  }

  type GetGuildGroupByPayload<T extends GuildGroupByArgs> = PrismaPromise<
    Array<
      PickArray<GuildGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GuildGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GuildGroupByOutputType[P]>
            : GetScalarType<T[P], GuildGroupByOutputType[P]>
        }
      >
    >


  export type GuildSelect = {
    id?: boolean
    name?: boolean
    users?: boolean | UserFindManyArgs
    GuildPreferences?: boolean | GuildPreferencesArgs
    preferenceID?: boolean
    logsNow?: boolean | logsNowFindManyArgs
    historicLogs?: boolean | historicLogsFindManyArgs
    historicQuickLogs?: boolean | historicQuickLogsFindManyArgs
    UserActivityLogsToday?: boolean | UserActivityLogsTodayFindManyArgs
    _count?: boolean | GuildCountOutputTypeArgs
  }


  export type GuildInclude = {
    users?: boolean | UserFindManyArgs
    GuildPreferences?: boolean | GuildPreferencesArgs
    logsNow?: boolean | logsNowFindManyArgs
    historicLogs?: boolean | historicLogsFindManyArgs
    historicQuickLogs?: boolean | historicQuickLogsFindManyArgs
    UserActivityLogsToday?: boolean | UserActivityLogsTodayFindManyArgs
    _count?: boolean | GuildCountOutputTypeArgs
  } 

  export type GuildGetPayload<S extends boolean | null | undefined | GuildArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Guild :
    S extends undefined ? never :
    S extends { include: any } & (GuildArgs | GuildFindManyArgs)
    ? Guild  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'users' ? Array < UserGetPayload<S['include'][P]>>  :
        P extends 'GuildPreferences' ? GuildPreferencesGetPayload<S['include'][P]> | null :
        P extends 'logsNow' ? Array < logsNowGetPayload<S['include'][P]>>  :
        P extends 'historicLogs' ? Array < historicLogsGetPayload<S['include'][P]>>  :
        P extends 'historicQuickLogs' ? Array < historicQuickLogsGetPayload<S['include'][P]>>  :
        P extends 'UserActivityLogsToday' ? Array < UserActivityLogsTodayGetPayload<S['include'][P]>>  :
        P extends '_count' ? GuildCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (GuildArgs | GuildFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'users' ? Array < UserGetPayload<S['select'][P]>>  :
        P extends 'GuildPreferences' ? GuildPreferencesGetPayload<S['select'][P]> | null :
        P extends 'logsNow' ? Array < logsNowGetPayload<S['select'][P]>>  :
        P extends 'historicLogs' ? Array < historicLogsGetPayload<S['select'][P]>>  :
        P extends 'historicQuickLogs' ? Array < historicQuickLogsGetPayload<S['select'][P]>>  :
        P extends 'UserActivityLogsToday' ? Array < UserActivityLogsTodayGetPayload<S['select'][P]>>  :
        P extends '_count' ? GuildCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Guild ? Guild[P] : never
  } 
      : Guild


  type GuildCountArgs = Merge<
    Omit<GuildFindManyArgs, 'select' | 'include'> & {
      select?: GuildCountAggregateInputType | true
    }
  >

  export interface GuildDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Guild that matches the filter.
     * @param {GuildFindUniqueArgs} args - Arguments to find a Guild
     * @example
     * // Get one Guild
     * const guild = await prisma.guild.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GuildFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, GuildFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Guild'> extends True ? Prisma__GuildClient<GuildGetPayload<T>> : Prisma__GuildClient<GuildGetPayload<T> | null, null>

    /**
     * Find one Guild that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {GuildFindUniqueOrThrowArgs} args - Arguments to find a Guild
     * @example
     * // Get one Guild
     * const guild = await prisma.guild.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends GuildFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, GuildFindUniqueOrThrowArgs>
    ): Prisma__GuildClient<GuildGetPayload<T>>

    /**
     * Find the first Guild that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildFindFirstArgs} args - Arguments to find a Guild
     * @example
     * // Get one Guild
     * const guild = await prisma.guild.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GuildFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, GuildFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Guild'> extends True ? Prisma__GuildClient<GuildGetPayload<T>> : Prisma__GuildClient<GuildGetPayload<T> | null, null>

    /**
     * Find the first Guild that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildFindFirstOrThrowArgs} args - Arguments to find a Guild
     * @example
     * // Get one Guild
     * const guild = await prisma.guild.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends GuildFindFirstOrThrowArgs>(
      args?: SelectSubset<T, GuildFindFirstOrThrowArgs>
    ): Prisma__GuildClient<GuildGetPayload<T>>

    /**
     * Find zero or more Guilds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Guilds
     * const guilds = await prisma.guild.findMany()
     * 
     * // Get first 10 Guilds
     * const guilds = await prisma.guild.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const guildWithIdOnly = await prisma.guild.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends GuildFindManyArgs>(
      args?: SelectSubset<T, GuildFindManyArgs>
    ): PrismaPromise<Array<GuildGetPayload<T>>>

    /**
     * Create a Guild.
     * @param {GuildCreateArgs} args - Arguments to create a Guild.
     * @example
     * // Create one Guild
     * const Guild = await prisma.guild.create({
     *   data: {
     *     // ... data to create a Guild
     *   }
     * })
     * 
    **/
    create<T extends GuildCreateArgs>(
      args: SelectSubset<T, GuildCreateArgs>
    ): Prisma__GuildClient<GuildGetPayload<T>>

    /**
     * Create many Guilds.
     *     @param {GuildCreateManyArgs} args - Arguments to create many Guilds.
     *     @example
     *     // Create many Guilds
     *     const guild = await prisma.guild.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GuildCreateManyArgs>(
      args?: SelectSubset<T, GuildCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Guild.
     * @param {GuildDeleteArgs} args - Arguments to delete one Guild.
     * @example
     * // Delete one Guild
     * const Guild = await prisma.guild.delete({
     *   where: {
     *     // ... filter to delete one Guild
     *   }
     * })
     * 
    **/
    delete<T extends GuildDeleteArgs>(
      args: SelectSubset<T, GuildDeleteArgs>
    ): Prisma__GuildClient<GuildGetPayload<T>>

    /**
     * Update one Guild.
     * @param {GuildUpdateArgs} args - Arguments to update one Guild.
     * @example
     * // Update one Guild
     * const guild = await prisma.guild.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GuildUpdateArgs>(
      args: SelectSubset<T, GuildUpdateArgs>
    ): Prisma__GuildClient<GuildGetPayload<T>>

    /**
     * Delete zero or more Guilds.
     * @param {GuildDeleteManyArgs} args - Arguments to filter Guilds to delete.
     * @example
     * // Delete a few Guilds
     * const { count } = await prisma.guild.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GuildDeleteManyArgs>(
      args?: SelectSubset<T, GuildDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Guilds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Guilds
     * const guild = await prisma.guild.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GuildUpdateManyArgs>(
      args: SelectSubset<T, GuildUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Guild.
     * @param {GuildUpsertArgs} args - Arguments to update or create a Guild.
     * @example
     * // Update or create a Guild
     * const guild = await prisma.guild.upsert({
     *   create: {
     *     // ... data to create a Guild
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Guild we want to update
     *   }
     * })
    **/
    upsert<T extends GuildUpsertArgs>(
      args: SelectSubset<T, GuildUpsertArgs>
    ): Prisma__GuildClient<GuildGetPayload<T>>

    /**
     * Count the number of Guilds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildCountArgs} args - Arguments to filter Guilds to count.
     * @example
     * // Count the number of Guilds
     * const count = await prisma.guild.count({
     *   where: {
     *     // ... the filter for the Guilds we want to count
     *   }
     * })
    **/
    count<T extends GuildCountArgs>(
      args?: Subset<T, GuildCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuildCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Guild.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuildAggregateArgs>(args: Subset<T, GuildAggregateArgs>): PrismaPromise<GetGuildAggregateType<T>>

    /**
     * Group by Guild.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GuildGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GuildGroupByArgs['orderBy'] }
        : { orderBy?: GuildGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GuildGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuildGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Guild.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__GuildClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    users<T extends UserFindManyArgs= {}>(args?: Subset<T, UserFindManyArgs>): PrismaPromise<Array<UserGetPayload<T>>| Null>;

    GuildPreferences<T extends GuildPreferencesArgs= {}>(args?: Subset<T, GuildPreferencesArgs>): Prisma__GuildPreferencesClient<GuildPreferencesGetPayload<T> | Null>;

    logsNow<T extends logsNowFindManyArgs= {}>(args?: Subset<T, logsNowFindManyArgs>): PrismaPromise<Array<logsNowGetPayload<T>>| Null>;

    historicLogs<T extends historicLogsFindManyArgs= {}>(args?: Subset<T, historicLogsFindManyArgs>): PrismaPromise<Array<historicLogsGetPayload<T>>| Null>;

    historicQuickLogs<T extends historicQuickLogsFindManyArgs= {}>(args?: Subset<T, historicQuickLogsFindManyArgs>): PrismaPromise<Array<historicQuickLogsGetPayload<T>>| Null>;

    UserActivityLogsToday<T extends UserActivityLogsTodayFindManyArgs= {}>(args?: Subset<T, UserActivityLogsTodayFindManyArgs>): PrismaPromise<Array<UserActivityLogsTodayGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Guild base type for findUnique actions
   */
  export type GuildFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Guild
     * 
    **/
    select?: GuildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GuildInclude | null
    /**
     * Filter, which Guild to fetch.
     * 
    **/
    where: GuildWhereUniqueInput
  }

  /**
   * Guild: findUnique
   */
  export interface GuildFindUniqueArgs extends GuildFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Guild findUniqueOrThrow
   */
  export type GuildFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Guild
     * 
    **/
    select?: GuildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GuildInclude | null
    /**
     * Filter, which Guild to fetch.
     * 
    **/
    where: GuildWhereUniqueInput
  }


  /**
   * Guild base type for findFirst actions
   */
  export type GuildFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Guild
     * 
    **/
    select?: GuildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GuildInclude | null
    /**
     * Filter, which Guild to fetch.
     * 
    **/
    where?: GuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guilds to fetch.
     * 
    **/
    orderBy?: Enumerable<GuildOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Guilds.
     * 
    **/
    cursor?: GuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guilds from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guilds.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Guilds.
     * 
    **/
    distinct?: Enumerable<GuildScalarFieldEnum>
  }

  /**
   * Guild: findFirst
   */
  export interface GuildFindFirstArgs extends GuildFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Guild findFirstOrThrow
   */
  export type GuildFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Guild
     * 
    **/
    select?: GuildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GuildInclude | null
    /**
     * Filter, which Guild to fetch.
     * 
    **/
    where?: GuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guilds to fetch.
     * 
    **/
    orderBy?: Enumerable<GuildOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Guilds.
     * 
    **/
    cursor?: GuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guilds from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guilds.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Guilds.
     * 
    **/
    distinct?: Enumerable<GuildScalarFieldEnum>
  }


  /**
   * Guild findMany
   */
  export type GuildFindManyArgs = {
    /**
     * Select specific fields to fetch from the Guild
     * 
    **/
    select?: GuildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GuildInclude | null
    /**
     * Filter, which Guilds to fetch.
     * 
    **/
    where?: GuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guilds to fetch.
     * 
    **/
    orderBy?: Enumerable<GuildOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Guilds.
     * 
    **/
    cursor?: GuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guilds from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guilds.
     * 
    **/
    skip?: number
    distinct?: Enumerable<GuildScalarFieldEnum>
  }


  /**
   * Guild create
   */
  export type GuildCreateArgs = {
    /**
     * Select specific fields to fetch from the Guild
     * 
    **/
    select?: GuildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GuildInclude | null
    /**
     * The data needed to create a Guild.
     * 
    **/
    data: XOR<GuildCreateInput, GuildUncheckedCreateInput>
  }


  /**
   * Guild createMany
   */
  export type GuildCreateManyArgs = {
    /**
     * The data used to create many Guilds.
     * 
    **/
    data: Enumerable<GuildCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Guild update
   */
  export type GuildUpdateArgs = {
    /**
     * Select specific fields to fetch from the Guild
     * 
    **/
    select?: GuildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GuildInclude | null
    /**
     * The data needed to update a Guild.
     * 
    **/
    data: XOR<GuildUpdateInput, GuildUncheckedUpdateInput>
    /**
     * Choose, which Guild to update.
     * 
    **/
    where: GuildWhereUniqueInput
  }


  /**
   * Guild updateMany
   */
  export type GuildUpdateManyArgs = {
    /**
     * The data used to update Guilds.
     * 
    **/
    data: XOR<GuildUpdateManyMutationInput, GuildUncheckedUpdateManyInput>
    /**
     * Filter which Guilds to update
     * 
    **/
    where?: GuildWhereInput
  }


  /**
   * Guild upsert
   */
  export type GuildUpsertArgs = {
    /**
     * Select specific fields to fetch from the Guild
     * 
    **/
    select?: GuildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GuildInclude | null
    /**
     * The filter to search for the Guild to update in case it exists.
     * 
    **/
    where: GuildWhereUniqueInput
    /**
     * In case the Guild found by the `where` argument doesn't exist, create a new Guild with this data.
     * 
    **/
    create: XOR<GuildCreateInput, GuildUncheckedCreateInput>
    /**
     * In case the Guild was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<GuildUpdateInput, GuildUncheckedUpdateInput>
  }


  /**
   * Guild delete
   */
  export type GuildDeleteArgs = {
    /**
     * Select specific fields to fetch from the Guild
     * 
    **/
    select?: GuildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GuildInclude | null
    /**
     * Filter which Guild to delete.
     * 
    **/
    where: GuildWhereUniqueInput
  }


  /**
   * Guild deleteMany
   */
  export type GuildDeleteManyArgs = {
    /**
     * Filter which Guilds to delete
     * 
    **/
    where?: GuildWhereInput
  }


  /**
   * Guild without action
   */
  export type GuildArgs = {
    /**
     * Select specific fields to fetch from the Guild
     * 
    **/
    select?: GuildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GuildInclude | null
  }



  /**
   * Model GuildPreferences
   */


  export type AggregateGuildPreferences = {
    _count: GuildPreferencesCountAggregateOutputType | null
    _avg: GuildPreferencesAvgAggregateOutputType | null
    _sum: GuildPreferencesSumAggregateOutputType | null
    _min: GuildPreferencesMinAggregateOutputType | null
    _max: GuildPreferencesMaxAggregateOutputType | null
  }

  export type GuildPreferencesAvgAggregateOutputType = {
    id: number | null
  }

  export type GuildPreferencesSumAggregateOutputType = {
    id: number | null
  }

  export type GuildPreferencesMinAggregateOutputType = {
    id: number | null
    guildID: string | null
  }

  export type GuildPreferencesMaxAggregateOutputType = {
    id: number | null
    guildID: string | null
  }

  export type GuildPreferencesCountAggregateOutputType = {
    id: number
    guildID: number
    _all: number
  }


  export type GuildPreferencesAvgAggregateInputType = {
    id?: true
  }

  export type GuildPreferencesSumAggregateInputType = {
    id?: true
  }

  export type GuildPreferencesMinAggregateInputType = {
    id?: true
    guildID?: true
  }

  export type GuildPreferencesMaxAggregateInputType = {
    id?: true
    guildID?: true
  }

  export type GuildPreferencesCountAggregateInputType = {
    id?: true
    guildID?: true
    _all?: true
  }

  export type GuildPreferencesAggregateArgs = {
    /**
     * Filter which GuildPreferences to aggregate.
     * 
    **/
    where?: GuildPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildPreferences to fetch.
     * 
    **/
    orderBy?: Enumerable<GuildPreferencesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: GuildPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildPreferences from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildPreferences.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GuildPreferences
    **/
    _count?: true | GuildPreferencesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GuildPreferencesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GuildPreferencesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GuildPreferencesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GuildPreferencesMaxAggregateInputType
  }

  export type GetGuildPreferencesAggregateType<T extends GuildPreferencesAggregateArgs> = {
        [P in keyof T & keyof AggregateGuildPreferences]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuildPreferences[P]>
      : GetScalarType<T[P], AggregateGuildPreferences[P]>
  }




  export type GuildPreferencesGroupByArgs = {
    where?: GuildPreferencesWhereInput
    orderBy?: Enumerable<GuildPreferencesOrderByWithAggregationInput>
    by: Array<GuildPreferencesScalarFieldEnum>
    having?: GuildPreferencesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GuildPreferencesCountAggregateInputType | true
    _avg?: GuildPreferencesAvgAggregateInputType
    _sum?: GuildPreferencesSumAggregateInputType
    _min?: GuildPreferencesMinAggregateInputType
    _max?: GuildPreferencesMaxAggregateInputType
  }


  export type GuildPreferencesGroupByOutputType = {
    id: number
    guildID: string
    _count: GuildPreferencesCountAggregateOutputType | null
    _avg: GuildPreferencesAvgAggregateOutputType | null
    _sum: GuildPreferencesSumAggregateOutputType | null
    _min: GuildPreferencesMinAggregateOutputType | null
    _max: GuildPreferencesMaxAggregateOutputType | null
  }

  type GetGuildPreferencesGroupByPayload<T extends GuildPreferencesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<GuildPreferencesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GuildPreferencesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GuildPreferencesGroupByOutputType[P]>
            : GetScalarType<T[P], GuildPreferencesGroupByOutputType[P]>
        }
      >
    >


  export type GuildPreferencesSelect = {
    id?: boolean
    guild?: boolean | GuildArgs
    guildID?: boolean
  }


  export type GuildPreferencesInclude = {
    guild?: boolean | GuildArgs
  } 

  export type GuildPreferencesGetPayload<S extends boolean | null | undefined | GuildPreferencesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? GuildPreferences :
    S extends undefined ? never :
    S extends { include: any } & (GuildPreferencesArgs | GuildPreferencesFindManyArgs)
    ? GuildPreferences  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'guild' ? GuildGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (GuildPreferencesArgs | GuildPreferencesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'guild' ? GuildGetPayload<S['select'][P]> | null :  P extends keyof GuildPreferences ? GuildPreferences[P] : never
  } 
      : GuildPreferences


  type GuildPreferencesCountArgs = Merge<
    Omit<GuildPreferencesFindManyArgs, 'select' | 'include'> & {
      select?: GuildPreferencesCountAggregateInputType | true
    }
  >

  export interface GuildPreferencesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one GuildPreferences that matches the filter.
     * @param {GuildPreferencesFindUniqueArgs} args - Arguments to find a GuildPreferences
     * @example
     * // Get one GuildPreferences
     * const guildPreferences = await prisma.guildPreferences.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GuildPreferencesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, GuildPreferencesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'GuildPreferences'> extends True ? Prisma__GuildPreferencesClient<GuildPreferencesGetPayload<T>> : Prisma__GuildPreferencesClient<GuildPreferencesGetPayload<T> | null, null>

    /**
     * Find one GuildPreferences that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {GuildPreferencesFindUniqueOrThrowArgs} args - Arguments to find a GuildPreferences
     * @example
     * // Get one GuildPreferences
     * const guildPreferences = await prisma.guildPreferences.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends GuildPreferencesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, GuildPreferencesFindUniqueOrThrowArgs>
    ): Prisma__GuildPreferencesClient<GuildPreferencesGetPayload<T>>

    /**
     * Find the first GuildPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildPreferencesFindFirstArgs} args - Arguments to find a GuildPreferences
     * @example
     * // Get one GuildPreferences
     * const guildPreferences = await prisma.guildPreferences.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GuildPreferencesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, GuildPreferencesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'GuildPreferences'> extends True ? Prisma__GuildPreferencesClient<GuildPreferencesGetPayload<T>> : Prisma__GuildPreferencesClient<GuildPreferencesGetPayload<T> | null, null>

    /**
     * Find the first GuildPreferences that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildPreferencesFindFirstOrThrowArgs} args - Arguments to find a GuildPreferences
     * @example
     * // Get one GuildPreferences
     * const guildPreferences = await prisma.guildPreferences.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends GuildPreferencesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, GuildPreferencesFindFirstOrThrowArgs>
    ): Prisma__GuildPreferencesClient<GuildPreferencesGetPayload<T>>

    /**
     * Find zero or more GuildPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildPreferencesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GuildPreferences
     * const guildPreferences = await prisma.guildPreferences.findMany()
     * 
     * // Get first 10 GuildPreferences
     * const guildPreferences = await prisma.guildPreferences.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const guildPreferencesWithIdOnly = await prisma.guildPreferences.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends GuildPreferencesFindManyArgs>(
      args?: SelectSubset<T, GuildPreferencesFindManyArgs>
    ): PrismaPromise<Array<GuildPreferencesGetPayload<T>>>

    /**
     * Create a GuildPreferences.
     * @param {GuildPreferencesCreateArgs} args - Arguments to create a GuildPreferences.
     * @example
     * // Create one GuildPreferences
     * const GuildPreferences = await prisma.guildPreferences.create({
     *   data: {
     *     // ... data to create a GuildPreferences
     *   }
     * })
     * 
    **/
    create<T extends GuildPreferencesCreateArgs>(
      args: SelectSubset<T, GuildPreferencesCreateArgs>
    ): Prisma__GuildPreferencesClient<GuildPreferencesGetPayload<T>>

    /**
     * Create many GuildPreferences.
     *     @param {GuildPreferencesCreateManyArgs} args - Arguments to create many GuildPreferences.
     *     @example
     *     // Create many GuildPreferences
     *     const guildPreferences = await prisma.guildPreferences.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GuildPreferencesCreateManyArgs>(
      args?: SelectSubset<T, GuildPreferencesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a GuildPreferences.
     * @param {GuildPreferencesDeleteArgs} args - Arguments to delete one GuildPreferences.
     * @example
     * // Delete one GuildPreferences
     * const GuildPreferences = await prisma.guildPreferences.delete({
     *   where: {
     *     // ... filter to delete one GuildPreferences
     *   }
     * })
     * 
    **/
    delete<T extends GuildPreferencesDeleteArgs>(
      args: SelectSubset<T, GuildPreferencesDeleteArgs>
    ): Prisma__GuildPreferencesClient<GuildPreferencesGetPayload<T>>

    /**
     * Update one GuildPreferences.
     * @param {GuildPreferencesUpdateArgs} args - Arguments to update one GuildPreferences.
     * @example
     * // Update one GuildPreferences
     * const guildPreferences = await prisma.guildPreferences.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GuildPreferencesUpdateArgs>(
      args: SelectSubset<T, GuildPreferencesUpdateArgs>
    ): Prisma__GuildPreferencesClient<GuildPreferencesGetPayload<T>>

    /**
     * Delete zero or more GuildPreferences.
     * @param {GuildPreferencesDeleteManyArgs} args - Arguments to filter GuildPreferences to delete.
     * @example
     * // Delete a few GuildPreferences
     * const { count } = await prisma.guildPreferences.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GuildPreferencesDeleteManyArgs>(
      args?: SelectSubset<T, GuildPreferencesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more GuildPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildPreferencesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GuildPreferences
     * const guildPreferences = await prisma.guildPreferences.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GuildPreferencesUpdateManyArgs>(
      args: SelectSubset<T, GuildPreferencesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one GuildPreferences.
     * @param {GuildPreferencesUpsertArgs} args - Arguments to update or create a GuildPreferences.
     * @example
     * // Update or create a GuildPreferences
     * const guildPreferences = await prisma.guildPreferences.upsert({
     *   create: {
     *     // ... data to create a GuildPreferences
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GuildPreferences we want to update
     *   }
     * })
    **/
    upsert<T extends GuildPreferencesUpsertArgs>(
      args: SelectSubset<T, GuildPreferencesUpsertArgs>
    ): Prisma__GuildPreferencesClient<GuildPreferencesGetPayload<T>>

    /**
     * Count the number of GuildPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildPreferencesCountArgs} args - Arguments to filter GuildPreferences to count.
     * @example
     * // Count the number of GuildPreferences
     * const count = await prisma.guildPreferences.count({
     *   where: {
     *     // ... the filter for the GuildPreferences we want to count
     *   }
     * })
    **/
    count<T extends GuildPreferencesCountArgs>(
      args?: Subset<T, GuildPreferencesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuildPreferencesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GuildPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildPreferencesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuildPreferencesAggregateArgs>(args: Subset<T, GuildPreferencesAggregateArgs>): PrismaPromise<GetGuildPreferencesAggregateType<T>>

    /**
     * Group by GuildPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildPreferencesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GuildPreferencesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GuildPreferencesGroupByArgs['orderBy'] }
        : { orderBy?: GuildPreferencesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GuildPreferencesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuildPreferencesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for GuildPreferences.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__GuildPreferencesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    guild<T extends GuildArgs= {}>(args?: Subset<T, GuildArgs>): Prisma__GuildClient<GuildGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * GuildPreferences base type for findUnique actions
   */
  export type GuildPreferencesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the GuildPreferences
     * 
    **/
    select?: GuildPreferencesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GuildPreferencesInclude | null
    /**
     * Filter, which GuildPreferences to fetch.
     * 
    **/
    where: GuildPreferencesWhereUniqueInput
  }

  /**
   * GuildPreferences: findUnique
   */
  export interface GuildPreferencesFindUniqueArgs extends GuildPreferencesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * GuildPreferences findUniqueOrThrow
   */
  export type GuildPreferencesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the GuildPreferences
     * 
    **/
    select?: GuildPreferencesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GuildPreferencesInclude | null
    /**
     * Filter, which GuildPreferences to fetch.
     * 
    **/
    where: GuildPreferencesWhereUniqueInput
  }


  /**
   * GuildPreferences base type for findFirst actions
   */
  export type GuildPreferencesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the GuildPreferences
     * 
    **/
    select?: GuildPreferencesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GuildPreferencesInclude | null
    /**
     * Filter, which GuildPreferences to fetch.
     * 
    **/
    where?: GuildPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildPreferences to fetch.
     * 
    **/
    orderBy?: Enumerable<GuildPreferencesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GuildPreferences.
     * 
    **/
    cursor?: GuildPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildPreferences from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildPreferences.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GuildPreferences.
     * 
    **/
    distinct?: Enumerable<GuildPreferencesScalarFieldEnum>
  }

  /**
   * GuildPreferences: findFirst
   */
  export interface GuildPreferencesFindFirstArgs extends GuildPreferencesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * GuildPreferences findFirstOrThrow
   */
  export type GuildPreferencesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the GuildPreferences
     * 
    **/
    select?: GuildPreferencesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GuildPreferencesInclude | null
    /**
     * Filter, which GuildPreferences to fetch.
     * 
    **/
    where?: GuildPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildPreferences to fetch.
     * 
    **/
    orderBy?: Enumerable<GuildPreferencesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GuildPreferences.
     * 
    **/
    cursor?: GuildPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildPreferences from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildPreferences.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GuildPreferences.
     * 
    **/
    distinct?: Enumerable<GuildPreferencesScalarFieldEnum>
  }


  /**
   * GuildPreferences findMany
   */
  export type GuildPreferencesFindManyArgs = {
    /**
     * Select specific fields to fetch from the GuildPreferences
     * 
    **/
    select?: GuildPreferencesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GuildPreferencesInclude | null
    /**
     * Filter, which GuildPreferences to fetch.
     * 
    **/
    where?: GuildPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildPreferences to fetch.
     * 
    **/
    orderBy?: Enumerable<GuildPreferencesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GuildPreferences.
     * 
    **/
    cursor?: GuildPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildPreferences from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildPreferences.
     * 
    **/
    skip?: number
    distinct?: Enumerable<GuildPreferencesScalarFieldEnum>
  }


  /**
   * GuildPreferences create
   */
  export type GuildPreferencesCreateArgs = {
    /**
     * Select specific fields to fetch from the GuildPreferences
     * 
    **/
    select?: GuildPreferencesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GuildPreferencesInclude | null
    /**
     * The data needed to create a GuildPreferences.
     * 
    **/
    data: XOR<GuildPreferencesCreateInput, GuildPreferencesUncheckedCreateInput>
  }


  /**
   * GuildPreferences createMany
   */
  export type GuildPreferencesCreateManyArgs = {
    /**
     * The data used to create many GuildPreferences.
     * 
    **/
    data: Enumerable<GuildPreferencesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * GuildPreferences update
   */
  export type GuildPreferencesUpdateArgs = {
    /**
     * Select specific fields to fetch from the GuildPreferences
     * 
    **/
    select?: GuildPreferencesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GuildPreferencesInclude | null
    /**
     * The data needed to update a GuildPreferences.
     * 
    **/
    data: XOR<GuildPreferencesUpdateInput, GuildPreferencesUncheckedUpdateInput>
    /**
     * Choose, which GuildPreferences to update.
     * 
    **/
    where: GuildPreferencesWhereUniqueInput
  }


  /**
   * GuildPreferences updateMany
   */
  export type GuildPreferencesUpdateManyArgs = {
    /**
     * The data used to update GuildPreferences.
     * 
    **/
    data: XOR<GuildPreferencesUpdateManyMutationInput, GuildPreferencesUncheckedUpdateManyInput>
    /**
     * Filter which GuildPreferences to update
     * 
    **/
    where?: GuildPreferencesWhereInput
  }


  /**
   * GuildPreferences upsert
   */
  export type GuildPreferencesUpsertArgs = {
    /**
     * Select specific fields to fetch from the GuildPreferences
     * 
    **/
    select?: GuildPreferencesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GuildPreferencesInclude | null
    /**
     * The filter to search for the GuildPreferences to update in case it exists.
     * 
    **/
    where: GuildPreferencesWhereUniqueInput
    /**
     * In case the GuildPreferences found by the `where` argument doesn't exist, create a new GuildPreferences with this data.
     * 
    **/
    create: XOR<GuildPreferencesCreateInput, GuildPreferencesUncheckedCreateInput>
    /**
     * In case the GuildPreferences was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<GuildPreferencesUpdateInput, GuildPreferencesUncheckedUpdateInput>
  }


  /**
   * GuildPreferences delete
   */
  export type GuildPreferencesDeleteArgs = {
    /**
     * Select specific fields to fetch from the GuildPreferences
     * 
    **/
    select?: GuildPreferencesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GuildPreferencesInclude | null
    /**
     * Filter which GuildPreferences to delete.
     * 
    **/
    where: GuildPreferencesWhereUniqueInput
  }


  /**
   * GuildPreferences deleteMany
   */
  export type GuildPreferencesDeleteManyArgs = {
    /**
     * Filter which GuildPreferences to delete
     * 
    **/
    where?: GuildPreferencesWhereInput
  }


  /**
   * GuildPreferences without action
   */
  export type GuildPreferencesArgs = {
    /**
     * Select specific fields to fetch from the GuildPreferences
     * 
    **/
    select?: GuildPreferencesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GuildPreferencesInclude | null
  }



  /**
   * Model Activity
   */


  export type AggregateActivity = {
    _count: ActivityCountAggregateOutputType | null
    _avg: ActivityAvgAggregateOutputType | null
    _sum: ActivitySumAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  export type ActivityAvgAggregateOutputType = {
    id: number | null
  }

  export type ActivitySumAggregateOutputType = {
    id: number | null
  }

  export type ActivityMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type ActivityMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type ActivityCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type ActivityAvgAggregateInputType = {
    id?: true
  }

  export type ActivitySumAggregateInputType = {
    id?: true
  }

  export type ActivityMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type ActivityMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type ActivityCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type ActivityAggregateArgs = {
    /**
     * Filter which Activity to aggregate.
     * 
    **/
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     * 
    **/
    orderBy?: Enumerable<ActivityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Activities
    **/
    _count?: true | ActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActivityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActivitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityMaxAggregateInputType
  }

  export type GetActivityAggregateType<T extends ActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivity[P]>
      : GetScalarType<T[P], AggregateActivity[P]>
  }




  export type ActivityGroupByArgs = {
    where?: ActivityWhereInput
    orderBy?: Enumerable<ActivityOrderByWithAggregationInput>
    by: Array<ActivityScalarFieldEnum>
    having?: ActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityCountAggregateInputType | true
    _avg?: ActivityAvgAggregateInputType
    _sum?: ActivitySumAggregateInputType
    _min?: ActivityMinAggregateInputType
    _max?: ActivityMaxAggregateInputType
  }


  export type ActivityGroupByOutputType = {
    id: number
    name: string
    _count: ActivityCountAggregateOutputType | null
    _avg: ActivityAvgAggregateOutputType | null
    _sum: ActivitySumAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  type GetActivityGroupByPayload<T extends ActivityGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityGroupByOutputType[P]>
        }
      >
    >


  export type ActivitySelect = {
    id?: boolean
    name?: boolean
    rewards?: boolean | ActivityRewardsArgs
    UserActivityLogsToday?: boolean | UserActivityLogsTodayFindManyArgs
    logsNow?: boolean | logsNowFindManyArgs
    historicLogs?: boolean | historicLogsFindManyArgs
    historicQuickLogs?: boolean | historicQuickLogsFindManyArgs
    logsToday?: boolean | logsTodayFindManyArgs
    _count?: boolean | ActivityCountOutputTypeArgs
  }


  export type ActivityInclude = {
    rewards?: boolean | ActivityRewardsArgs
    UserActivityLogsToday?: boolean | UserActivityLogsTodayFindManyArgs
    logsNow?: boolean | logsNowFindManyArgs
    historicLogs?: boolean | historicLogsFindManyArgs
    historicQuickLogs?: boolean | historicQuickLogsFindManyArgs
    logsToday?: boolean | logsTodayFindManyArgs
    _count?: boolean | ActivityCountOutputTypeArgs
  } 

  export type ActivityGetPayload<S extends boolean | null | undefined | ActivityArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Activity :
    S extends undefined ? never :
    S extends { include: any } & (ActivityArgs | ActivityFindManyArgs)
    ? Activity  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'rewards' ? ActivityRewardsGetPayload<S['include'][P]> | null :
        P extends 'UserActivityLogsToday' ? Array < UserActivityLogsTodayGetPayload<S['include'][P]>>  :
        P extends 'logsNow' ? Array < logsNowGetPayload<S['include'][P]>>  :
        P extends 'historicLogs' ? Array < historicLogsGetPayload<S['include'][P]>>  :
        P extends 'historicQuickLogs' ? Array < historicQuickLogsGetPayload<S['include'][P]>>  :
        P extends 'logsToday' ? Array < logsTodayGetPayload<S['include'][P]>>  :
        P extends '_count' ? ActivityCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ActivityArgs | ActivityFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'rewards' ? ActivityRewardsGetPayload<S['select'][P]> | null :
        P extends 'UserActivityLogsToday' ? Array < UserActivityLogsTodayGetPayload<S['select'][P]>>  :
        P extends 'logsNow' ? Array < logsNowGetPayload<S['select'][P]>>  :
        P extends 'historicLogs' ? Array < historicLogsGetPayload<S['select'][P]>>  :
        P extends 'historicQuickLogs' ? Array < historicQuickLogsGetPayload<S['select'][P]>>  :
        P extends 'logsToday' ? Array < logsTodayGetPayload<S['select'][P]>>  :
        P extends '_count' ? ActivityCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Activity ? Activity[P] : never
  } 
      : Activity


  type ActivityCountArgs = Merge<
    Omit<ActivityFindManyArgs, 'select' | 'include'> & {
      select?: ActivityCountAggregateInputType | true
    }
  >

  export interface ActivityDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Activity that matches the filter.
     * @param {ActivityFindUniqueArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ActivityFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ActivityFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Activity'> extends True ? Prisma__ActivityClient<ActivityGetPayload<T>> : Prisma__ActivityClient<ActivityGetPayload<T> | null, null>

    /**
     * Find one Activity that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ActivityFindUniqueOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ActivityFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ActivityFindUniqueOrThrowArgs>
    ): Prisma__ActivityClient<ActivityGetPayload<T>>

    /**
     * Find the first Activity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ActivityFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ActivityFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Activity'> extends True ? Prisma__ActivityClient<ActivityGetPayload<T>> : Prisma__ActivityClient<ActivityGetPayload<T> | null, null>

    /**
     * Find the first Activity that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ActivityFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ActivityFindFirstOrThrowArgs>
    ): Prisma__ActivityClient<ActivityGetPayload<T>>

    /**
     * Find zero or more Activities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Activities
     * const activities = await prisma.activity.findMany()
     * 
     * // Get first 10 Activities
     * const activities = await prisma.activity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityWithIdOnly = await prisma.activity.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ActivityFindManyArgs>(
      args?: SelectSubset<T, ActivityFindManyArgs>
    ): PrismaPromise<Array<ActivityGetPayload<T>>>

    /**
     * Create a Activity.
     * @param {ActivityCreateArgs} args - Arguments to create a Activity.
     * @example
     * // Create one Activity
     * const Activity = await prisma.activity.create({
     *   data: {
     *     // ... data to create a Activity
     *   }
     * })
     * 
    **/
    create<T extends ActivityCreateArgs>(
      args: SelectSubset<T, ActivityCreateArgs>
    ): Prisma__ActivityClient<ActivityGetPayload<T>>

    /**
     * Create many Activities.
     *     @param {ActivityCreateManyArgs} args - Arguments to create many Activities.
     *     @example
     *     // Create many Activities
     *     const activity = await prisma.activity.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ActivityCreateManyArgs>(
      args?: SelectSubset<T, ActivityCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Activity.
     * @param {ActivityDeleteArgs} args - Arguments to delete one Activity.
     * @example
     * // Delete one Activity
     * const Activity = await prisma.activity.delete({
     *   where: {
     *     // ... filter to delete one Activity
     *   }
     * })
     * 
    **/
    delete<T extends ActivityDeleteArgs>(
      args: SelectSubset<T, ActivityDeleteArgs>
    ): Prisma__ActivityClient<ActivityGetPayload<T>>

    /**
     * Update one Activity.
     * @param {ActivityUpdateArgs} args - Arguments to update one Activity.
     * @example
     * // Update one Activity
     * const activity = await prisma.activity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ActivityUpdateArgs>(
      args: SelectSubset<T, ActivityUpdateArgs>
    ): Prisma__ActivityClient<ActivityGetPayload<T>>

    /**
     * Delete zero or more Activities.
     * @param {ActivityDeleteManyArgs} args - Arguments to filter Activities to delete.
     * @example
     * // Delete a few Activities
     * const { count } = await prisma.activity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ActivityDeleteManyArgs>(
      args?: SelectSubset<T, ActivityDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ActivityUpdateManyArgs>(
      args: SelectSubset<T, ActivityUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Activity.
     * @param {ActivityUpsertArgs} args - Arguments to update or create a Activity.
     * @example
     * // Update or create a Activity
     * const activity = await prisma.activity.upsert({
     *   create: {
     *     // ... data to create a Activity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Activity we want to update
     *   }
     * })
    **/
    upsert<T extends ActivityUpsertArgs>(
      args: SelectSubset<T, ActivityUpsertArgs>
    ): Prisma__ActivityClient<ActivityGetPayload<T>>

    /**
     * Count the number of Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityCountArgs} args - Arguments to filter Activities to count.
     * @example
     * // Count the number of Activities
     * const count = await prisma.activity.count({
     *   where: {
     *     // ... the filter for the Activities we want to count
     *   }
     * })
    **/
    count<T extends ActivityCountArgs>(
      args?: Subset<T, ActivityCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityAggregateArgs>(args: Subset<T, ActivityAggregateArgs>): PrismaPromise<GetActivityAggregateType<T>>

    /**
     * Group by Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityGroupByArgs['orderBy'] }
        : { orderBy?: ActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Activity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ActivityClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    rewards<T extends ActivityRewardsArgs= {}>(args?: Subset<T, ActivityRewardsArgs>): Prisma__ActivityRewardsClient<ActivityRewardsGetPayload<T> | Null>;

    UserActivityLogsToday<T extends UserActivityLogsTodayFindManyArgs= {}>(args?: Subset<T, UserActivityLogsTodayFindManyArgs>): PrismaPromise<Array<UserActivityLogsTodayGetPayload<T>>| Null>;

    logsNow<T extends logsNowFindManyArgs= {}>(args?: Subset<T, logsNowFindManyArgs>): PrismaPromise<Array<logsNowGetPayload<T>>| Null>;

    historicLogs<T extends historicLogsFindManyArgs= {}>(args?: Subset<T, historicLogsFindManyArgs>): PrismaPromise<Array<historicLogsGetPayload<T>>| Null>;

    historicQuickLogs<T extends historicQuickLogsFindManyArgs= {}>(args?: Subset<T, historicQuickLogsFindManyArgs>): PrismaPromise<Array<historicQuickLogsGetPayload<T>>| Null>;

    logsToday<T extends logsTodayFindManyArgs= {}>(args?: Subset<T, logsTodayFindManyArgs>): PrismaPromise<Array<logsTodayGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Activity base type for findUnique actions
   */
  export type ActivityFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Activity
     * 
    **/
    select?: ActivitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActivityInclude | null
    /**
     * Filter, which Activity to fetch.
     * 
    **/
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity: findUnique
   */
  export interface ActivityFindUniqueArgs extends ActivityFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Activity findUniqueOrThrow
   */
  export type ActivityFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Activity
     * 
    **/
    select?: ActivitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActivityInclude | null
    /**
     * Filter, which Activity to fetch.
     * 
    **/
    where: ActivityWhereUniqueInput
  }


  /**
   * Activity base type for findFirst actions
   */
  export type ActivityFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Activity
     * 
    **/
    select?: ActivitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActivityInclude | null
    /**
     * Filter, which Activity to fetch.
     * 
    **/
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     * 
    **/
    orderBy?: Enumerable<ActivityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     * 
    **/
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     * 
    **/
    distinct?: Enumerable<ActivityScalarFieldEnum>
  }

  /**
   * Activity: findFirst
   */
  export interface ActivityFindFirstArgs extends ActivityFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Activity findFirstOrThrow
   */
  export type ActivityFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Activity
     * 
    **/
    select?: ActivitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActivityInclude | null
    /**
     * Filter, which Activity to fetch.
     * 
    **/
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     * 
    **/
    orderBy?: Enumerable<ActivityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     * 
    **/
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     * 
    **/
    distinct?: Enumerable<ActivityScalarFieldEnum>
  }


  /**
   * Activity findMany
   */
  export type ActivityFindManyArgs = {
    /**
     * Select specific fields to fetch from the Activity
     * 
    **/
    select?: ActivitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActivityInclude | null
    /**
     * Filter, which Activities to fetch.
     * 
    **/
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     * 
    **/
    orderBy?: Enumerable<ActivityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Activities.
     * 
    **/
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ActivityScalarFieldEnum>
  }


  /**
   * Activity create
   */
  export type ActivityCreateArgs = {
    /**
     * Select specific fields to fetch from the Activity
     * 
    **/
    select?: ActivitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActivityInclude | null
    /**
     * The data needed to create a Activity.
     * 
    **/
    data: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
  }


  /**
   * Activity createMany
   */
  export type ActivityCreateManyArgs = {
    /**
     * The data used to create many Activities.
     * 
    **/
    data: Enumerable<ActivityCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Activity update
   */
  export type ActivityUpdateArgs = {
    /**
     * Select specific fields to fetch from the Activity
     * 
    **/
    select?: ActivitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActivityInclude | null
    /**
     * The data needed to update a Activity.
     * 
    **/
    data: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
    /**
     * Choose, which Activity to update.
     * 
    **/
    where: ActivityWhereUniqueInput
  }


  /**
   * Activity updateMany
   */
  export type ActivityUpdateManyArgs = {
    /**
     * The data used to update Activities.
     * 
    **/
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     * 
    **/
    where?: ActivityWhereInput
  }


  /**
   * Activity upsert
   */
  export type ActivityUpsertArgs = {
    /**
     * Select specific fields to fetch from the Activity
     * 
    **/
    select?: ActivitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActivityInclude | null
    /**
     * The filter to search for the Activity to update in case it exists.
     * 
    **/
    where: ActivityWhereUniqueInput
    /**
     * In case the Activity found by the `where` argument doesn't exist, create a new Activity with this data.
     * 
    **/
    create: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
    /**
     * In case the Activity was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
  }


  /**
   * Activity delete
   */
  export type ActivityDeleteArgs = {
    /**
     * Select specific fields to fetch from the Activity
     * 
    **/
    select?: ActivitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActivityInclude | null
    /**
     * Filter which Activity to delete.
     * 
    **/
    where: ActivityWhereUniqueInput
  }


  /**
   * Activity deleteMany
   */
  export type ActivityDeleteManyArgs = {
    /**
     * Filter which Activities to delete
     * 
    **/
    where?: ActivityWhereInput
  }


  /**
   * Activity without action
   */
  export type ActivityArgs = {
    /**
     * Select specific fields to fetch from the Activity
     * 
    **/
    select?: ActivitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActivityInclude | null
  }



  /**
   * Model ActivityRewards
   */


  export type AggregateActivityRewards = {
    _count: ActivityRewardsCountAggregateOutputType | null
    _avg: ActivityRewardsAvgAggregateOutputType | null
    _sum: ActivityRewardsSumAggregateOutputType | null
    _min: ActivityRewardsMinAggregateOutputType | null
    _max: ActivityRewardsMaxAggregateOutputType | null
  }

  export type ActivityRewardsAvgAggregateOutputType = {
    activityID: number | null
    id: number | null
    rewardMinute: number | null
    rewardMinuteCam: number | null
    rewardMinuteLog: number | null
    RewardStreak: number | null
    RewardRestart: number | null
    rewardMin: number | null
    rewardMax: number | null
    reward: number | null
  }

  export type ActivityRewardsSumAggregateOutputType = {
    activityID: number | null
    id: number | null
    rewardMinute: number | null
    rewardMinuteCam: number | null
    rewardMinuteLog: number | null
    RewardStreak: number | null
    RewardRestart: number | null
    rewardMin: number | null
    rewardMax: number | null
    reward: number | null
  }

  export type ActivityRewardsMinAggregateOutputType = {
    activityID: number | null
    id: number | null
    rewardMinute: number | null
    rewardMinuteCam: number | null
    rewardMinuteLog: number | null
    RewardStreak: number | null
    RewardRestart: number | null
    rewardMin: number | null
    rewardMax: number | null
    reward: number | null
  }

  export type ActivityRewardsMaxAggregateOutputType = {
    activityID: number | null
    id: number | null
    rewardMinute: number | null
    rewardMinuteCam: number | null
    rewardMinuteLog: number | null
    RewardStreak: number | null
    RewardRestart: number | null
    rewardMin: number | null
    rewardMax: number | null
    reward: number | null
  }

  export type ActivityRewardsCountAggregateOutputType = {
    activityID: number
    id: number
    rewardMinute: number
    rewardMinuteCam: number
    rewardMinuteLog: number
    RewardStreak: number
    RewardRestart: number
    rewardMin: number
    rewardMax: number
    reward: number
    _all: number
  }


  export type ActivityRewardsAvgAggregateInputType = {
    activityID?: true
    id?: true
    rewardMinute?: true
    rewardMinuteCam?: true
    rewardMinuteLog?: true
    RewardStreak?: true
    RewardRestart?: true
    rewardMin?: true
    rewardMax?: true
    reward?: true
  }

  export type ActivityRewardsSumAggregateInputType = {
    activityID?: true
    id?: true
    rewardMinute?: true
    rewardMinuteCam?: true
    rewardMinuteLog?: true
    RewardStreak?: true
    RewardRestart?: true
    rewardMin?: true
    rewardMax?: true
    reward?: true
  }

  export type ActivityRewardsMinAggregateInputType = {
    activityID?: true
    id?: true
    rewardMinute?: true
    rewardMinuteCam?: true
    rewardMinuteLog?: true
    RewardStreak?: true
    RewardRestart?: true
    rewardMin?: true
    rewardMax?: true
    reward?: true
  }

  export type ActivityRewardsMaxAggregateInputType = {
    activityID?: true
    id?: true
    rewardMinute?: true
    rewardMinuteCam?: true
    rewardMinuteLog?: true
    RewardStreak?: true
    RewardRestart?: true
    rewardMin?: true
    rewardMax?: true
    reward?: true
  }

  export type ActivityRewardsCountAggregateInputType = {
    activityID?: true
    id?: true
    rewardMinute?: true
    rewardMinuteCam?: true
    rewardMinuteLog?: true
    RewardStreak?: true
    RewardRestart?: true
    rewardMin?: true
    rewardMax?: true
    reward?: true
    _all?: true
  }

  export type ActivityRewardsAggregateArgs = {
    /**
     * Filter which ActivityRewards to aggregate.
     * 
    **/
    where?: ActivityRewardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityRewards to fetch.
     * 
    **/
    orderBy?: Enumerable<ActivityRewardsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ActivityRewardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityRewards from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityRewards.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActivityRewards
    **/
    _count?: true | ActivityRewardsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActivityRewardsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActivityRewardsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityRewardsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityRewardsMaxAggregateInputType
  }

  export type GetActivityRewardsAggregateType<T extends ActivityRewardsAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityRewards]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityRewards[P]>
      : GetScalarType<T[P], AggregateActivityRewards[P]>
  }




  export type ActivityRewardsGroupByArgs = {
    where?: ActivityRewardsWhereInput
    orderBy?: Enumerable<ActivityRewardsOrderByWithAggregationInput>
    by: Array<ActivityRewardsScalarFieldEnum>
    having?: ActivityRewardsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityRewardsCountAggregateInputType | true
    _avg?: ActivityRewardsAvgAggregateInputType
    _sum?: ActivityRewardsSumAggregateInputType
    _min?: ActivityRewardsMinAggregateInputType
    _max?: ActivityRewardsMaxAggregateInputType
  }


  export type ActivityRewardsGroupByOutputType = {
    activityID: number
    id: number
    rewardMinute: number
    rewardMinuteCam: number
    rewardMinuteLog: number
    RewardStreak: number
    RewardRestart: number
    rewardMin: number
    rewardMax: number
    reward: number
    _count: ActivityRewardsCountAggregateOutputType | null
    _avg: ActivityRewardsAvgAggregateOutputType | null
    _sum: ActivityRewardsSumAggregateOutputType | null
    _min: ActivityRewardsMinAggregateOutputType | null
    _max: ActivityRewardsMaxAggregateOutputType | null
  }

  type GetActivityRewardsGroupByPayload<T extends ActivityRewardsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ActivityRewardsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityRewardsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityRewardsGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityRewardsGroupByOutputType[P]>
        }
      >
    >


  export type ActivityRewardsSelect = {
    Activity?: boolean | ActivityArgs
    activityID?: boolean
    id?: boolean
    rewardMinute?: boolean
    rewardMinuteCam?: boolean
    rewardMinuteLog?: boolean
    RewardStreak?: boolean
    RewardRestart?: boolean
    rewardMin?: boolean
    rewardMax?: boolean
    reward?: boolean
  }


  export type ActivityRewardsInclude = {
    Activity?: boolean | ActivityArgs
  } 

  export type ActivityRewardsGetPayload<S extends boolean | null | undefined | ActivityRewardsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ActivityRewards :
    S extends undefined ? never :
    S extends { include: any } & (ActivityRewardsArgs | ActivityRewardsFindManyArgs)
    ? ActivityRewards  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Activity' ? ActivityGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ActivityRewardsArgs | ActivityRewardsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Activity' ? ActivityGetPayload<S['select'][P]> :  P extends keyof ActivityRewards ? ActivityRewards[P] : never
  } 
      : ActivityRewards


  type ActivityRewardsCountArgs = Merge<
    Omit<ActivityRewardsFindManyArgs, 'select' | 'include'> & {
      select?: ActivityRewardsCountAggregateInputType | true
    }
  >

  export interface ActivityRewardsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one ActivityRewards that matches the filter.
     * @param {ActivityRewardsFindUniqueArgs} args - Arguments to find a ActivityRewards
     * @example
     * // Get one ActivityRewards
     * const activityRewards = await prisma.activityRewards.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ActivityRewardsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ActivityRewardsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ActivityRewards'> extends True ? Prisma__ActivityRewardsClient<ActivityRewardsGetPayload<T>> : Prisma__ActivityRewardsClient<ActivityRewardsGetPayload<T> | null, null>

    /**
     * Find one ActivityRewards that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ActivityRewardsFindUniqueOrThrowArgs} args - Arguments to find a ActivityRewards
     * @example
     * // Get one ActivityRewards
     * const activityRewards = await prisma.activityRewards.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ActivityRewardsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ActivityRewardsFindUniqueOrThrowArgs>
    ): Prisma__ActivityRewardsClient<ActivityRewardsGetPayload<T>>

    /**
     * Find the first ActivityRewards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityRewardsFindFirstArgs} args - Arguments to find a ActivityRewards
     * @example
     * // Get one ActivityRewards
     * const activityRewards = await prisma.activityRewards.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ActivityRewardsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ActivityRewardsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ActivityRewards'> extends True ? Prisma__ActivityRewardsClient<ActivityRewardsGetPayload<T>> : Prisma__ActivityRewardsClient<ActivityRewardsGetPayload<T> | null, null>

    /**
     * Find the first ActivityRewards that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityRewardsFindFirstOrThrowArgs} args - Arguments to find a ActivityRewards
     * @example
     * // Get one ActivityRewards
     * const activityRewards = await prisma.activityRewards.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ActivityRewardsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ActivityRewardsFindFirstOrThrowArgs>
    ): Prisma__ActivityRewardsClient<ActivityRewardsGetPayload<T>>

    /**
     * Find zero or more ActivityRewards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityRewardsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityRewards
     * const activityRewards = await prisma.activityRewards.findMany()
     * 
     * // Get first 10 ActivityRewards
     * const activityRewards = await prisma.activityRewards.findMany({ take: 10 })
     * 
     * // Only select the `activityID`
     * const activityRewardsWithActivityIDOnly = await prisma.activityRewards.findMany({ select: { activityID: true } })
     * 
    **/
    findMany<T extends ActivityRewardsFindManyArgs>(
      args?: SelectSubset<T, ActivityRewardsFindManyArgs>
    ): PrismaPromise<Array<ActivityRewardsGetPayload<T>>>

    /**
     * Create a ActivityRewards.
     * @param {ActivityRewardsCreateArgs} args - Arguments to create a ActivityRewards.
     * @example
     * // Create one ActivityRewards
     * const ActivityRewards = await prisma.activityRewards.create({
     *   data: {
     *     // ... data to create a ActivityRewards
     *   }
     * })
     * 
    **/
    create<T extends ActivityRewardsCreateArgs>(
      args: SelectSubset<T, ActivityRewardsCreateArgs>
    ): Prisma__ActivityRewardsClient<ActivityRewardsGetPayload<T>>

    /**
     * Create many ActivityRewards.
     *     @param {ActivityRewardsCreateManyArgs} args - Arguments to create many ActivityRewards.
     *     @example
     *     // Create many ActivityRewards
     *     const activityRewards = await prisma.activityRewards.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ActivityRewardsCreateManyArgs>(
      args?: SelectSubset<T, ActivityRewardsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ActivityRewards.
     * @param {ActivityRewardsDeleteArgs} args - Arguments to delete one ActivityRewards.
     * @example
     * // Delete one ActivityRewards
     * const ActivityRewards = await prisma.activityRewards.delete({
     *   where: {
     *     // ... filter to delete one ActivityRewards
     *   }
     * })
     * 
    **/
    delete<T extends ActivityRewardsDeleteArgs>(
      args: SelectSubset<T, ActivityRewardsDeleteArgs>
    ): Prisma__ActivityRewardsClient<ActivityRewardsGetPayload<T>>

    /**
     * Update one ActivityRewards.
     * @param {ActivityRewardsUpdateArgs} args - Arguments to update one ActivityRewards.
     * @example
     * // Update one ActivityRewards
     * const activityRewards = await prisma.activityRewards.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ActivityRewardsUpdateArgs>(
      args: SelectSubset<T, ActivityRewardsUpdateArgs>
    ): Prisma__ActivityRewardsClient<ActivityRewardsGetPayload<T>>

    /**
     * Delete zero or more ActivityRewards.
     * @param {ActivityRewardsDeleteManyArgs} args - Arguments to filter ActivityRewards to delete.
     * @example
     * // Delete a few ActivityRewards
     * const { count } = await prisma.activityRewards.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ActivityRewardsDeleteManyArgs>(
      args?: SelectSubset<T, ActivityRewardsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityRewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityRewardsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityRewards
     * const activityRewards = await prisma.activityRewards.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ActivityRewardsUpdateManyArgs>(
      args: SelectSubset<T, ActivityRewardsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ActivityRewards.
     * @param {ActivityRewardsUpsertArgs} args - Arguments to update or create a ActivityRewards.
     * @example
     * // Update or create a ActivityRewards
     * const activityRewards = await prisma.activityRewards.upsert({
     *   create: {
     *     // ... data to create a ActivityRewards
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityRewards we want to update
     *   }
     * })
    **/
    upsert<T extends ActivityRewardsUpsertArgs>(
      args: SelectSubset<T, ActivityRewardsUpsertArgs>
    ): Prisma__ActivityRewardsClient<ActivityRewardsGetPayload<T>>

    /**
     * Count the number of ActivityRewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityRewardsCountArgs} args - Arguments to filter ActivityRewards to count.
     * @example
     * // Count the number of ActivityRewards
     * const count = await prisma.activityRewards.count({
     *   where: {
     *     // ... the filter for the ActivityRewards we want to count
     *   }
     * })
    **/
    count<T extends ActivityRewardsCountArgs>(
      args?: Subset<T, ActivityRewardsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityRewardsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityRewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityRewardsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityRewardsAggregateArgs>(args: Subset<T, ActivityRewardsAggregateArgs>): PrismaPromise<GetActivityRewardsAggregateType<T>>

    /**
     * Group by ActivityRewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityRewardsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityRewardsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityRewardsGroupByArgs['orderBy'] }
        : { orderBy?: ActivityRewardsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityRewardsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityRewardsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivityRewards.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ActivityRewardsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Activity<T extends ActivityArgs= {}>(args?: Subset<T, ActivityArgs>): Prisma__ActivityClient<ActivityGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ActivityRewards base type for findUnique actions
   */
  export type ActivityRewardsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ActivityRewards
     * 
    **/
    select?: ActivityRewardsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActivityRewardsInclude | null
    /**
     * Filter, which ActivityRewards to fetch.
     * 
    **/
    where: ActivityRewardsWhereUniqueInput
  }

  /**
   * ActivityRewards: findUnique
   */
  export interface ActivityRewardsFindUniqueArgs extends ActivityRewardsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ActivityRewards findUniqueOrThrow
   */
  export type ActivityRewardsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ActivityRewards
     * 
    **/
    select?: ActivityRewardsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActivityRewardsInclude | null
    /**
     * Filter, which ActivityRewards to fetch.
     * 
    **/
    where: ActivityRewardsWhereUniqueInput
  }


  /**
   * ActivityRewards base type for findFirst actions
   */
  export type ActivityRewardsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ActivityRewards
     * 
    **/
    select?: ActivityRewardsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActivityRewardsInclude | null
    /**
     * Filter, which ActivityRewards to fetch.
     * 
    **/
    where?: ActivityRewardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityRewards to fetch.
     * 
    **/
    orderBy?: Enumerable<ActivityRewardsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityRewards.
     * 
    **/
    cursor?: ActivityRewardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityRewards from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityRewards.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityRewards.
     * 
    **/
    distinct?: Enumerable<ActivityRewardsScalarFieldEnum>
  }

  /**
   * ActivityRewards: findFirst
   */
  export interface ActivityRewardsFindFirstArgs extends ActivityRewardsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ActivityRewards findFirstOrThrow
   */
  export type ActivityRewardsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ActivityRewards
     * 
    **/
    select?: ActivityRewardsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActivityRewardsInclude | null
    /**
     * Filter, which ActivityRewards to fetch.
     * 
    **/
    where?: ActivityRewardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityRewards to fetch.
     * 
    **/
    orderBy?: Enumerable<ActivityRewardsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityRewards.
     * 
    **/
    cursor?: ActivityRewardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityRewards from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityRewards.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityRewards.
     * 
    **/
    distinct?: Enumerable<ActivityRewardsScalarFieldEnum>
  }


  /**
   * ActivityRewards findMany
   */
  export type ActivityRewardsFindManyArgs = {
    /**
     * Select specific fields to fetch from the ActivityRewards
     * 
    **/
    select?: ActivityRewardsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActivityRewardsInclude | null
    /**
     * Filter, which ActivityRewards to fetch.
     * 
    **/
    where?: ActivityRewardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityRewards to fetch.
     * 
    **/
    orderBy?: Enumerable<ActivityRewardsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActivityRewards.
     * 
    **/
    cursor?: ActivityRewardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityRewards from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityRewards.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ActivityRewardsScalarFieldEnum>
  }


  /**
   * ActivityRewards create
   */
  export type ActivityRewardsCreateArgs = {
    /**
     * Select specific fields to fetch from the ActivityRewards
     * 
    **/
    select?: ActivityRewardsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActivityRewardsInclude | null
    /**
     * The data needed to create a ActivityRewards.
     * 
    **/
    data: XOR<ActivityRewardsCreateInput, ActivityRewardsUncheckedCreateInput>
  }


  /**
   * ActivityRewards createMany
   */
  export type ActivityRewardsCreateManyArgs = {
    /**
     * The data used to create many ActivityRewards.
     * 
    **/
    data: Enumerable<ActivityRewardsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ActivityRewards update
   */
  export type ActivityRewardsUpdateArgs = {
    /**
     * Select specific fields to fetch from the ActivityRewards
     * 
    **/
    select?: ActivityRewardsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActivityRewardsInclude | null
    /**
     * The data needed to update a ActivityRewards.
     * 
    **/
    data: XOR<ActivityRewardsUpdateInput, ActivityRewardsUncheckedUpdateInput>
    /**
     * Choose, which ActivityRewards to update.
     * 
    **/
    where: ActivityRewardsWhereUniqueInput
  }


  /**
   * ActivityRewards updateMany
   */
  export type ActivityRewardsUpdateManyArgs = {
    /**
     * The data used to update ActivityRewards.
     * 
    **/
    data: XOR<ActivityRewardsUpdateManyMutationInput, ActivityRewardsUncheckedUpdateManyInput>
    /**
     * Filter which ActivityRewards to update
     * 
    **/
    where?: ActivityRewardsWhereInput
  }


  /**
   * ActivityRewards upsert
   */
  export type ActivityRewardsUpsertArgs = {
    /**
     * Select specific fields to fetch from the ActivityRewards
     * 
    **/
    select?: ActivityRewardsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActivityRewardsInclude | null
    /**
     * The filter to search for the ActivityRewards to update in case it exists.
     * 
    **/
    where: ActivityRewardsWhereUniqueInput
    /**
     * In case the ActivityRewards found by the `where` argument doesn't exist, create a new ActivityRewards with this data.
     * 
    **/
    create: XOR<ActivityRewardsCreateInput, ActivityRewardsUncheckedCreateInput>
    /**
     * In case the ActivityRewards was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ActivityRewardsUpdateInput, ActivityRewardsUncheckedUpdateInput>
  }


  /**
   * ActivityRewards delete
   */
  export type ActivityRewardsDeleteArgs = {
    /**
     * Select specific fields to fetch from the ActivityRewards
     * 
    **/
    select?: ActivityRewardsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActivityRewardsInclude | null
    /**
     * Filter which ActivityRewards to delete.
     * 
    **/
    where: ActivityRewardsWhereUniqueInput
  }


  /**
   * ActivityRewards deleteMany
   */
  export type ActivityRewardsDeleteManyArgs = {
    /**
     * Filter which ActivityRewards to delete
     * 
    **/
    where?: ActivityRewardsWhereInput
  }


  /**
   * ActivityRewards without action
   */
  export type ActivityRewardsArgs = {
    /**
     * Select specific fields to fetch from the ActivityRewards
     * 
    **/
    select?: ActivityRewardsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActivityRewardsInclude | null
  }



  /**
   * Model logsNow
   */


  export type AggregateLogsNow = {
    _count: LogsNowCountAggregateOutputType | null
    _avg: LogsNowAvgAggregateOutputType | null
    _sum: LogsNowSumAggregateOutputType | null
    _min: LogsNowMinAggregateOutputType | null
    _max: LogsNowMaxAggregateOutputType | null
  }

  export type LogsNowAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    activityId: number | null
  }

  export type LogsNowSumAggregateOutputType = {
    id: number | null
    userId: number | null
    activityId: number | null
  }

  export type LogsNowMinAggregateOutputType = {
    id: number | null
    timestamp: Date | null
    type: ActivityType | null
    userId: number | null
    activityId: number | null
    guildId: string | null
  }

  export type LogsNowMaxAggregateOutputType = {
    id: number | null
    timestamp: Date | null
    type: ActivityType | null
    userId: number | null
    activityId: number | null
    guildId: string | null
  }

  export type LogsNowCountAggregateOutputType = {
    id: number
    timestamp: number
    type: number
    userId: number
    activityId: number
    guildId: number
    _all: number
  }


  export type LogsNowAvgAggregateInputType = {
    id?: true
    userId?: true
    activityId?: true
  }

  export type LogsNowSumAggregateInputType = {
    id?: true
    userId?: true
    activityId?: true
  }

  export type LogsNowMinAggregateInputType = {
    id?: true
    timestamp?: true
    type?: true
    userId?: true
    activityId?: true
    guildId?: true
  }

  export type LogsNowMaxAggregateInputType = {
    id?: true
    timestamp?: true
    type?: true
    userId?: true
    activityId?: true
    guildId?: true
  }

  export type LogsNowCountAggregateInputType = {
    id?: true
    timestamp?: true
    type?: true
    userId?: true
    activityId?: true
    guildId?: true
    _all?: true
  }

  export type LogsNowAggregateArgs = {
    /**
     * Filter which logsNow to aggregate.
     * 
    **/
    where?: logsNowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logsNows to fetch.
     * 
    **/
    orderBy?: Enumerable<logsNowOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: logsNowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logsNows from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logsNows.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned logsNows
    **/
    _count?: true | LogsNowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LogsNowAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LogsNowSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogsNowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogsNowMaxAggregateInputType
  }

  export type GetLogsNowAggregateType<T extends LogsNowAggregateArgs> = {
        [P in keyof T & keyof AggregateLogsNow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogsNow[P]>
      : GetScalarType<T[P], AggregateLogsNow[P]>
  }




  export type LogsNowGroupByArgs = {
    where?: logsNowWhereInput
    orderBy?: Enumerable<logsNowOrderByWithAggregationInput>
    by: Array<LogsNowScalarFieldEnum>
    having?: logsNowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogsNowCountAggregateInputType | true
    _avg?: LogsNowAvgAggregateInputType
    _sum?: LogsNowSumAggregateInputType
    _min?: LogsNowMinAggregateInputType
    _max?: LogsNowMaxAggregateInputType
  }


  export type LogsNowGroupByOutputType = {
    id: number
    timestamp: Date
    type: ActivityType
    userId: number
    activityId: number
    guildId: string
    _count: LogsNowCountAggregateOutputType | null
    _avg: LogsNowAvgAggregateOutputType | null
    _sum: LogsNowSumAggregateOutputType | null
    _min: LogsNowMinAggregateOutputType | null
    _max: LogsNowMaxAggregateOutputType | null
  }

  type GetLogsNowGroupByPayload<T extends LogsNowGroupByArgs> = PrismaPromise<
    Array<
      PickArray<LogsNowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogsNowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogsNowGroupByOutputType[P]>
            : GetScalarType<T[P], LogsNowGroupByOutputType[P]>
        }
      >
    >


  export type logsNowSelect = {
    id?: boolean
    user?: boolean | UserArgs
    activity?: boolean | ActivityArgs
    guild?: boolean | GuildArgs
    timestamp?: boolean
    type?: boolean
    userId?: boolean
    activityId?: boolean
    guildId?: boolean
  }


  export type logsNowInclude = {
    user?: boolean | UserArgs
    activity?: boolean | ActivityArgs
    guild?: boolean | GuildArgs
  } 

  export type logsNowGetPayload<S extends boolean | null | undefined | logsNowArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? logsNow :
    S extends undefined ? never :
    S extends { include: any } & (logsNowArgs | logsNowFindManyArgs)
    ? logsNow  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends 'activity' ? ActivityGetPayload<S['include'][P]> :
        P extends 'guild' ? GuildGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (logsNowArgs | logsNowFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends 'activity' ? ActivityGetPayload<S['select'][P]> :
        P extends 'guild' ? GuildGetPayload<S['select'][P]> :  P extends keyof logsNow ? logsNow[P] : never
  } 
      : logsNow


  type logsNowCountArgs = Merge<
    Omit<logsNowFindManyArgs, 'select' | 'include'> & {
      select?: LogsNowCountAggregateInputType | true
    }
  >

  export interface logsNowDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one LogsNow that matches the filter.
     * @param {logsNowFindUniqueArgs} args - Arguments to find a LogsNow
     * @example
     * // Get one LogsNow
     * const logsNow = await prisma.logsNow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends logsNowFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, logsNowFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'logsNow'> extends True ? Prisma__logsNowClient<logsNowGetPayload<T>> : Prisma__logsNowClient<logsNowGetPayload<T> | null, null>

    /**
     * Find one LogsNow that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {logsNowFindUniqueOrThrowArgs} args - Arguments to find a LogsNow
     * @example
     * // Get one LogsNow
     * const logsNow = await prisma.logsNow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends logsNowFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, logsNowFindUniqueOrThrowArgs>
    ): Prisma__logsNowClient<logsNowGetPayload<T>>

    /**
     * Find the first LogsNow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logsNowFindFirstArgs} args - Arguments to find a LogsNow
     * @example
     * // Get one LogsNow
     * const logsNow = await prisma.logsNow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends logsNowFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, logsNowFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'logsNow'> extends True ? Prisma__logsNowClient<logsNowGetPayload<T>> : Prisma__logsNowClient<logsNowGetPayload<T> | null, null>

    /**
     * Find the first LogsNow that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logsNowFindFirstOrThrowArgs} args - Arguments to find a LogsNow
     * @example
     * // Get one LogsNow
     * const logsNow = await prisma.logsNow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends logsNowFindFirstOrThrowArgs>(
      args?: SelectSubset<T, logsNowFindFirstOrThrowArgs>
    ): Prisma__logsNowClient<logsNowGetPayload<T>>

    /**
     * Find zero or more LogsNows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logsNowFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LogsNows
     * const logsNows = await prisma.logsNow.findMany()
     * 
     * // Get first 10 LogsNows
     * const logsNows = await prisma.logsNow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logsNowWithIdOnly = await prisma.logsNow.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends logsNowFindManyArgs>(
      args?: SelectSubset<T, logsNowFindManyArgs>
    ): PrismaPromise<Array<logsNowGetPayload<T>>>

    /**
     * Create a LogsNow.
     * @param {logsNowCreateArgs} args - Arguments to create a LogsNow.
     * @example
     * // Create one LogsNow
     * const LogsNow = await prisma.logsNow.create({
     *   data: {
     *     // ... data to create a LogsNow
     *   }
     * })
     * 
    **/
    create<T extends logsNowCreateArgs>(
      args: SelectSubset<T, logsNowCreateArgs>
    ): Prisma__logsNowClient<logsNowGetPayload<T>>

    /**
     * Create many LogsNows.
     *     @param {logsNowCreateManyArgs} args - Arguments to create many LogsNows.
     *     @example
     *     // Create many LogsNows
     *     const logsNow = await prisma.logsNow.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends logsNowCreateManyArgs>(
      args?: SelectSubset<T, logsNowCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a LogsNow.
     * @param {logsNowDeleteArgs} args - Arguments to delete one LogsNow.
     * @example
     * // Delete one LogsNow
     * const LogsNow = await prisma.logsNow.delete({
     *   where: {
     *     // ... filter to delete one LogsNow
     *   }
     * })
     * 
    **/
    delete<T extends logsNowDeleteArgs>(
      args: SelectSubset<T, logsNowDeleteArgs>
    ): Prisma__logsNowClient<logsNowGetPayload<T>>

    /**
     * Update one LogsNow.
     * @param {logsNowUpdateArgs} args - Arguments to update one LogsNow.
     * @example
     * // Update one LogsNow
     * const logsNow = await prisma.logsNow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends logsNowUpdateArgs>(
      args: SelectSubset<T, logsNowUpdateArgs>
    ): Prisma__logsNowClient<logsNowGetPayload<T>>

    /**
     * Delete zero or more LogsNows.
     * @param {logsNowDeleteManyArgs} args - Arguments to filter LogsNows to delete.
     * @example
     * // Delete a few LogsNows
     * const { count } = await prisma.logsNow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends logsNowDeleteManyArgs>(
      args?: SelectSubset<T, logsNowDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more LogsNows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logsNowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LogsNows
     * const logsNow = await prisma.logsNow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends logsNowUpdateManyArgs>(
      args: SelectSubset<T, logsNowUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one LogsNow.
     * @param {logsNowUpsertArgs} args - Arguments to update or create a LogsNow.
     * @example
     * // Update or create a LogsNow
     * const logsNow = await prisma.logsNow.upsert({
     *   create: {
     *     // ... data to create a LogsNow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LogsNow we want to update
     *   }
     * })
    **/
    upsert<T extends logsNowUpsertArgs>(
      args: SelectSubset<T, logsNowUpsertArgs>
    ): Prisma__logsNowClient<logsNowGetPayload<T>>

    /**
     * Count the number of LogsNows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logsNowCountArgs} args - Arguments to filter LogsNows to count.
     * @example
     * // Count the number of LogsNows
     * const count = await prisma.logsNow.count({
     *   where: {
     *     // ... the filter for the LogsNows we want to count
     *   }
     * })
    **/
    count<T extends logsNowCountArgs>(
      args?: Subset<T, logsNowCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogsNowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LogsNow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsNowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogsNowAggregateArgs>(args: Subset<T, LogsNowAggregateArgs>): PrismaPromise<GetLogsNowAggregateType<T>>

    /**
     * Group by LogsNow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsNowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogsNowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogsNowGroupByArgs['orderBy'] }
        : { orderBy?: LogsNowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogsNowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogsNowGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for logsNow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__logsNowClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    activity<T extends ActivityArgs= {}>(args?: Subset<T, ActivityArgs>): Prisma__ActivityClient<ActivityGetPayload<T> | Null>;

    guild<T extends GuildArgs= {}>(args?: Subset<T, GuildArgs>): Prisma__GuildClient<GuildGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * logsNow base type for findUnique actions
   */
  export type logsNowFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the logsNow
     * 
    **/
    select?: logsNowSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: logsNowInclude | null
    /**
     * Filter, which logsNow to fetch.
     * 
    **/
    where: logsNowWhereUniqueInput
  }

  /**
   * logsNow: findUnique
   */
  export interface logsNowFindUniqueArgs extends logsNowFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * logsNow findUniqueOrThrow
   */
  export type logsNowFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the logsNow
     * 
    **/
    select?: logsNowSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: logsNowInclude | null
    /**
     * Filter, which logsNow to fetch.
     * 
    **/
    where: logsNowWhereUniqueInput
  }


  /**
   * logsNow base type for findFirst actions
   */
  export type logsNowFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the logsNow
     * 
    **/
    select?: logsNowSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: logsNowInclude | null
    /**
     * Filter, which logsNow to fetch.
     * 
    **/
    where?: logsNowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logsNows to fetch.
     * 
    **/
    orderBy?: Enumerable<logsNowOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for logsNows.
     * 
    **/
    cursor?: logsNowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logsNows from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logsNows.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of logsNows.
     * 
    **/
    distinct?: Enumerable<LogsNowScalarFieldEnum>
  }

  /**
   * logsNow: findFirst
   */
  export interface logsNowFindFirstArgs extends logsNowFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * logsNow findFirstOrThrow
   */
  export type logsNowFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the logsNow
     * 
    **/
    select?: logsNowSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: logsNowInclude | null
    /**
     * Filter, which logsNow to fetch.
     * 
    **/
    where?: logsNowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logsNows to fetch.
     * 
    **/
    orderBy?: Enumerable<logsNowOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for logsNows.
     * 
    **/
    cursor?: logsNowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logsNows from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logsNows.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of logsNows.
     * 
    **/
    distinct?: Enumerable<LogsNowScalarFieldEnum>
  }


  /**
   * logsNow findMany
   */
  export type logsNowFindManyArgs = {
    /**
     * Select specific fields to fetch from the logsNow
     * 
    **/
    select?: logsNowSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: logsNowInclude | null
    /**
     * Filter, which logsNows to fetch.
     * 
    **/
    where?: logsNowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logsNows to fetch.
     * 
    **/
    orderBy?: Enumerable<logsNowOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing logsNows.
     * 
    **/
    cursor?: logsNowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logsNows from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logsNows.
     * 
    **/
    skip?: number
    distinct?: Enumerable<LogsNowScalarFieldEnum>
  }


  /**
   * logsNow create
   */
  export type logsNowCreateArgs = {
    /**
     * Select specific fields to fetch from the logsNow
     * 
    **/
    select?: logsNowSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: logsNowInclude | null
    /**
     * The data needed to create a logsNow.
     * 
    **/
    data: XOR<logsNowCreateInput, logsNowUncheckedCreateInput>
  }


  /**
   * logsNow createMany
   */
  export type logsNowCreateManyArgs = {
    /**
     * The data used to create many logsNows.
     * 
    **/
    data: Enumerable<logsNowCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * logsNow update
   */
  export type logsNowUpdateArgs = {
    /**
     * Select specific fields to fetch from the logsNow
     * 
    **/
    select?: logsNowSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: logsNowInclude | null
    /**
     * The data needed to update a logsNow.
     * 
    **/
    data: XOR<logsNowUpdateInput, logsNowUncheckedUpdateInput>
    /**
     * Choose, which logsNow to update.
     * 
    **/
    where: logsNowWhereUniqueInput
  }


  /**
   * logsNow updateMany
   */
  export type logsNowUpdateManyArgs = {
    /**
     * The data used to update logsNows.
     * 
    **/
    data: XOR<logsNowUpdateManyMutationInput, logsNowUncheckedUpdateManyInput>
    /**
     * Filter which logsNows to update
     * 
    **/
    where?: logsNowWhereInput
  }


  /**
   * logsNow upsert
   */
  export type logsNowUpsertArgs = {
    /**
     * Select specific fields to fetch from the logsNow
     * 
    **/
    select?: logsNowSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: logsNowInclude | null
    /**
     * The filter to search for the logsNow to update in case it exists.
     * 
    **/
    where: logsNowWhereUniqueInput
    /**
     * In case the logsNow found by the `where` argument doesn't exist, create a new logsNow with this data.
     * 
    **/
    create: XOR<logsNowCreateInput, logsNowUncheckedCreateInput>
    /**
     * In case the logsNow was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<logsNowUpdateInput, logsNowUncheckedUpdateInput>
  }


  /**
   * logsNow delete
   */
  export type logsNowDeleteArgs = {
    /**
     * Select specific fields to fetch from the logsNow
     * 
    **/
    select?: logsNowSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: logsNowInclude | null
    /**
     * Filter which logsNow to delete.
     * 
    **/
    where: logsNowWhereUniqueInput
  }


  /**
   * logsNow deleteMany
   */
  export type logsNowDeleteManyArgs = {
    /**
     * Filter which logsNows to delete
     * 
    **/
    where?: logsNowWhereInput
  }


  /**
   * logsNow without action
   */
  export type logsNowArgs = {
    /**
     * Select specific fields to fetch from the logsNow
     * 
    **/
    select?: logsNowSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: logsNowInclude | null
  }



  /**
   * Model historicLogs
   */


  export type AggregateHistoricLogs = {
    _count: HistoricLogsCountAggregateOutputType | null
    _avg: HistoricLogsAvgAggregateOutputType | null
    _sum: HistoricLogsSumAggregateOutputType | null
    _min: HistoricLogsMinAggregateOutputType | null
    _max: HistoricLogsMaxAggregateOutputType | null
  }

  export type HistoricLogsAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    activityId: number | null
  }

  export type HistoricLogsSumAggregateOutputType = {
    id: number | null
    userId: number | null
    activityId: number | null
  }

  export type HistoricLogsMinAggregateOutputType = {
    id: number | null
    date: Date | null
    type: ActivityType | null
    timeframe: Timeframe | null
    userId: number | null
    activityId: number | null
    guildId: string | null
  }

  export type HistoricLogsMaxAggregateOutputType = {
    id: number | null
    date: Date | null
    type: ActivityType | null
    timeframe: Timeframe | null
    userId: number | null
    activityId: number | null
    guildId: string | null
  }

  export type HistoricLogsCountAggregateOutputType = {
    id: number
    date: number
    type: number
    timeframe: number
    userId: number
    activityId: number
    guildId: number
    _all: number
  }


  export type HistoricLogsAvgAggregateInputType = {
    id?: true
    userId?: true
    activityId?: true
  }

  export type HistoricLogsSumAggregateInputType = {
    id?: true
    userId?: true
    activityId?: true
  }

  export type HistoricLogsMinAggregateInputType = {
    id?: true
    date?: true
    type?: true
    timeframe?: true
    userId?: true
    activityId?: true
    guildId?: true
  }

  export type HistoricLogsMaxAggregateInputType = {
    id?: true
    date?: true
    type?: true
    timeframe?: true
    userId?: true
    activityId?: true
    guildId?: true
  }

  export type HistoricLogsCountAggregateInputType = {
    id?: true
    date?: true
    type?: true
    timeframe?: true
    userId?: true
    activityId?: true
    guildId?: true
    _all?: true
  }

  export type HistoricLogsAggregateArgs = {
    /**
     * Filter which historicLogs to aggregate.
     * 
    **/
    where?: historicLogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historicLogs to fetch.
     * 
    **/
    orderBy?: Enumerable<historicLogsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: historicLogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historicLogs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historicLogs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned historicLogs
    **/
    _count?: true | HistoricLogsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HistoricLogsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HistoricLogsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HistoricLogsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HistoricLogsMaxAggregateInputType
  }

  export type GetHistoricLogsAggregateType<T extends HistoricLogsAggregateArgs> = {
        [P in keyof T & keyof AggregateHistoricLogs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHistoricLogs[P]>
      : GetScalarType<T[P], AggregateHistoricLogs[P]>
  }




  export type HistoricLogsGroupByArgs = {
    where?: historicLogsWhereInput
    orderBy?: Enumerable<historicLogsOrderByWithAggregationInput>
    by: Array<HistoricLogsScalarFieldEnum>
    having?: historicLogsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HistoricLogsCountAggregateInputType | true
    _avg?: HistoricLogsAvgAggregateInputType
    _sum?: HistoricLogsSumAggregateInputType
    _min?: HistoricLogsMinAggregateInputType
    _max?: HistoricLogsMaxAggregateInputType
  }


  export type HistoricLogsGroupByOutputType = {
    id: number
    date: Date
    type: ActivityType
    timeframe: Timeframe
    userId: number
    activityId: number
    guildId: string
    _count: HistoricLogsCountAggregateOutputType | null
    _avg: HistoricLogsAvgAggregateOutputType | null
    _sum: HistoricLogsSumAggregateOutputType | null
    _min: HistoricLogsMinAggregateOutputType | null
    _max: HistoricLogsMaxAggregateOutputType | null
  }

  type GetHistoricLogsGroupByPayload<T extends HistoricLogsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<HistoricLogsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HistoricLogsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HistoricLogsGroupByOutputType[P]>
            : GetScalarType<T[P], HistoricLogsGroupByOutputType[P]>
        }
      >
    >


  export type historicLogsSelect = {
    id?: boolean
    user?: boolean | UserArgs
    activity?: boolean | ActivityArgs
    guild?: boolean | GuildArgs
    date?: boolean
    type?: boolean
    timeframe?: boolean
    userId?: boolean
    activityId?: boolean
    guildId?: boolean
  }


  export type historicLogsInclude = {
    user?: boolean | UserArgs
    activity?: boolean | ActivityArgs
    guild?: boolean | GuildArgs
  } 

  export type historicLogsGetPayload<S extends boolean | null | undefined | historicLogsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? historicLogs :
    S extends undefined ? never :
    S extends { include: any } & (historicLogsArgs | historicLogsFindManyArgs)
    ? historicLogs  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends 'activity' ? ActivityGetPayload<S['include'][P]> :
        P extends 'guild' ? GuildGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (historicLogsArgs | historicLogsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends 'activity' ? ActivityGetPayload<S['select'][P]> :
        P extends 'guild' ? GuildGetPayload<S['select'][P]> :  P extends keyof historicLogs ? historicLogs[P] : never
  } 
      : historicLogs


  type historicLogsCountArgs = Merge<
    Omit<historicLogsFindManyArgs, 'select' | 'include'> & {
      select?: HistoricLogsCountAggregateInputType | true
    }
  >

  export interface historicLogsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one HistoricLogs that matches the filter.
     * @param {historicLogsFindUniqueArgs} args - Arguments to find a HistoricLogs
     * @example
     * // Get one HistoricLogs
     * const historicLogs = await prisma.historicLogs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends historicLogsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, historicLogsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'historicLogs'> extends True ? Prisma__historicLogsClient<historicLogsGetPayload<T>> : Prisma__historicLogsClient<historicLogsGetPayload<T> | null, null>

    /**
     * Find one HistoricLogs that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {historicLogsFindUniqueOrThrowArgs} args - Arguments to find a HistoricLogs
     * @example
     * // Get one HistoricLogs
     * const historicLogs = await prisma.historicLogs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends historicLogsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, historicLogsFindUniqueOrThrowArgs>
    ): Prisma__historicLogsClient<historicLogsGetPayload<T>>

    /**
     * Find the first HistoricLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historicLogsFindFirstArgs} args - Arguments to find a HistoricLogs
     * @example
     * // Get one HistoricLogs
     * const historicLogs = await prisma.historicLogs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends historicLogsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, historicLogsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'historicLogs'> extends True ? Prisma__historicLogsClient<historicLogsGetPayload<T>> : Prisma__historicLogsClient<historicLogsGetPayload<T> | null, null>

    /**
     * Find the first HistoricLogs that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historicLogsFindFirstOrThrowArgs} args - Arguments to find a HistoricLogs
     * @example
     * // Get one HistoricLogs
     * const historicLogs = await prisma.historicLogs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends historicLogsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, historicLogsFindFirstOrThrowArgs>
    ): Prisma__historicLogsClient<historicLogsGetPayload<T>>

    /**
     * Find zero or more HistoricLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historicLogsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HistoricLogs
     * const historicLogs = await prisma.historicLogs.findMany()
     * 
     * // Get first 10 HistoricLogs
     * const historicLogs = await prisma.historicLogs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const historicLogsWithIdOnly = await prisma.historicLogs.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends historicLogsFindManyArgs>(
      args?: SelectSubset<T, historicLogsFindManyArgs>
    ): PrismaPromise<Array<historicLogsGetPayload<T>>>

    /**
     * Create a HistoricLogs.
     * @param {historicLogsCreateArgs} args - Arguments to create a HistoricLogs.
     * @example
     * // Create one HistoricLogs
     * const HistoricLogs = await prisma.historicLogs.create({
     *   data: {
     *     // ... data to create a HistoricLogs
     *   }
     * })
     * 
    **/
    create<T extends historicLogsCreateArgs>(
      args: SelectSubset<T, historicLogsCreateArgs>
    ): Prisma__historicLogsClient<historicLogsGetPayload<T>>

    /**
     * Create many HistoricLogs.
     *     @param {historicLogsCreateManyArgs} args - Arguments to create many HistoricLogs.
     *     @example
     *     // Create many HistoricLogs
     *     const historicLogs = await prisma.historicLogs.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends historicLogsCreateManyArgs>(
      args?: SelectSubset<T, historicLogsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a HistoricLogs.
     * @param {historicLogsDeleteArgs} args - Arguments to delete one HistoricLogs.
     * @example
     * // Delete one HistoricLogs
     * const HistoricLogs = await prisma.historicLogs.delete({
     *   where: {
     *     // ... filter to delete one HistoricLogs
     *   }
     * })
     * 
    **/
    delete<T extends historicLogsDeleteArgs>(
      args: SelectSubset<T, historicLogsDeleteArgs>
    ): Prisma__historicLogsClient<historicLogsGetPayload<T>>

    /**
     * Update one HistoricLogs.
     * @param {historicLogsUpdateArgs} args - Arguments to update one HistoricLogs.
     * @example
     * // Update one HistoricLogs
     * const historicLogs = await prisma.historicLogs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends historicLogsUpdateArgs>(
      args: SelectSubset<T, historicLogsUpdateArgs>
    ): Prisma__historicLogsClient<historicLogsGetPayload<T>>

    /**
     * Delete zero or more HistoricLogs.
     * @param {historicLogsDeleteManyArgs} args - Arguments to filter HistoricLogs to delete.
     * @example
     * // Delete a few HistoricLogs
     * const { count } = await prisma.historicLogs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends historicLogsDeleteManyArgs>(
      args?: SelectSubset<T, historicLogsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more HistoricLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historicLogsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HistoricLogs
     * const historicLogs = await prisma.historicLogs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends historicLogsUpdateManyArgs>(
      args: SelectSubset<T, historicLogsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one HistoricLogs.
     * @param {historicLogsUpsertArgs} args - Arguments to update or create a HistoricLogs.
     * @example
     * // Update or create a HistoricLogs
     * const historicLogs = await prisma.historicLogs.upsert({
     *   create: {
     *     // ... data to create a HistoricLogs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HistoricLogs we want to update
     *   }
     * })
    **/
    upsert<T extends historicLogsUpsertArgs>(
      args: SelectSubset<T, historicLogsUpsertArgs>
    ): Prisma__historicLogsClient<historicLogsGetPayload<T>>

    /**
     * Count the number of HistoricLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historicLogsCountArgs} args - Arguments to filter HistoricLogs to count.
     * @example
     * // Count the number of HistoricLogs
     * const count = await prisma.historicLogs.count({
     *   where: {
     *     // ... the filter for the HistoricLogs we want to count
     *   }
     * })
    **/
    count<T extends historicLogsCountArgs>(
      args?: Subset<T, historicLogsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HistoricLogsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HistoricLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoricLogsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HistoricLogsAggregateArgs>(args: Subset<T, HistoricLogsAggregateArgs>): PrismaPromise<GetHistoricLogsAggregateType<T>>

    /**
     * Group by HistoricLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoricLogsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HistoricLogsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HistoricLogsGroupByArgs['orderBy'] }
        : { orderBy?: HistoricLogsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HistoricLogsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHistoricLogsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for historicLogs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__historicLogsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    activity<T extends ActivityArgs= {}>(args?: Subset<T, ActivityArgs>): Prisma__ActivityClient<ActivityGetPayload<T> | Null>;

    guild<T extends GuildArgs= {}>(args?: Subset<T, GuildArgs>): Prisma__GuildClient<GuildGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * historicLogs base type for findUnique actions
   */
  export type historicLogsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the historicLogs
     * 
    **/
    select?: historicLogsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: historicLogsInclude | null
    /**
     * Filter, which historicLogs to fetch.
     * 
    **/
    where: historicLogsWhereUniqueInput
  }

  /**
   * historicLogs: findUnique
   */
  export interface historicLogsFindUniqueArgs extends historicLogsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * historicLogs findUniqueOrThrow
   */
  export type historicLogsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the historicLogs
     * 
    **/
    select?: historicLogsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: historicLogsInclude | null
    /**
     * Filter, which historicLogs to fetch.
     * 
    **/
    where: historicLogsWhereUniqueInput
  }


  /**
   * historicLogs base type for findFirst actions
   */
  export type historicLogsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the historicLogs
     * 
    **/
    select?: historicLogsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: historicLogsInclude | null
    /**
     * Filter, which historicLogs to fetch.
     * 
    **/
    where?: historicLogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historicLogs to fetch.
     * 
    **/
    orderBy?: Enumerable<historicLogsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for historicLogs.
     * 
    **/
    cursor?: historicLogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historicLogs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historicLogs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of historicLogs.
     * 
    **/
    distinct?: Enumerable<HistoricLogsScalarFieldEnum>
  }

  /**
   * historicLogs: findFirst
   */
  export interface historicLogsFindFirstArgs extends historicLogsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * historicLogs findFirstOrThrow
   */
  export type historicLogsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the historicLogs
     * 
    **/
    select?: historicLogsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: historicLogsInclude | null
    /**
     * Filter, which historicLogs to fetch.
     * 
    **/
    where?: historicLogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historicLogs to fetch.
     * 
    **/
    orderBy?: Enumerable<historicLogsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for historicLogs.
     * 
    **/
    cursor?: historicLogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historicLogs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historicLogs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of historicLogs.
     * 
    **/
    distinct?: Enumerable<HistoricLogsScalarFieldEnum>
  }


  /**
   * historicLogs findMany
   */
  export type historicLogsFindManyArgs = {
    /**
     * Select specific fields to fetch from the historicLogs
     * 
    **/
    select?: historicLogsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: historicLogsInclude | null
    /**
     * Filter, which historicLogs to fetch.
     * 
    **/
    where?: historicLogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historicLogs to fetch.
     * 
    **/
    orderBy?: Enumerable<historicLogsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing historicLogs.
     * 
    **/
    cursor?: historicLogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historicLogs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historicLogs.
     * 
    **/
    skip?: number
    distinct?: Enumerable<HistoricLogsScalarFieldEnum>
  }


  /**
   * historicLogs create
   */
  export type historicLogsCreateArgs = {
    /**
     * Select specific fields to fetch from the historicLogs
     * 
    **/
    select?: historicLogsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: historicLogsInclude | null
    /**
     * The data needed to create a historicLogs.
     * 
    **/
    data: XOR<historicLogsCreateInput, historicLogsUncheckedCreateInput>
  }


  /**
   * historicLogs createMany
   */
  export type historicLogsCreateManyArgs = {
    /**
     * The data used to create many historicLogs.
     * 
    **/
    data: Enumerable<historicLogsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * historicLogs update
   */
  export type historicLogsUpdateArgs = {
    /**
     * Select specific fields to fetch from the historicLogs
     * 
    **/
    select?: historicLogsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: historicLogsInclude | null
    /**
     * The data needed to update a historicLogs.
     * 
    **/
    data: XOR<historicLogsUpdateInput, historicLogsUncheckedUpdateInput>
    /**
     * Choose, which historicLogs to update.
     * 
    **/
    where: historicLogsWhereUniqueInput
  }


  /**
   * historicLogs updateMany
   */
  export type historicLogsUpdateManyArgs = {
    /**
     * The data used to update historicLogs.
     * 
    **/
    data: XOR<historicLogsUpdateManyMutationInput, historicLogsUncheckedUpdateManyInput>
    /**
     * Filter which historicLogs to update
     * 
    **/
    where?: historicLogsWhereInput
  }


  /**
   * historicLogs upsert
   */
  export type historicLogsUpsertArgs = {
    /**
     * Select specific fields to fetch from the historicLogs
     * 
    **/
    select?: historicLogsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: historicLogsInclude | null
    /**
     * The filter to search for the historicLogs to update in case it exists.
     * 
    **/
    where: historicLogsWhereUniqueInput
    /**
     * In case the historicLogs found by the `where` argument doesn't exist, create a new historicLogs with this data.
     * 
    **/
    create: XOR<historicLogsCreateInput, historicLogsUncheckedCreateInput>
    /**
     * In case the historicLogs was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<historicLogsUpdateInput, historicLogsUncheckedUpdateInput>
  }


  /**
   * historicLogs delete
   */
  export type historicLogsDeleteArgs = {
    /**
     * Select specific fields to fetch from the historicLogs
     * 
    **/
    select?: historicLogsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: historicLogsInclude | null
    /**
     * Filter which historicLogs to delete.
     * 
    **/
    where: historicLogsWhereUniqueInput
  }


  /**
   * historicLogs deleteMany
   */
  export type historicLogsDeleteManyArgs = {
    /**
     * Filter which historicLogs to delete
     * 
    **/
    where?: historicLogsWhereInput
  }


  /**
   * historicLogs without action
   */
  export type historicLogsArgs = {
    /**
     * Select specific fields to fetch from the historicLogs
     * 
    **/
    select?: historicLogsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: historicLogsInclude | null
  }



  /**
   * Model historicQuickLogs
   */


  export type AggregateHistoricQuickLogs = {
    _count: HistoricQuickLogsCountAggregateOutputType | null
    _avg: HistoricQuickLogsAvgAggregateOutputType | null
    _sum: HistoricQuickLogsSumAggregateOutputType | null
    _min: HistoricQuickLogsMinAggregateOutputType | null
    _max: HistoricQuickLogsMaxAggregateOutputType | null
  }

  export type HistoricQuickLogsAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    activityId: number | null
  }

  export type HistoricQuickLogsSumAggregateOutputType = {
    id: number | null
    userId: number | null
    activityId: number | null
  }

  export type HistoricQuickLogsMinAggregateOutputType = {
    id: number | null
    date: Date | null
    type: ActivityType | null
    start: Date | null
    end: Date | null
    userId: number | null
    activityId: number | null
    guildId: string | null
  }

  export type HistoricQuickLogsMaxAggregateOutputType = {
    id: number | null
    date: Date | null
    type: ActivityType | null
    start: Date | null
    end: Date | null
    userId: number | null
    activityId: number | null
    guildId: string | null
  }

  export type HistoricQuickLogsCountAggregateOutputType = {
    id: number
    date: number
    type: number
    start: number
    end: number
    userId: number
    activityId: number
    guildId: number
    _all: number
  }


  export type HistoricQuickLogsAvgAggregateInputType = {
    id?: true
    userId?: true
    activityId?: true
  }

  export type HistoricQuickLogsSumAggregateInputType = {
    id?: true
    userId?: true
    activityId?: true
  }

  export type HistoricQuickLogsMinAggregateInputType = {
    id?: true
    date?: true
    type?: true
    start?: true
    end?: true
    userId?: true
    activityId?: true
    guildId?: true
  }

  export type HistoricQuickLogsMaxAggregateInputType = {
    id?: true
    date?: true
    type?: true
    start?: true
    end?: true
    userId?: true
    activityId?: true
    guildId?: true
  }

  export type HistoricQuickLogsCountAggregateInputType = {
    id?: true
    date?: true
    type?: true
    start?: true
    end?: true
    userId?: true
    activityId?: true
    guildId?: true
    _all?: true
  }

  export type HistoricQuickLogsAggregateArgs = {
    /**
     * Filter which historicQuickLogs to aggregate.
     * 
    **/
    where?: historicQuickLogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historicQuickLogs to fetch.
     * 
    **/
    orderBy?: Enumerable<historicQuickLogsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: historicQuickLogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historicQuickLogs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historicQuickLogs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned historicQuickLogs
    **/
    _count?: true | HistoricQuickLogsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HistoricQuickLogsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HistoricQuickLogsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HistoricQuickLogsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HistoricQuickLogsMaxAggregateInputType
  }

  export type GetHistoricQuickLogsAggregateType<T extends HistoricQuickLogsAggregateArgs> = {
        [P in keyof T & keyof AggregateHistoricQuickLogs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHistoricQuickLogs[P]>
      : GetScalarType<T[P], AggregateHistoricQuickLogs[P]>
  }




  export type HistoricQuickLogsGroupByArgs = {
    where?: historicQuickLogsWhereInput
    orderBy?: Enumerable<historicQuickLogsOrderByWithAggregationInput>
    by: Array<HistoricQuickLogsScalarFieldEnum>
    having?: historicQuickLogsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HistoricQuickLogsCountAggregateInputType | true
    _avg?: HistoricQuickLogsAvgAggregateInputType
    _sum?: HistoricQuickLogsSumAggregateInputType
    _min?: HistoricQuickLogsMinAggregateInputType
    _max?: HistoricQuickLogsMaxAggregateInputType
  }


  export type HistoricQuickLogsGroupByOutputType = {
    id: number
    date: Date
    type: ActivityType
    start: Date
    end: Date
    userId: number
    activityId: number
    guildId: string
    _count: HistoricQuickLogsCountAggregateOutputType | null
    _avg: HistoricQuickLogsAvgAggregateOutputType | null
    _sum: HistoricQuickLogsSumAggregateOutputType | null
    _min: HistoricQuickLogsMinAggregateOutputType | null
    _max: HistoricQuickLogsMaxAggregateOutputType | null
  }

  type GetHistoricQuickLogsGroupByPayload<T extends HistoricQuickLogsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<HistoricQuickLogsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HistoricQuickLogsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HistoricQuickLogsGroupByOutputType[P]>
            : GetScalarType<T[P], HistoricQuickLogsGroupByOutputType[P]>
        }
      >
    >


  export type historicQuickLogsSelect = {
    id?: boolean
    user?: boolean | UserArgs
    activity?: boolean | ActivityArgs
    guild?: boolean | GuildArgs
    date?: boolean
    type?: boolean
    start?: boolean
    end?: boolean
    userId?: boolean
    activityId?: boolean
    guildId?: boolean
  }


  export type historicQuickLogsInclude = {
    user?: boolean | UserArgs
    activity?: boolean | ActivityArgs
    guild?: boolean | GuildArgs
  } 

  export type historicQuickLogsGetPayload<S extends boolean | null | undefined | historicQuickLogsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? historicQuickLogs :
    S extends undefined ? never :
    S extends { include: any } & (historicQuickLogsArgs | historicQuickLogsFindManyArgs)
    ? historicQuickLogs  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends 'activity' ? ActivityGetPayload<S['include'][P]> :
        P extends 'guild' ? GuildGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (historicQuickLogsArgs | historicQuickLogsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends 'activity' ? ActivityGetPayload<S['select'][P]> :
        P extends 'guild' ? GuildGetPayload<S['select'][P]> :  P extends keyof historicQuickLogs ? historicQuickLogs[P] : never
  } 
      : historicQuickLogs


  type historicQuickLogsCountArgs = Merge<
    Omit<historicQuickLogsFindManyArgs, 'select' | 'include'> & {
      select?: HistoricQuickLogsCountAggregateInputType | true
    }
  >

  export interface historicQuickLogsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one HistoricQuickLogs that matches the filter.
     * @param {historicQuickLogsFindUniqueArgs} args - Arguments to find a HistoricQuickLogs
     * @example
     * // Get one HistoricQuickLogs
     * const historicQuickLogs = await prisma.historicQuickLogs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends historicQuickLogsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, historicQuickLogsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'historicQuickLogs'> extends True ? Prisma__historicQuickLogsClient<historicQuickLogsGetPayload<T>> : Prisma__historicQuickLogsClient<historicQuickLogsGetPayload<T> | null, null>

    /**
     * Find one HistoricQuickLogs that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {historicQuickLogsFindUniqueOrThrowArgs} args - Arguments to find a HistoricQuickLogs
     * @example
     * // Get one HistoricQuickLogs
     * const historicQuickLogs = await prisma.historicQuickLogs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends historicQuickLogsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, historicQuickLogsFindUniqueOrThrowArgs>
    ): Prisma__historicQuickLogsClient<historicQuickLogsGetPayload<T>>

    /**
     * Find the first HistoricQuickLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historicQuickLogsFindFirstArgs} args - Arguments to find a HistoricQuickLogs
     * @example
     * // Get one HistoricQuickLogs
     * const historicQuickLogs = await prisma.historicQuickLogs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends historicQuickLogsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, historicQuickLogsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'historicQuickLogs'> extends True ? Prisma__historicQuickLogsClient<historicQuickLogsGetPayload<T>> : Prisma__historicQuickLogsClient<historicQuickLogsGetPayload<T> | null, null>

    /**
     * Find the first HistoricQuickLogs that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historicQuickLogsFindFirstOrThrowArgs} args - Arguments to find a HistoricQuickLogs
     * @example
     * // Get one HistoricQuickLogs
     * const historicQuickLogs = await prisma.historicQuickLogs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends historicQuickLogsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, historicQuickLogsFindFirstOrThrowArgs>
    ): Prisma__historicQuickLogsClient<historicQuickLogsGetPayload<T>>

    /**
     * Find zero or more HistoricQuickLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historicQuickLogsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HistoricQuickLogs
     * const historicQuickLogs = await prisma.historicQuickLogs.findMany()
     * 
     * // Get first 10 HistoricQuickLogs
     * const historicQuickLogs = await prisma.historicQuickLogs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const historicQuickLogsWithIdOnly = await prisma.historicQuickLogs.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends historicQuickLogsFindManyArgs>(
      args?: SelectSubset<T, historicQuickLogsFindManyArgs>
    ): PrismaPromise<Array<historicQuickLogsGetPayload<T>>>

    /**
     * Create a HistoricQuickLogs.
     * @param {historicQuickLogsCreateArgs} args - Arguments to create a HistoricQuickLogs.
     * @example
     * // Create one HistoricQuickLogs
     * const HistoricQuickLogs = await prisma.historicQuickLogs.create({
     *   data: {
     *     // ... data to create a HistoricQuickLogs
     *   }
     * })
     * 
    **/
    create<T extends historicQuickLogsCreateArgs>(
      args: SelectSubset<T, historicQuickLogsCreateArgs>
    ): Prisma__historicQuickLogsClient<historicQuickLogsGetPayload<T>>

    /**
     * Create many HistoricQuickLogs.
     *     @param {historicQuickLogsCreateManyArgs} args - Arguments to create many HistoricQuickLogs.
     *     @example
     *     // Create many HistoricQuickLogs
     *     const historicQuickLogs = await prisma.historicQuickLogs.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends historicQuickLogsCreateManyArgs>(
      args?: SelectSubset<T, historicQuickLogsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a HistoricQuickLogs.
     * @param {historicQuickLogsDeleteArgs} args - Arguments to delete one HistoricQuickLogs.
     * @example
     * // Delete one HistoricQuickLogs
     * const HistoricQuickLogs = await prisma.historicQuickLogs.delete({
     *   where: {
     *     // ... filter to delete one HistoricQuickLogs
     *   }
     * })
     * 
    **/
    delete<T extends historicQuickLogsDeleteArgs>(
      args: SelectSubset<T, historicQuickLogsDeleteArgs>
    ): Prisma__historicQuickLogsClient<historicQuickLogsGetPayload<T>>

    /**
     * Update one HistoricQuickLogs.
     * @param {historicQuickLogsUpdateArgs} args - Arguments to update one HistoricQuickLogs.
     * @example
     * // Update one HistoricQuickLogs
     * const historicQuickLogs = await prisma.historicQuickLogs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends historicQuickLogsUpdateArgs>(
      args: SelectSubset<T, historicQuickLogsUpdateArgs>
    ): Prisma__historicQuickLogsClient<historicQuickLogsGetPayload<T>>

    /**
     * Delete zero or more HistoricQuickLogs.
     * @param {historicQuickLogsDeleteManyArgs} args - Arguments to filter HistoricQuickLogs to delete.
     * @example
     * // Delete a few HistoricQuickLogs
     * const { count } = await prisma.historicQuickLogs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends historicQuickLogsDeleteManyArgs>(
      args?: SelectSubset<T, historicQuickLogsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more HistoricQuickLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historicQuickLogsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HistoricQuickLogs
     * const historicQuickLogs = await prisma.historicQuickLogs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends historicQuickLogsUpdateManyArgs>(
      args: SelectSubset<T, historicQuickLogsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one HistoricQuickLogs.
     * @param {historicQuickLogsUpsertArgs} args - Arguments to update or create a HistoricQuickLogs.
     * @example
     * // Update or create a HistoricQuickLogs
     * const historicQuickLogs = await prisma.historicQuickLogs.upsert({
     *   create: {
     *     // ... data to create a HistoricQuickLogs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HistoricQuickLogs we want to update
     *   }
     * })
    **/
    upsert<T extends historicQuickLogsUpsertArgs>(
      args: SelectSubset<T, historicQuickLogsUpsertArgs>
    ): Prisma__historicQuickLogsClient<historicQuickLogsGetPayload<T>>

    /**
     * Count the number of HistoricQuickLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historicQuickLogsCountArgs} args - Arguments to filter HistoricQuickLogs to count.
     * @example
     * // Count the number of HistoricQuickLogs
     * const count = await prisma.historicQuickLogs.count({
     *   where: {
     *     // ... the filter for the HistoricQuickLogs we want to count
     *   }
     * })
    **/
    count<T extends historicQuickLogsCountArgs>(
      args?: Subset<T, historicQuickLogsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HistoricQuickLogsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HistoricQuickLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoricQuickLogsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HistoricQuickLogsAggregateArgs>(args: Subset<T, HistoricQuickLogsAggregateArgs>): PrismaPromise<GetHistoricQuickLogsAggregateType<T>>

    /**
     * Group by HistoricQuickLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoricQuickLogsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HistoricQuickLogsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HistoricQuickLogsGroupByArgs['orderBy'] }
        : { orderBy?: HistoricQuickLogsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HistoricQuickLogsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHistoricQuickLogsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for historicQuickLogs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__historicQuickLogsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    activity<T extends ActivityArgs= {}>(args?: Subset<T, ActivityArgs>): Prisma__ActivityClient<ActivityGetPayload<T> | Null>;

    guild<T extends GuildArgs= {}>(args?: Subset<T, GuildArgs>): Prisma__GuildClient<GuildGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * historicQuickLogs base type for findUnique actions
   */
  export type historicQuickLogsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the historicQuickLogs
     * 
    **/
    select?: historicQuickLogsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: historicQuickLogsInclude | null
    /**
     * Filter, which historicQuickLogs to fetch.
     * 
    **/
    where: historicQuickLogsWhereUniqueInput
  }

  /**
   * historicQuickLogs: findUnique
   */
  export interface historicQuickLogsFindUniqueArgs extends historicQuickLogsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * historicQuickLogs findUniqueOrThrow
   */
  export type historicQuickLogsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the historicQuickLogs
     * 
    **/
    select?: historicQuickLogsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: historicQuickLogsInclude | null
    /**
     * Filter, which historicQuickLogs to fetch.
     * 
    **/
    where: historicQuickLogsWhereUniqueInput
  }


  /**
   * historicQuickLogs base type for findFirst actions
   */
  export type historicQuickLogsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the historicQuickLogs
     * 
    **/
    select?: historicQuickLogsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: historicQuickLogsInclude | null
    /**
     * Filter, which historicQuickLogs to fetch.
     * 
    **/
    where?: historicQuickLogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historicQuickLogs to fetch.
     * 
    **/
    orderBy?: Enumerable<historicQuickLogsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for historicQuickLogs.
     * 
    **/
    cursor?: historicQuickLogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historicQuickLogs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historicQuickLogs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of historicQuickLogs.
     * 
    **/
    distinct?: Enumerable<HistoricQuickLogsScalarFieldEnum>
  }

  /**
   * historicQuickLogs: findFirst
   */
  export interface historicQuickLogsFindFirstArgs extends historicQuickLogsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * historicQuickLogs findFirstOrThrow
   */
  export type historicQuickLogsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the historicQuickLogs
     * 
    **/
    select?: historicQuickLogsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: historicQuickLogsInclude | null
    /**
     * Filter, which historicQuickLogs to fetch.
     * 
    **/
    where?: historicQuickLogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historicQuickLogs to fetch.
     * 
    **/
    orderBy?: Enumerable<historicQuickLogsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for historicQuickLogs.
     * 
    **/
    cursor?: historicQuickLogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historicQuickLogs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historicQuickLogs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of historicQuickLogs.
     * 
    **/
    distinct?: Enumerable<HistoricQuickLogsScalarFieldEnum>
  }


  /**
   * historicQuickLogs findMany
   */
  export type historicQuickLogsFindManyArgs = {
    /**
     * Select specific fields to fetch from the historicQuickLogs
     * 
    **/
    select?: historicQuickLogsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: historicQuickLogsInclude | null
    /**
     * Filter, which historicQuickLogs to fetch.
     * 
    **/
    where?: historicQuickLogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historicQuickLogs to fetch.
     * 
    **/
    orderBy?: Enumerable<historicQuickLogsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing historicQuickLogs.
     * 
    **/
    cursor?: historicQuickLogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historicQuickLogs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historicQuickLogs.
     * 
    **/
    skip?: number
    distinct?: Enumerable<HistoricQuickLogsScalarFieldEnum>
  }


  /**
   * historicQuickLogs create
   */
  export type historicQuickLogsCreateArgs = {
    /**
     * Select specific fields to fetch from the historicQuickLogs
     * 
    **/
    select?: historicQuickLogsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: historicQuickLogsInclude | null
    /**
     * The data needed to create a historicQuickLogs.
     * 
    **/
    data: XOR<historicQuickLogsCreateInput, historicQuickLogsUncheckedCreateInput>
  }


  /**
   * historicQuickLogs createMany
   */
  export type historicQuickLogsCreateManyArgs = {
    /**
     * The data used to create many historicQuickLogs.
     * 
    **/
    data: Enumerable<historicQuickLogsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * historicQuickLogs update
   */
  export type historicQuickLogsUpdateArgs = {
    /**
     * Select specific fields to fetch from the historicQuickLogs
     * 
    **/
    select?: historicQuickLogsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: historicQuickLogsInclude | null
    /**
     * The data needed to update a historicQuickLogs.
     * 
    **/
    data: XOR<historicQuickLogsUpdateInput, historicQuickLogsUncheckedUpdateInput>
    /**
     * Choose, which historicQuickLogs to update.
     * 
    **/
    where: historicQuickLogsWhereUniqueInput
  }


  /**
   * historicQuickLogs updateMany
   */
  export type historicQuickLogsUpdateManyArgs = {
    /**
     * The data used to update historicQuickLogs.
     * 
    **/
    data: XOR<historicQuickLogsUpdateManyMutationInput, historicQuickLogsUncheckedUpdateManyInput>
    /**
     * Filter which historicQuickLogs to update
     * 
    **/
    where?: historicQuickLogsWhereInput
  }


  /**
   * historicQuickLogs upsert
   */
  export type historicQuickLogsUpsertArgs = {
    /**
     * Select specific fields to fetch from the historicQuickLogs
     * 
    **/
    select?: historicQuickLogsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: historicQuickLogsInclude | null
    /**
     * The filter to search for the historicQuickLogs to update in case it exists.
     * 
    **/
    where: historicQuickLogsWhereUniqueInput
    /**
     * In case the historicQuickLogs found by the `where` argument doesn't exist, create a new historicQuickLogs with this data.
     * 
    **/
    create: XOR<historicQuickLogsCreateInput, historicQuickLogsUncheckedCreateInput>
    /**
     * In case the historicQuickLogs was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<historicQuickLogsUpdateInput, historicQuickLogsUncheckedUpdateInput>
  }


  /**
   * historicQuickLogs delete
   */
  export type historicQuickLogsDeleteArgs = {
    /**
     * Select specific fields to fetch from the historicQuickLogs
     * 
    **/
    select?: historicQuickLogsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: historicQuickLogsInclude | null
    /**
     * Filter which historicQuickLogs to delete.
     * 
    **/
    where: historicQuickLogsWhereUniqueInput
  }


  /**
   * historicQuickLogs deleteMany
   */
  export type historicQuickLogsDeleteManyArgs = {
    /**
     * Filter which historicQuickLogs to delete
     * 
    **/
    where?: historicQuickLogsWhereInput
  }


  /**
   * historicQuickLogs without action
   */
  export type historicQuickLogsArgs = {
    /**
     * Select specific fields to fetch from the historicQuickLogs
     * 
    **/
    select?: historicQuickLogsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: historicQuickLogsInclude | null
  }



  /**
   * Model logsToday
   */


  export type AggregateLogsToday = {
    _count: LogsTodayCountAggregateOutputType | null
    _avg: LogsTodayAvgAggregateOutputType | null
    _sum: LogsTodaySumAggregateOutputType | null
    _min: LogsTodayMinAggregateOutputType | null
    _max: LogsTodayMaxAggregateOutputType | null
  }

  export type LogsTodayAvgAggregateOutputType = {
    id: number | null
    minutes: number | null
    userId: number | null
    activityId: number | null
  }

  export type LogsTodaySumAggregateOutputType = {
    id: number | null
    minutes: number | null
    userId: number | null
    activityId: number | null
  }

  export type LogsTodayMinAggregateOutputType = {
    id: number | null
    date: Date | null
    Type: string | null
    Timeframe: Timeframe | null
    minutes: number | null
    userId: number | null
    activityId: number | null
  }

  export type LogsTodayMaxAggregateOutputType = {
    id: number | null
    date: Date | null
    Type: string | null
    Timeframe: Timeframe | null
    minutes: number | null
    userId: number | null
    activityId: number | null
  }

  export type LogsTodayCountAggregateOutputType = {
    id: number
    date: number
    Type: number
    Timeframe: number
    minutes: number
    userId: number
    activityId: number
    _all: number
  }


  export type LogsTodayAvgAggregateInputType = {
    id?: true
    minutes?: true
    userId?: true
    activityId?: true
  }

  export type LogsTodaySumAggregateInputType = {
    id?: true
    minutes?: true
    userId?: true
    activityId?: true
  }

  export type LogsTodayMinAggregateInputType = {
    id?: true
    date?: true
    Type?: true
    Timeframe?: true
    minutes?: true
    userId?: true
    activityId?: true
  }

  export type LogsTodayMaxAggregateInputType = {
    id?: true
    date?: true
    Type?: true
    Timeframe?: true
    minutes?: true
    userId?: true
    activityId?: true
  }

  export type LogsTodayCountAggregateInputType = {
    id?: true
    date?: true
    Type?: true
    Timeframe?: true
    minutes?: true
    userId?: true
    activityId?: true
    _all?: true
  }

  export type LogsTodayAggregateArgs = {
    /**
     * Filter which logsToday to aggregate.
     * 
    **/
    where?: logsTodayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logsTodays to fetch.
     * 
    **/
    orderBy?: Enumerable<logsTodayOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: logsTodayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logsTodays from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logsTodays.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned logsTodays
    **/
    _count?: true | LogsTodayCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LogsTodayAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LogsTodaySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogsTodayMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogsTodayMaxAggregateInputType
  }

  export type GetLogsTodayAggregateType<T extends LogsTodayAggregateArgs> = {
        [P in keyof T & keyof AggregateLogsToday]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogsToday[P]>
      : GetScalarType<T[P], AggregateLogsToday[P]>
  }




  export type LogsTodayGroupByArgs = {
    where?: logsTodayWhereInput
    orderBy?: Enumerable<logsTodayOrderByWithAggregationInput>
    by: Array<LogsTodayScalarFieldEnum>
    having?: logsTodayScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogsTodayCountAggregateInputType | true
    _avg?: LogsTodayAvgAggregateInputType
    _sum?: LogsTodaySumAggregateInputType
    _min?: LogsTodayMinAggregateInputType
    _max?: LogsTodayMaxAggregateInputType
  }


  export type LogsTodayGroupByOutputType = {
    id: number
    date: Date
    Type: string
    Timeframe: Timeframe
    minutes: number
    userId: number
    activityId: number
    _count: LogsTodayCountAggregateOutputType | null
    _avg: LogsTodayAvgAggregateOutputType | null
    _sum: LogsTodaySumAggregateOutputType | null
    _min: LogsTodayMinAggregateOutputType | null
    _max: LogsTodayMaxAggregateOutputType | null
  }

  type GetLogsTodayGroupByPayload<T extends LogsTodayGroupByArgs> = PrismaPromise<
    Array<
      PickArray<LogsTodayGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogsTodayGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogsTodayGroupByOutputType[P]>
            : GetScalarType<T[P], LogsTodayGroupByOutputType[P]>
        }
      >
    >


  export type logsTodaySelect = {
    id?: boolean
    user?: boolean | UserArgs
    activity?: boolean | ActivityArgs
    date?: boolean
    Type?: boolean
    Timeframe?: boolean
    minutes?: boolean
    userId?: boolean
    activityId?: boolean
  }


  export type logsTodayInclude = {
    user?: boolean | UserArgs
    activity?: boolean | ActivityArgs
  } 

  export type logsTodayGetPayload<S extends boolean | null | undefined | logsTodayArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? logsToday :
    S extends undefined ? never :
    S extends { include: any } & (logsTodayArgs | logsTodayFindManyArgs)
    ? logsToday  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends 'activity' ? ActivityGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (logsTodayArgs | logsTodayFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends 'activity' ? ActivityGetPayload<S['select'][P]> :  P extends keyof logsToday ? logsToday[P] : never
  } 
      : logsToday


  type logsTodayCountArgs = Merge<
    Omit<logsTodayFindManyArgs, 'select' | 'include'> & {
      select?: LogsTodayCountAggregateInputType | true
    }
  >

  export interface logsTodayDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one LogsToday that matches the filter.
     * @param {logsTodayFindUniqueArgs} args - Arguments to find a LogsToday
     * @example
     * // Get one LogsToday
     * const logsToday = await prisma.logsToday.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends logsTodayFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, logsTodayFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'logsToday'> extends True ? Prisma__logsTodayClient<logsTodayGetPayload<T>> : Prisma__logsTodayClient<logsTodayGetPayload<T> | null, null>

    /**
     * Find one LogsToday that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {logsTodayFindUniqueOrThrowArgs} args - Arguments to find a LogsToday
     * @example
     * // Get one LogsToday
     * const logsToday = await prisma.logsToday.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends logsTodayFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, logsTodayFindUniqueOrThrowArgs>
    ): Prisma__logsTodayClient<logsTodayGetPayload<T>>

    /**
     * Find the first LogsToday that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logsTodayFindFirstArgs} args - Arguments to find a LogsToday
     * @example
     * // Get one LogsToday
     * const logsToday = await prisma.logsToday.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends logsTodayFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, logsTodayFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'logsToday'> extends True ? Prisma__logsTodayClient<logsTodayGetPayload<T>> : Prisma__logsTodayClient<logsTodayGetPayload<T> | null, null>

    /**
     * Find the first LogsToday that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logsTodayFindFirstOrThrowArgs} args - Arguments to find a LogsToday
     * @example
     * // Get one LogsToday
     * const logsToday = await prisma.logsToday.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends logsTodayFindFirstOrThrowArgs>(
      args?: SelectSubset<T, logsTodayFindFirstOrThrowArgs>
    ): Prisma__logsTodayClient<logsTodayGetPayload<T>>

    /**
     * Find zero or more LogsTodays that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logsTodayFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LogsTodays
     * const logsTodays = await prisma.logsToday.findMany()
     * 
     * // Get first 10 LogsTodays
     * const logsTodays = await prisma.logsToday.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logsTodayWithIdOnly = await prisma.logsToday.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends logsTodayFindManyArgs>(
      args?: SelectSubset<T, logsTodayFindManyArgs>
    ): PrismaPromise<Array<logsTodayGetPayload<T>>>

    /**
     * Create a LogsToday.
     * @param {logsTodayCreateArgs} args - Arguments to create a LogsToday.
     * @example
     * // Create one LogsToday
     * const LogsToday = await prisma.logsToday.create({
     *   data: {
     *     // ... data to create a LogsToday
     *   }
     * })
     * 
    **/
    create<T extends logsTodayCreateArgs>(
      args: SelectSubset<T, logsTodayCreateArgs>
    ): Prisma__logsTodayClient<logsTodayGetPayload<T>>

    /**
     * Create many LogsTodays.
     *     @param {logsTodayCreateManyArgs} args - Arguments to create many LogsTodays.
     *     @example
     *     // Create many LogsTodays
     *     const logsToday = await prisma.logsToday.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends logsTodayCreateManyArgs>(
      args?: SelectSubset<T, logsTodayCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a LogsToday.
     * @param {logsTodayDeleteArgs} args - Arguments to delete one LogsToday.
     * @example
     * // Delete one LogsToday
     * const LogsToday = await prisma.logsToday.delete({
     *   where: {
     *     // ... filter to delete one LogsToday
     *   }
     * })
     * 
    **/
    delete<T extends logsTodayDeleteArgs>(
      args: SelectSubset<T, logsTodayDeleteArgs>
    ): Prisma__logsTodayClient<logsTodayGetPayload<T>>

    /**
     * Update one LogsToday.
     * @param {logsTodayUpdateArgs} args - Arguments to update one LogsToday.
     * @example
     * // Update one LogsToday
     * const logsToday = await prisma.logsToday.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends logsTodayUpdateArgs>(
      args: SelectSubset<T, logsTodayUpdateArgs>
    ): Prisma__logsTodayClient<logsTodayGetPayload<T>>

    /**
     * Delete zero or more LogsTodays.
     * @param {logsTodayDeleteManyArgs} args - Arguments to filter LogsTodays to delete.
     * @example
     * // Delete a few LogsTodays
     * const { count } = await prisma.logsToday.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends logsTodayDeleteManyArgs>(
      args?: SelectSubset<T, logsTodayDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more LogsTodays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logsTodayUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LogsTodays
     * const logsToday = await prisma.logsToday.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends logsTodayUpdateManyArgs>(
      args: SelectSubset<T, logsTodayUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one LogsToday.
     * @param {logsTodayUpsertArgs} args - Arguments to update or create a LogsToday.
     * @example
     * // Update or create a LogsToday
     * const logsToday = await prisma.logsToday.upsert({
     *   create: {
     *     // ... data to create a LogsToday
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LogsToday we want to update
     *   }
     * })
    **/
    upsert<T extends logsTodayUpsertArgs>(
      args: SelectSubset<T, logsTodayUpsertArgs>
    ): Prisma__logsTodayClient<logsTodayGetPayload<T>>

    /**
     * Count the number of LogsTodays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logsTodayCountArgs} args - Arguments to filter LogsTodays to count.
     * @example
     * // Count the number of LogsTodays
     * const count = await prisma.logsToday.count({
     *   where: {
     *     // ... the filter for the LogsTodays we want to count
     *   }
     * })
    **/
    count<T extends logsTodayCountArgs>(
      args?: Subset<T, logsTodayCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogsTodayCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LogsToday.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsTodayAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogsTodayAggregateArgs>(args: Subset<T, LogsTodayAggregateArgs>): PrismaPromise<GetLogsTodayAggregateType<T>>

    /**
     * Group by LogsToday.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsTodayGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogsTodayGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogsTodayGroupByArgs['orderBy'] }
        : { orderBy?: LogsTodayGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogsTodayGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogsTodayGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for logsToday.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__logsTodayClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    activity<T extends ActivityArgs= {}>(args?: Subset<T, ActivityArgs>): Prisma__ActivityClient<ActivityGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * logsToday base type for findUnique actions
   */
  export type logsTodayFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the logsToday
     * 
    **/
    select?: logsTodaySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: logsTodayInclude | null
    /**
     * Filter, which logsToday to fetch.
     * 
    **/
    where: logsTodayWhereUniqueInput
  }

  /**
   * logsToday: findUnique
   */
  export interface logsTodayFindUniqueArgs extends logsTodayFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * logsToday findUniqueOrThrow
   */
  export type logsTodayFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the logsToday
     * 
    **/
    select?: logsTodaySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: logsTodayInclude | null
    /**
     * Filter, which logsToday to fetch.
     * 
    **/
    where: logsTodayWhereUniqueInput
  }


  /**
   * logsToday base type for findFirst actions
   */
  export type logsTodayFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the logsToday
     * 
    **/
    select?: logsTodaySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: logsTodayInclude | null
    /**
     * Filter, which logsToday to fetch.
     * 
    **/
    where?: logsTodayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logsTodays to fetch.
     * 
    **/
    orderBy?: Enumerable<logsTodayOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for logsTodays.
     * 
    **/
    cursor?: logsTodayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logsTodays from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logsTodays.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of logsTodays.
     * 
    **/
    distinct?: Enumerable<LogsTodayScalarFieldEnum>
  }

  /**
   * logsToday: findFirst
   */
  export interface logsTodayFindFirstArgs extends logsTodayFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * logsToday findFirstOrThrow
   */
  export type logsTodayFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the logsToday
     * 
    **/
    select?: logsTodaySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: logsTodayInclude | null
    /**
     * Filter, which logsToday to fetch.
     * 
    **/
    where?: logsTodayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logsTodays to fetch.
     * 
    **/
    orderBy?: Enumerable<logsTodayOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for logsTodays.
     * 
    **/
    cursor?: logsTodayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logsTodays from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logsTodays.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of logsTodays.
     * 
    **/
    distinct?: Enumerable<LogsTodayScalarFieldEnum>
  }


  /**
   * logsToday findMany
   */
  export type logsTodayFindManyArgs = {
    /**
     * Select specific fields to fetch from the logsToday
     * 
    **/
    select?: logsTodaySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: logsTodayInclude | null
    /**
     * Filter, which logsTodays to fetch.
     * 
    **/
    where?: logsTodayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logsTodays to fetch.
     * 
    **/
    orderBy?: Enumerable<logsTodayOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing logsTodays.
     * 
    **/
    cursor?: logsTodayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logsTodays from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logsTodays.
     * 
    **/
    skip?: number
    distinct?: Enumerable<LogsTodayScalarFieldEnum>
  }


  /**
   * logsToday create
   */
  export type logsTodayCreateArgs = {
    /**
     * Select specific fields to fetch from the logsToday
     * 
    **/
    select?: logsTodaySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: logsTodayInclude | null
    /**
     * The data needed to create a logsToday.
     * 
    **/
    data: XOR<logsTodayCreateInput, logsTodayUncheckedCreateInput>
  }


  /**
   * logsToday createMany
   */
  export type logsTodayCreateManyArgs = {
    /**
     * The data used to create many logsTodays.
     * 
    **/
    data: Enumerable<logsTodayCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * logsToday update
   */
  export type logsTodayUpdateArgs = {
    /**
     * Select specific fields to fetch from the logsToday
     * 
    **/
    select?: logsTodaySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: logsTodayInclude | null
    /**
     * The data needed to update a logsToday.
     * 
    **/
    data: XOR<logsTodayUpdateInput, logsTodayUncheckedUpdateInput>
    /**
     * Choose, which logsToday to update.
     * 
    **/
    where: logsTodayWhereUniqueInput
  }


  /**
   * logsToday updateMany
   */
  export type logsTodayUpdateManyArgs = {
    /**
     * The data used to update logsTodays.
     * 
    **/
    data: XOR<logsTodayUpdateManyMutationInput, logsTodayUncheckedUpdateManyInput>
    /**
     * Filter which logsTodays to update
     * 
    **/
    where?: logsTodayWhereInput
  }


  /**
   * logsToday upsert
   */
  export type logsTodayUpsertArgs = {
    /**
     * Select specific fields to fetch from the logsToday
     * 
    **/
    select?: logsTodaySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: logsTodayInclude | null
    /**
     * The filter to search for the logsToday to update in case it exists.
     * 
    **/
    where: logsTodayWhereUniqueInput
    /**
     * In case the logsToday found by the `where` argument doesn't exist, create a new logsToday with this data.
     * 
    **/
    create: XOR<logsTodayCreateInput, logsTodayUncheckedCreateInput>
    /**
     * In case the logsToday was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<logsTodayUpdateInput, logsTodayUncheckedUpdateInput>
  }


  /**
   * logsToday delete
   */
  export type logsTodayDeleteArgs = {
    /**
     * Select specific fields to fetch from the logsToday
     * 
    **/
    select?: logsTodaySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: logsTodayInclude | null
    /**
     * Filter which logsToday to delete.
     * 
    **/
    where: logsTodayWhereUniqueInput
  }


  /**
   * logsToday deleteMany
   */
  export type logsTodayDeleteManyArgs = {
    /**
     * Filter which logsTodays to delete
     * 
    **/
    where?: logsTodayWhereInput
  }


  /**
   * logsToday without action
   */
  export type logsTodayArgs = {
    /**
     * Select specific fields to fetch from the logsToday
     * 
    **/
    select?: logsTodaySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: logsTodayInclude | null
  }



  /**
   * Model UserActivityLogsToday
   */


  export type AggregateUserActivityLogsToday = {
    _count: UserActivityLogsTodayCountAggregateOutputType | null
    _avg: UserActivityLogsTodayAvgAggregateOutputType | null
    _sum: UserActivityLogsTodaySumAggregateOutputType | null
    _min: UserActivityLogsTodayMinAggregateOutputType | null
    _max: UserActivityLogsTodayMaxAggregateOutputType | null
  }

  export type UserActivityLogsTodayAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    activityId: number | null
  }

  export type UserActivityLogsTodaySumAggregateOutputType = {
    id: number | null
    userId: number | null
    activityId: number | null
  }

  export type UserActivityLogsTodayMinAggregateOutputType = {
    id: number | null
    type: ActivityType | null
    startedAt: Date | null
    endedAt: Date | null
    userId: number | null
    guildId: string | null
    activityId: number | null
  }

  export type UserActivityLogsTodayMaxAggregateOutputType = {
    id: number | null
    type: ActivityType | null
    startedAt: Date | null
    endedAt: Date | null
    userId: number | null
    guildId: string | null
    activityId: number | null
  }

  export type UserActivityLogsTodayCountAggregateOutputType = {
    id: number
    type: number
    startedAt: number
    endedAt: number
    userId: number
    guildId: number
    activityId: number
    _all: number
  }


  export type UserActivityLogsTodayAvgAggregateInputType = {
    id?: true
    userId?: true
    activityId?: true
  }

  export type UserActivityLogsTodaySumAggregateInputType = {
    id?: true
    userId?: true
    activityId?: true
  }

  export type UserActivityLogsTodayMinAggregateInputType = {
    id?: true
    type?: true
    startedAt?: true
    endedAt?: true
    userId?: true
    guildId?: true
    activityId?: true
  }

  export type UserActivityLogsTodayMaxAggregateInputType = {
    id?: true
    type?: true
    startedAt?: true
    endedAt?: true
    userId?: true
    guildId?: true
    activityId?: true
  }

  export type UserActivityLogsTodayCountAggregateInputType = {
    id?: true
    type?: true
    startedAt?: true
    endedAt?: true
    userId?: true
    guildId?: true
    activityId?: true
    _all?: true
  }

  export type UserActivityLogsTodayAggregateArgs = {
    /**
     * Filter which UserActivityLogsToday to aggregate.
     * 
    **/
    where?: UserActivityLogsTodayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserActivityLogsTodays to fetch.
     * 
    **/
    orderBy?: Enumerable<UserActivityLogsTodayOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserActivityLogsTodayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserActivityLogsTodays from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserActivityLogsTodays.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserActivityLogsTodays
    **/
    _count?: true | UserActivityLogsTodayCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserActivityLogsTodayAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserActivityLogsTodaySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserActivityLogsTodayMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserActivityLogsTodayMaxAggregateInputType
  }

  export type GetUserActivityLogsTodayAggregateType<T extends UserActivityLogsTodayAggregateArgs> = {
        [P in keyof T & keyof AggregateUserActivityLogsToday]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserActivityLogsToday[P]>
      : GetScalarType<T[P], AggregateUserActivityLogsToday[P]>
  }




  export type UserActivityLogsTodayGroupByArgs = {
    where?: UserActivityLogsTodayWhereInput
    orderBy?: Enumerable<UserActivityLogsTodayOrderByWithAggregationInput>
    by: Array<UserActivityLogsTodayScalarFieldEnum>
    having?: UserActivityLogsTodayScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserActivityLogsTodayCountAggregateInputType | true
    _avg?: UserActivityLogsTodayAvgAggregateInputType
    _sum?: UserActivityLogsTodaySumAggregateInputType
    _min?: UserActivityLogsTodayMinAggregateInputType
    _max?: UserActivityLogsTodayMaxAggregateInputType
  }


  export type UserActivityLogsTodayGroupByOutputType = {
    id: number
    type: ActivityType
    startedAt: Date
    endedAt: Date
    userId: number
    guildId: string
    activityId: number
    _count: UserActivityLogsTodayCountAggregateOutputType | null
    _avg: UserActivityLogsTodayAvgAggregateOutputType | null
    _sum: UserActivityLogsTodaySumAggregateOutputType | null
    _min: UserActivityLogsTodayMinAggregateOutputType | null
    _max: UserActivityLogsTodayMaxAggregateOutputType | null
  }

  type GetUserActivityLogsTodayGroupByPayload<T extends UserActivityLogsTodayGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserActivityLogsTodayGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserActivityLogsTodayGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserActivityLogsTodayGroupByOutputType[P]>
            : GetScalarType<T[P], UserActivityLogsTodayGroupByOutputType[P]>
        }
      >
    >


  export type UserActivityLogsTodaySelect = {
    id?: boolean
    user?: boolean | UserArgs
    type?: boolean
    guild?: boolean | GuildArgs
    activity?: boolean | ActivityArgs
    startedAt?: boolean
    endedAt?: boolean
    userId?: boolean
    guildId?: boolean
    activityId?: boolean
  }


  export type UserActivityLogsTodayInclude = {
    user?: boolean | UserArgs
    guild?: boolean | GuildArgs
    activity?: boolean | ActivityArgs
  } 

  export type UserActivityLogsTodayGetPayload<S extends boolean | null | undefined | UserActivityLogsTodayArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserActivityLogsToday :
    S extends undefined ? never :
    S extends { include: any } & (UserActivityLogsTodayArgs | UserActivityLogsTodayFindManyArgs)
    ? UserActivityLogsToday  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends 'guild' ? GuildGetPayload<S['include'][P]> :
        P extends 'activity' ? ActivityGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserActivityLogsTodayArgs | UserActivityLogsTodayFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends 'guild' ? GuildGetPayload<S['select'][P]> :
        P extends 'activity' ? ActivityGetPayload<S['select'][P]> :  P extends keyof UserActivityLogsToday ? UserActivityLogsToday[P] : never
  } 
      : UserActivityLogsToday


  type UserActivityLogsTodayCountArgs = Merge<
    Omit<UserActivityLogsTodayFindManyArgs, 'select' | 'include'> & {
      select?: UserActivityLogsTodayCountAggregateInputType | true
    }
  >

  export interface UserActivityLogsTodayDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one UserActivityLogsToday that matches the filter.
     * @param {UserActivityLogsTodayFindUniqueArgs} args - Arguments to find a UserActivityLogsToday
     * @example
     * // Get one UserActivityLogsToday
     * const userActivityLogsToday = await prisma.userActivityLogsToday.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserActivityLogsTodayFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserActivityLogsTodayFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserActivityLogsToday'> extends True ? Prisma__UserActivityLogsTodayClient<UserActivityLogsTodayGetPayload<T>> : Prisma__UserActivityLogsTodayClient<UserActivityLogsTodayGetPayload<T> | null, null>

    /**
     * Find one UserActivityLogsToday that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserActivityLogsTodayFindUniqueOrThrowArgs} args - Arguments to find a UserActivityLogsToday
     * @example
     * // Get one UserActivityLogsToday
     * const userActivityLogsToday = await prisma.userActivityLogsToday.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserActivityLogsTodayFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserActivityLogsTodayFindUniqueOrThrowArgs>
    ): Prisma__UserActivityLogsTodayClient<UserActivityLogsTodayGetPayload<T>>

    /**
     * Find the first UserActivityLogsToday that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivityLogsTodayFindFirstArgs} args - Arguments to find a UserActivityLogsToday
     * @example
     * // Get one UserActivityLogsToday
     * const userActivityLogsToday = await prisma.userActivityLogsToday.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserActivityLogsTodayFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserActivityLogsTodayFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserActivityLogsToday'> extends True ? Prisma__UserActivityLogsTodayClient<UserActivityLogsTodayGetPayload<T>> : Prisma__UserActivityLogsTodayClient<UserActivityLogsTodayGetPayload<T> | null, null>

    /**
     * Find the first UserActivityLogsToday that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivityLogsTodayFindFirstOrThrowArgs} args - Arguments to find a UserActivityLogsToday
     * @example
     * // Get one UserActivityLogsToday
     * const userActivityLogsToday = await prisma.userActivityLogsToday.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserActivityLogsTodayFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserActivityLogsTodayFindFirstOrThrowArgs>
    ): Prisma__UserActivityLogsTodayClient<UserActivityLogsTodayGetPayload<T>>

    /**
     * Find zero or more UserActivityLogsTodays that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivityLogsTodayFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserActivityLogsTodays
     * const userActivityLogsTodays = await prisma.userActivityLogsToday.findMany()
     * 
     * // Get first 10 UserActivityLogsTodays
     * const userActivityLogsTodays = await prisma.userActivityLogsToday.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userActivityLogsTodayWithIdOnly = await prisma.userActivityLogsToday.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserActivityLogsTodayFindManyArgs>(
      args?: SelectSubset<T, UserActivityLogsTodayFindManyArgs>
    ): PrismaPromise<Array<UserActivityLogsTodayGetPayload<T>>>

    /**
     * Create a UserActivityLogsToday.
     * @param {UserActivityLogsTodayCreateArgs} args - Arguments to create a UserActivityLogsToday.
     * @example
     * // Create one UserActivityLogsToday
     * const UserActivityLogsToday = await prisma.userActivityLogsToday.create({
     *   data: {
     *     // ... data to create a UserActivityLogsToday
     *   }
     * })
     * 
    **/
    create<T extends UserActivityLogsTodayCreateArgs>(
      args: SelectSubset<T, UserActivityLogsTodayCreateArgs>
    ): Prisma__UserActivityLogsTodayClient<UserActivityLogsTodayGetPayload<T>>

    /**
     * Create many UserActivityLogsTodays.
     *     @param {UserActivityLogsTodayCreateManyArgs} args - Arguments to create many UserActivityLogsTodays.
     *     @example
     *     // Create many UserActivityLogsTodays
     *     const userActivityLogsToday = await prisma.userActivityLogsToday.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserActivityLogsTodayCreateManyArgs>(
      args?: SelectSubset<T, UserActivityLogsTodayCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserActivityLogsToday.
     * @param {UserActivityLogsTodayDeleteArgs} args - Arguments to delete one UserActivityLogsToday.
     * @example
     * // Delete one UserActivityLogsToday
     * const UserActivityLogsToday = await prisma.userActivityLogsToday.delete({
     *   where: {
     *     // ... filter to delete one UserActivityLogsToday
     *   }
     * })
     * 
    **/
    delete<T extends UserActivityLogsTodayDeleteArgs>(
      args: SelectSubset<T, UserActivityLogsTodayDeleteArgs>
    ): Prisma__UserActivityLogsTodayClient<UserActivityLogsTodayGetPayload<T>>

    /**
     * Update one UserActivityLogsToday.
     * @param {UserActivityLogsTodayUpdateArgs} args - Arguments to update one UserActivityLogsToday.
     * @example
     * // Update one UserActivityLogsToday
     * const userActivityLogsToday = await prisma.userActivityLogsToday.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserActivityLogsTodayUpdateArgs>(
      args: SelectSubset<T, UserActivityLogsTodayUpdateArgs>
    ): Prisma__UserActivityLogsTodayClient<UserActivityLogsTodayGetPayload<T>>

    /**
     * Delete zero or more UserActivityLogsTodays.
     * @param {UserActivityLogsTodayDeleteManyArgs} args - Arguments to filter UserActivityLogsTodays to delete.
     * @example
     * // Delete a few UserActivityLogsTodays
     * const { count } = await prisma.userActivityLogsToday.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserActivityLogsTodayDeleteManyArgs>(
      args?: SelectSubset<T, UserActivityLogsTodayDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserActivityLogsTodays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivityLogsTodayUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserActivityLogsTodays
     * const userActivityLogsToday = await prisma.userActivityLogsToday.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserActivityLogsTodayUpdateManyArgs>(
      args: SelectSubset<T, UserActivityLogsTodayUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserActivityLogsToday.
     * @param {UserActivityLogsTodayUpsertArgs} args - Arguments to update or create a UserActivityLogsToday.
     * @example
     * // Update or create a UserActivityLogsToday
     * const userActivityLogsToday = await prisma.userActivityLogsToday.upsert({
     *   create: {
     *     // ... data to create a UserActivityLogsToday
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserActivityLogsToday we want to update
     *   }
     * })
    **/
    upsert<T extends UserActivityLogsTodayUpsertArgs>(
      args: SelectSubset<T, UserActivityLogsTodayUpsertArgs>
    ): Prisma__UserActivityLogsTodayClient<UserActivityLogsTodayGetPayload<T>>

    /**
     * Count the number of UserActivityLogsTodays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivityLogsTodayCountArgs} args - Arguments to filter UserActivityLogsTodays to count.
     * @example
     * // Count the number of UserActivityLogsTodays
     * const count = await prisma.userActivityLogsToday.count({
     *   where: {
     *     // ... the filter for the UserActivityLogsTodays we want to count
     *   }
     * })
    **/
    count<T extends UserActivityLogsTodayCountArgs>(
      args?: Subset<T, UserActivityLogsTodayCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserActivityLogsTodayCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserActivityLogsToday.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivityLogsTodayAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserActivityLogsTodayAggregateArgs>(args: Subset<T, UserActivityLogsTodayAggregateArgs>): PrismaPromise<GetUserActivityLogsTodayAggregateType<T>>

    /**
     * Group by UserActivityLogsToday.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivityLogsTodayGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserActivityLogsTodayGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserActivityLogsTodayGroupByArgs['orderBy'] }
        : { orderBy?: UserActivityLogsTodayGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserActivityLogsTodayGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserActivityLogsTodayGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UserActivityLogsToday.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserActivityLogsTodayClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    guild<T extends GuildArgs= {}>(args?: Subset<T, GuildArgs>): Prisma__GuildClient<GuildGetPayload<T> | Null>;

    activity<T extends ActivityArgs= {}>(args?: Subset<T, ActivityArgs>): Prisma__ActivityClient<ActivityGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UserActivityLogsToday base type for findUnique actions
   */
  export type UserActivityLogsTodayFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the UserActivityLogsToday
     * 
    **/
    select?: UserActivityLogsTodaySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserActivityLogsTodayInclude | null
    /**
     * Filter, which UserActivityLogsToday to fetch.
     * 
    **/
    where: UserActivityLogsTodayWhereUniqueInput
  }

  /**
   * UserActivityLogsToday: findUnique
   */
  export interface UserActivityLogsTodayFindUniqueArgs extends UserActivityLogsTodayFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserActivityLogsToday findUniqueOrThrow
   */
  export type UserActivityLogsTodayFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserActivityLogsToday
     * 
    **/
    select?: UserActivityLogsTodaySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserActivityLogsTodayInclude | null
    /**
     * Filter, which UserActivityLogsToday to fetch.
     * 
    **/
    where: UserActivityLogsTodayWhereUniqueInput
  }


  /**
   * UserActivityLogsToday base type for findFirst actions
   */
  export type UserActivityLogsTodayFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the UserActivityLogsToday
     * 
    **/
    select?: UserActivityLogsTodaySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserActivityLogsTodayInclude | null
    /**
     * Filter, which UserActivityLogsToday to fetch.
     * 
    **/
    where?: UserActivityLogsTodayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserActivityLogsTodays to fetch.
     * 
    **/
    orderBy?: Enumerable<UserActivityLogsTodayOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserActivityLogsTodays.
     * 
    **/
    cursor?: UserActivityLogsTodayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserActivityLogsTodays from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserActivityLogsTodays.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserActivityLogsTodays.
     * 
    **/
    distinct?: Enumerable<UserActivityLogsTodayScalarFieldEnum>
  }

  /**
   * UserActivityLogsToday: findFirst
   */
  export interface UserActivityLogsTodayFindFirstArgs extends UserActivityLogsTodayFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserActivityLogsToday findFirstOrThrow
   */
  export type UserActivityLogsTodayFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserActivityLogsToday
     * 
    **/
    select?: UserActivityLogsTodaySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserActivityLogsTodayInclude | null
    /**
     * Filter, which UserActivityLogsToday to fetch.
     * 
    **/
    where?: UserActivityLogsTodayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserActivityLogsTodays to fetch.
     * 
    **/
    orderBy?: Enumerable<UserActivityLogsTodayOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserActivityLogsTodays.
     * 
    **/
    cursor?: UserActivityLogsTodayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserActivityLogsTodays from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserActivityLogsTodays.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserActivityLogsTodays.
     * 
    **/
    distinct?: Enumerable<UserActivityLogsTodayScalarFieldEnum>
  }


  /**
   * UserActivityLogsToday findMany
   */
  export type UserActivityLogsTodayFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserActivityLogsToday
     * 
    **/
    select?: UserActivityLogsTodaySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserActivityLogsTodayInclude | null
    /**
     * Filter, which UserActivityLogsTodays to fetch.
     * 
    **/
    where?: UserActivityLogsTodayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserActivityLogsTodays to fetch.
     * 
    **/
    orderBy?: Enumerable<UserActivityLogsTodayOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserActivityLogsTodays.
     * 
    **/
    cursor?: UserActivityLogsTodayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserActivityLogsTodays from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserActivityLogsTodays.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserActivityLogsTodayScalarFieldEnum>
  }


  /**
   * UserActivityLogsToday create
   */
  export type UserActivityLogsTodayCreateArgs = {
    /**
     * Select specific fields to fetch from the UserActivityLogsToday
     * 
    **/
    select?: UserActivityLogsTodaySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserActivityLogsTodayInclude | null
    /**
     * The data needed to create a UserActivityLogsToday.
     * 
    **/
    data: XOR<UserActivityLogsTodayCreateInput, UserActivityLogsTodayUncheckedCreateInput>
  }


  /**
   * UserActivityLogsToday createMany
   */
  export type UserActivityLogsTodayCreateManyArgs = {
    /**
     * The data used to create many UserActivityLogsTodays.
     * 
    **/
    data: Enumerable<UserActivityLogsTodayCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserActivityLogsToday update
   */
  export type UserActivityLogsTodayUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserActivityLogsToday
     * 
    **/
    select?: UserActivityLogsTodaySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserActivityLogsTodayInclude | null
    /**
     * The data needed to update a UserActivityLogsToday.
     * 
    **/
    data: XOR<UserActivityLogsTodayUpdateInput, UserActivityLogsTodayUncheckedUpdateInput>
    /**
     * Choose, which UserActivityLogsToday to update.
     * 
    **/
    where: UserActivityLogsTodayWhereUniqueInput
  }


  /**
   * UserActivityLogsToday updateMany
   */
  export type UserActivityLogsTodayUpdateManyArgs = {
    /**
     * The data used to update UserActivityLogsTodays.
     * 
    **/
    data: XOR<UserActivityLogsTodayUpdateManyMutationInput, UserActivityLogsTodayUncheckedUpdateManyInput>
    /**
     * Filter which UserActivityLogsTodays to update
     * 
    **/
    where?: UserActivityLogsTodayWhereInput
  }


  /**
   * UserActivityLogsToday upsert
   */
  export type UserActivityLogsTodayUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserActivityLogsToday
     * 
    **/
    select?: UserActivityLogsTodaySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserActivityLogsTodayInclude | null
    /**
     * The filter to search for the UserActivityLogsToday to update in case it exists.
     * 
    **/
    where: UserActivityLogsTodayWhereUniqueInput
    /**
     * In case the UserActivityLogsToday found by the `where` argument doesn't exist, create a new UserActivityLogsToday with this data.
     * 
    **/
    create: XOR<UserActivityLogsTodayCreateInput, UserActivityLogsTodayUncheckedCreateInput>
    /**
     * In case the UserActivityLogsToday was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserActivityLogsTodayUpdateInput, UserActivityLogsTodayUncheckedUpdateInput>
  }


  /**
   * UserActivityLogsToday delete
   */
  export type UserActivityLogsTodayDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserActivityLogsToday
     * 
    **/
    select?: UserActivityLogsTodaySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserActivityLogsTodayInclude | null
    /**
     * Filter which UserActivityLogsToday to delete.
     * 
    **/
    where: UserActivityLogsTodayWhereUniqueInput
  }


  /**
   * UserActivityLogsToday deleteMany
   */
  export type UserActivityLogsTodayDeleteManyArgs = {
    /**
     * Filter which UserActivityLogsTodays to delete
     * 
    **/
    where?: UserActivityLogsTodayWhereInput
  }


  /**
   * UserActivityLogsToday without action
   */
  export type UserActivityLogsTodayArgs = {
    /**
     * Select specific fields to fetch from the UserActivityLogsToday
     * 
    **/
    select?: UserActivityLogsTodaySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserActivityLogsTodayInclude | null
  }



  /**
   * Model LevelRole
   */


  export type AggregateLevelRole = {
    _count: LevelRoleCountAggregateOutputType | null
    _avg: LevelRoleAvgAggregateOutputType | null
    _sum: LevelRoleSumAggregateOutputType | null
    _min: LevelRoleMinAggregateOutputType | null
    _max: LevelRoleMaxAggregateOutputType | null
  }

  export type LevelRoleAvgAggregateOutputType = {
    minlevel: number | null
  }

  export type LevelRoleSumAggregateOutputType = {
    minlevel: number | null
  }

  export type LevelRoleMinAggregateOutputType = {
    name: levelRole | null
    minlevel: number | null
  }

  export type LevelRoleMaxAggregateOutputType = {
    name: levelRole | null
    minlevel: number | null
  }

  export type LevelRoleCountAggregateOutputType = {
    name: number
    minlevel: number
    _all: number
  }


  export type LevelRoleAvgAggregateInputType = {
    minlevel?: true
  }

  export type LevelRoleSumAggregateInputType = {
    minlevel?: true
  }

  export type LevelRoleMinAggregateInputType = {
    name?: true
    minlevel?: true
  }

  export type LevelRoleMaxAggregateInputType = {
    name?: true
    minlevel?: true
  }

  export type LevelRoleCountAggregateInputType = {
    name?: true
    minlevel?: true
    _all?: true
  }

  export type LevelRoleAggregateArgs = {
    /**
     * Filter which LevelRole to aggregate.
     * 
    **/
    where?: LevelRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LevelRoles to fetch.
     * 
    **/
    orderBy?: Enumerable<LevelRoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: LevelRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LevelRoles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LevelRoles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LevelRoles
    **/
    _count?: true | LevelRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LevelRoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LevelRoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LevelRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LevelRoleMaxAggregateInputType
  }

  export type GetLevelRoleAggregateType<T extends LevelRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateLevelRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLevelRole[P]>
      : GetScalarType<T[P], AggregateLevelRole[P]>
  }




  export type LevelRoleGroupByArgs = {
    where?: LevelRoleWhereInput
    orderBy?: Enumerable<LevelRoleOrderByWithAggregationInput>
    by: Array<LevelRoleScalarFieldEnum>
    having?: LevelRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LevelRoleCountAggregateInputType | true
    _avg?: LevelRoleAvgAggregateInputType
    _sum?: LevelRoleSumAggregateInputType
    _min?: LevelRoleMinAggregateInputType
    _max?: LevelRoleMaxAggregateInputType
  }


  export type LevelRoleGroupByOutputType = {
    name: levelRole
    minlevel: number
    _count: LevelRoleCountAggregateOutputType | null
    _avg: LevelRoleAvgAggregateOutputType | null
    _sum: LevelRoleSumAggregateOutputType | null
    _min: LevelRoleMinAggregateOutputType | null
    _max: LevelRoleMaxAggregateOutputType | null
  }

  type GetLevelRoleGroupByPayload<T extends LevelRoleGroupByArgs> = PrismaPromise<
    Array<
      PickArray<LevelRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LevelRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LevelRoleGroupByOutputType[P]>
            : GetScalarType<T[P], LevelRoleGroupByOutputType[P]>
        }
      >
    >


  export type LevelRoleSelect = {
    name?: boolean
    minlevel?: boolean
  }


  export type LevelRoleGetPayload<S extends boolean | null | undefined | LevelRoleArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LevelRole :
    S extends undefined ? never :
    S extends { include: any } & (LevelRoleArgs | LevelRoleFindManyArgs)
    ? LevelRole 
    : S extends { select: any } & (LevelRoleArgs | LevelRoleFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof LevelRole ? LevelRole[P] : never
  } 
      : LevelRole


  type LevelRoleCountArgs = Merge<
    Omit<LevelRoleFindManyArgs, 'select' | 'include'> & {
      select?: LevelRoleCountAggregateInputType | true
    }
  >

  export interface LevelRoleDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one LevelRole that matches the filter.
     * @param {LevelRoleFindUniqueArgs} args - Arguments to find a LevelRole
     * @example
     * // Get one LevelRole
     * const levelRole = await prisma.levelRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LevelRoleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LevelRoleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LevelRole'> extends True ? Prisma__LevelRoleClient<LevelRoleGetPayload<T>> : Prisma__LevelRoleClient<LevelRoleGetPayload<T> | null, null>

    /**
     * Find one LevelRole that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LevelRoleFindUniqueOrThrowArgs} args - Arguments to find a LevelRole
     * @example
     * // Get one LevelRole
     * const levelRole = await prisma.levelRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LevelRoleFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LevelRoleFindUniqueOrThrowArgs>
    ): Prisma__LevelRoleClient<LevelRoleGetPayload<T>>

    /**
     * Find the first LevelRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelRoleFindFirstArgs} args - Arguments to find a LevelRole
     * @example
     * // Get one LevelRole
     * const levelRole = await prisma.levelRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LevelRoleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LevelRoleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LevelRole'> extends True ? Prisma__LevelRoleClient<LevelRoleGetPayload<T>> : Prisma__LevelRoleClient<LevelRoleGetPayload<T> | null, null>

    /**
     * Find the first LevelRole that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelRoleFindFirstOrThrowArgs} args - Arguments to find a LevelRole
     * @example
     * // Get one LevelRole
     * const levelRole = await prisma.levelRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LevelRoleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LevelRoleFindFirstOrThrowArgs>
    ): Prisma__LevelRoleClient<LevelRoleGetPayload<T>>

    /**
     * Find zero or more LevelRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelRoleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LevelRoles
     * const levelRoles = await prisma.levelRole.findMany()
     * 
     * // Get first 10 LevelRoles
     * const levelRoles = await prisma.levelRole.findMany({ take: 10 })
     * 
     * // Only select the `minlevel`
     * const levelRoleWithMinlevelOnly = await prisma.levelRole.findMany({ select: { minlevel: true } })
     * 
    **/
    findMany<T extends LevelRoleFindManyArgs>(
      args?: SelectSubset<T, LevelRoleFindManyArgs>
    ): PrismaPromise<Array<LevelRoleGetPayload<T>>>

    /**
     * Create a LevelRole.
     * @param {LevelRoleCreateArgs} args - Arguments to create a LevelRole.
     * @example
     * // Create one LevelRole
     * const LevelRole = await prisma.levelRole.create({
     *   data: {
     *     // ... data to create a LevelRole
     *   }
     * })
     * 
    **/
    create<T extends LevelRoleCreateArgs>(
      args: SelectSubset<T, LevelRoleCreateArgs>
    ): Prisma__LevelRoleClient<LevelRoleGetPayload<T>>

    /**
     * Create many LevelRoles.
     *     @param {LevelRoleCreateManyArgs} args - Arguments to create many LevelRoles.
     *     @example
     *     // Create many LevelRoles
     *     const levelRole = await prisma.levelRole.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LevelRoleCreateManyArgs>(
      args?: SelectSubset<T, LevelRoleCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a LevelRole.
     * @param {LevelRoleDeleteArgs} args - Arguments to delete one LevelRole.
     * @example
     * // Delete one LevelRole
     * const LevelRole = await prisma.levelRole.delete({
     *   where: {
     *     // ... filter to delete one LevelRole
     *   }
     * })
     * 
    **/
    delete<T extends LevelRoleDeleteArgs>(
      args: SelectSubset<T, LevelRoleDeleteArgs>
    ): Prisma__LevelRoleClient<LevelRoleGetPayload<T>>

    /**
     * Update one LevelRole.
     * @param {LevelRoleUpdateArgs} args - Arguments to update one LevelRole.
     * @example
     * // Update one LevelRole
     * const levelRole = await prisma.levelRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LevelRoleUpdateArgs>(
      args: SelectSubset<T, LevelRoleUpdateArgs>
    ): Prisma__LevelRoleClient<LevelRoleGetPayload<T>>

    /**
     * Delete zero or more LevelRoles.
     * @param {LevelRoleDeleteManyArgs} args - Arguments to filter LevelRoles to delete.
     * @example
     * // Delete a few LevelRoles
     * const { count } = await prisma.levelRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LevelRoleDeleteManyArgs>(
      args?: SelectSubset<T, LevelRoleDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more LevelRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LevelRoles
     * const levelRole = await prisma.levelRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LevelRoleUpdateManyArgs>(
      args: SelectSubset<T, LevelRoleUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one LevelRole.
     * @param {LevelRoleUpsertArgs} args - Arguments to update or create a LevelRole.
     * @example
     * // Update or create a LevelRole
     * const levelRole = await prisma.levelRole.upsert({
     *   create: {
     *     // ... data to create a LevelRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LevelRole we want to update
     *   }
     * })
    **/
    upsert<T extends LevelRoleUpsertArgs>(
      args: SelectSubset<T, LevelRoleUpsertArgs>
    ): Prisma__LevelRoleClient<LevelRoleGetPayload<T>>

    /**
     * Count the number of LevelRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelRoleCountArgs} args - Arguments to filter LevelRoles to count.
     * @example
     * // Count the number of LevelRoles
     * const count = await prisma.levelRole.count({
     *   where: {
     *     // ... the filter for the LevelRoles we want to count
     *   }
     * })
    **/
    count<T extends LevelRoleCountArgs>(
      args?: Subset<T, LevelRoleCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LevelRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LevelRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LevelRoleAggregateArgs>(args: Subset<T, LevelRoleAggregateArgs>): PrismaPromise<GetLevelRoleAggregateType<T>>

    /**
     * Group by LevelRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LevelRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LevelRoleGroupByArgs['orderBy'] }
        : { orderBy?: LevelRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LevelRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLevelRoleGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for LevelRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LevelRoleClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * LevelRole base type for findUnique actions
   */
  export type LevelRoleFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the LevelRole
     * 
    **/
    select?: LevelRoleSelect | null
    /**
     * Filter, which LevelRole to fetch.
     * 
    **/
    where: LevelRoleWhereUniqueInput
  }

  /**
   * LevelRole: findUnique
   */
  export interface LevelRoleFindUniqueArgs extends LevelRoleFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LevelRole findUniqueOrThrow
   */
  export type LevelRoleFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LevelRole
     * 
    **/
    select?: LevelRoleSelect | null
    /**
     * Filter, which LevelRole to fetch.
     * 
    **/
    where: LevelRoleWhereUniqueInput
  }


  /**
   * LevelRole base type for findFirst actions
   */
  export type LevelRoleFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the LevelRole
     * 
    **/
    select?: LevelRoleSelect | null
    /**
     * Filter, which LevelRole to fetch.
     * 
    **/
    where?: LevelRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LevelRoles to fetch.
     * 
    **/
    orderBy?: Enumerable<LevelRoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LevelRoles.
     * 
    **/
    cursor?: LevelRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LevelRoles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LevelRoles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LevelRoles.
     * 
    **/
    distinct?: Enumerable<LevelRoleScalarFieldEnum>
  }

  /**
   * LevelRole: findFirst
   */
  export interface LevelRoleFindFirstArgs extends LevelRoleFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LevelRole findFirstOrThrow
   */
  export type LevelRoleFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LevelRole
     * 
    **/
    select?: LevelRoleSelect | null
    /**
     * Filter, which LevelRole to fetch.
     * 
    **/
    where?: LevelRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LevelRoles to fetch.
     * 
    **/
    orderBy?: Enumerable<LevelRoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LevelRoles.
     * 
    **/
    cursor?: LevelRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LevelRoles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LevelRoles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LevelRoles.
     * 
    **/
    distinct?: Enumerable<LevelRoleScalarFieldEnum>
  }


  /**
   * LevelRole findMany
   */
  export type LevelRoleFindManyArgs = {
    /**
     * Select specific fields to fetch from the LevelRole
     * 
    **/
    select?: LevelRoleSelect | null
    /**
     * Filter, which LevelRoles to fetch.
     * 
    **/
    where?: LevelRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LevelRoles to fetch.
     * 
    **/
    orderBy?: Enumerable<LevelRoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LevelRoles.
     * 
    **/
    cursor?: LevelRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LevelRoles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LevelRoles.
     * 
    **/
    skip?: number
    distinct?: Enumerable<LevelRoleScalarFieldEnum>
  }


  /**
   * LevelRole create
   */
  export type LevelRoleCreateArgs = {
    /**
     * Select specific fields to fetch from the LevelRole
     * 
    **/
    select?: LevelRoleSelect | null
    /**
     * The data needed to create a LevelRole.
     * 
    **/
    data: XOR<LevelRoleCreateInput, LevelRoleUncheckedCreateInput>
  }


  /**
   * LevelRole createMany
   */
  export type LevelRoleCreateManyArgs = {
    /**
     * The data used to create many LevelRoles.
     * 
    **/
    data: Enumerable<LevelRoleCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LevelRole update
   */
  export type LevelRoleUpdateArgs = {
    /**
     * Select specific fields to fetch from the LevelRole
     * 
    **/
    select?: LevelRoleSelect | null
    /**
     * The data needed to update a LevelRole.
     * 
    **/
    data: XOR<LevelRoleUpdateInput, LevelRoleUncheckedUpdateInput>
    /**
     * Choose, which LevelRole to update.
     * 
    **/
    where: LevelRoleWhereUniqueInput
  }


  /**
   * LevelRole updateMany
   */
  export type LevelRoleUpdateManyArgs = {
    /**
     * The data used to update LevelRoles.
     * 
    **/
    data: XOR<LevelRoleUpdateManyMutationInput, LevelRoleUncheckedUpdateManyInput>
    /**
     * Filter which LevelRoles to update
     * 
    **/
    where?: LevelRoleWhereInput
  }


  /**
   * LevelRole upsert
   */
  export type LevelRoleUpsertArgs = {
    /**
     * Select specific fields to fetch from the LevelRole
     * 
    **/
    select?: LevelRoleSelect | null
    /**
     * The filter to search for the LevelRole to update in case it exists.
     * 
    **/
    where: LevelRoleWhereUniqueInput
    /**
     * In case the LevelRole found by the `where` argument doesn't exist, create a new LevelRole with this data.
     * 
    **/
    create: XOR<LevelRoleCreateInput, LevelRoleUncheckedCreateInput>
    /**
     * In case the LevelRole was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<LevelRoleUpdateInput, LevelRoleUncheckedUpdateInput>
  }


  /**
   * LevelRole delete
   */
  export type LevelRoleDeleteArgs = {
    /**
     * Select specific fields to fetch from the LevelRole
     * 
    **/
    select?: LevelRoleSelect | null
    /**
     * Filter which LevelRole to delete.
     * 
    **/
    where: LevelRoleWhereUniqueInput
  }


  /**
   * LevelRole deleteMany
   */
  export type LevelRoleDeleteManyArgs = {
    /**
     * Filter which LevelRoles to delete
     * 
    **/
    where?: LevelRoleWhereInput
  }


  /**
   * LevelRole without action
   */
  export type LevelRoleArgs = {
    /**
     * Select specific fields to fetch from the LevelRole
     * 
    **/
    select?: LevelRoleSelect | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const ActivityRewardsScalarFieldEnum: {
    activityID: 'activityID',
    id: 'id',
    rewardMinute: 'rewardMinute',
    rewardMinuteCam: 'rewardMinuteCam',
    rewardMinuteLog: 'rewardMinuteLog',
    RewardStreak: 'RewardStreak',
    RewardRestart: 'RewardRestart',
    rewardMin: 'rewardMin',
    rewardMax: 'rewardMax',
    reward: 'reward'
  };

  export type ActivityRewardsScalarFieldEnum = (typeof ActivityRewardsScalarFieldEnum)[keyof typeof ActivityRewardsScalarFieldEnum]


  export const ActivityScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type ActivityScalarFieldEnum = (typeof ActivityScalarFieldEnum)[keyof typeof ActivityScalarFieldEnum]


  export const GuildPreferencesScalarFieldEnum: {
    id: 'id',
    guildID: 'guildID'
  };

  export type GuildPreferencesScalarFieldEnum = (typeof GuildPreferencesScalarFieldEnum)[keyof typeof GuildPreferencesScalarFieldEnum]


  export const GuildScalarFieldEnum: {
    id: 'id',
    name: 'name',
    preferenceID: 'preferenceID'
  };

  export type GuildScalarFieldEnum = (typeof GuildScalarFieldEnum)[keyof typeof GuildScalarFieldEnum]


  export const HistoricLogsScalarFieldEnum: {
    id: 'id',
    date: 'date',
    type: 'type',
    timeframe: 'timeframe',
    userId: 'userId',
    activityId: 'activityId',
    guildId: 'guildId'
  };

  export type HistoricLogsScalarFieldEnum = (typeof HistoricLogsScalarFieldEnum)[keyof typeof HistoricLogsScalarFieldEnum]


  export const HistoricQuickLogsScalarFieldEnum: {
    id: 'id',
    date: 'date',
    type: 'type',
    start: 'start',
    end: 'end',
    userId: 'userId',
    activityId: 'activityId',
    guildId: 'guildId'
  };

  export type HistoricQuickLogsScalarFieldEnum = (typeof HistoricQuickLogsScalarFieldEnum)[keyof typeof HistoricQuickLogsScalarFieldEnum]


  export const LevelRoleScalarFieldEnum: {
    name: 'name',
    minlevel: 'minlevel'
  };

  export type LevelRoleScalarFieldEnum = (typeof LevelRoleScalarFieldEnum)[keyof typeof LevelRoleScalarFieldEnum]


  export const LogsNowScalarFieldEnum: {
    id: 'id',
    timestamp: 'timestamp',
    type: 'type',
    userId: 'userId',
    activityId: 'activityId',
    guildId: 'guildId'
  };

  export type LogsNowScalarFieldEnum = (typeof LogsNowScalarFieldEnum)[keyof typeof LogsNowScalarFieldEnum]


  export const LogsTodayScalarFieldEnum: {
    id: 'id',
    date: 'date',
    Type: 'Type',
    Timeframe: 'Timeframe',
    minutes: 'minutes',
    userId: 'userId',
    activityId: 'activityId'
  };

  export type LogsTodayScalarFieldEnum = (typeof LogsTodayScalarFieldEnum)[keyof typeof LogsTodayScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserActivityLogsTodayScalarFieldEnum: {
    id: 'id',
    type: 'type',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    userId: 'userId',
    guildId: 'guildId',
    activityId: 'activityId'
  };

  export type UserActivityLogsTodayScalarFieldEnum = (typeof UserActivityLogsTodayScalarFieldEnum)[keyof typeof UserActivityLogsTodayScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    nick: 'nick',
    timezone: 'timezone',
    role: 'role',
    levelRole: 'levelRole'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    nick?: StringFilter | string
    timezone?: IntFilter | number
    role?: EnumroleFilter | role
    levelRole?: EnumlevelRoleFilter | levelRole
    guilds?: GuildListRelationFilter
    logsNow?: LogsNowListRelationFilter
    historicLogs?: HistoricLogsListRelationFilter
    historicQuickLogs?: HistoricQuickLogsListRelationFilter
    logsToday?: LogsTodayListRelationFilter
    UserActivityLogsToday?: UserActivityLogsTodayListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    nick?: SortOrder
    timezone?: SortOrder
    role?: SortOrder
    levelRole?: SortOrder
    guilds?: GuildOrderByRelationAggregateInput
    logsNow?: logsNowOrderByRelationAggregateInput
    historicLogs?: historicLogsOrderByRelationAggregateInput
    historicQuickLogs?: historicQuickLogsOrderByRelationAggregateInput
    logsToday?: logsTodayOrderByRelationAggregateInput
    UserActivityLogsToday?: UserActivityLogsTodayOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    id?: number
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    nick?: SortOrder
    timezone?: SortOrder
    role?: SortOrder
    levelRole?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    nick?: StringWithAggregatesFilter | string
    timezone?: IntWithAggregatesFilter | number
    role?: EnumroleWithAggregatesFilter | role
    levelRole?: EnumlevelRoleWithAggregatesFilter | levelRole
  }

  export type GuildWhereInput = {
    AND?: Enumerable<GuildWhereInput>
    OR?: Enumerable<GuildWhereInput>
    NOT?: Enumerable<GuildWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    users?: UserListRelationFilter
    GuildPreferences?: XOR<GuildPreferencesRelationFilter, GuildPreferencesWhereInput> | null
    preferenceID?: IntFilter | number
    logsNow?: LogsNowListRelationFilter
    historicLogs?: HistoricLogsListRelationFilter
    historicQuickLogs?: HistoricQuickLogsListRelationFilter
    UserActivityLogsToday?: UserActivityLogsTodayListRelationFilter
  }

  export type GuildOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    users?: UserOrderByRelationAggregateInput
    GuildPreferences?: GuildPreferencesOrderByWithRelationInput
    preferenceID?: SortOrder
    logsNow?: logsNowOrderByRelationAggregateInput
    historicLogs?: historicLogsOrderByRelationAggregateInput
    historicQuickLogs?: historicQuickLogsOrderByRelationAggregateInput
    UserActivityLogsToday?: UserActivityLogsTodayOrderByRelationAggregateInput
  }

  export type GuildWhereUniqueInput = {
    id?: string
    preferenceID?: number
  }

  export type GuildOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    preferenceID?: SortOrder
    _count?: GuildCountOrderByAggregateInput
    _avg?: GuildAvgOrderByAggregateInput
    _max?: GuildMaxOrderByAggregateInput
    _min?: GuildMinOrderByAggregateInput
    _sum?: GuildSumOrderByAggregateInput
  }

  export type GuildScalarWhereWithAggregatesInput = {
    AND?: Enumerable<GuildScalarWhereWithAggregatesInput>
    OR?: Enumerable<GuildScalarWhereWithAggregatesInput>
    NOT?: Enumerable<GuildScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    preferenceID?: IntWithAggregatesFilter | number
  }

  export type GuildPreferencesWhereInput = {
    AND?: Enumerable<GuildPreferencesWhereInput>
    OR?: Enumerable<GuildPreferencesWhereInput>
    NOT?: Enumerable<GuildPreferencesWhereInput>
    id?: IntFilter | number
    guild?: XOR<GuildRelationFilter, GuildWhereInput> | null
    guildID?: StringFilter | string
  }

  export type GuildPreferencesOrderByWithRelationInput = {
    id?: SortOrder
    guild?: GuildOrderByWithRelationInput
    guildID?: SortOrder
  }

  export type GuildPreferencesWhereUniqueInput = {
    id?: number
    guildID?: string
  }

  export type GuildPreferencesOrderByWithAggregationInput = {
    id?: SortOrder
    guildID?: SortOrder
    _count?: GuildPreferencesCountOrderByAggregateInput
    _avg?: GuildPreferencesAvgOrderByAggregateInput
    _max?: GuildPreferencesMaxOrderByAggregateInput
    _min?: GuildPreferencesMinOrderByAggregateInput
    _sum?: GuildPreferencesSumOrderByAggregateInput
  }

  export type GuildPreferencesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<GuildPreferencesScalarWhereWithAggregatesInput>
    OR?: Enumerable<GuildPreferencesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<GuildPreferencesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    guildID?: StringWithAggregatesFilter | string
  }

  export type ActivityWhereInput = {
    AND?: Enumerable<ActivityWhereInput>
    OR?: Enumerable<ActivityWhereInput>
    NOT?: Enumerable<ActivityWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    rewards?: XOR<ActivityRewardsRelationFilter, ActivityRewardsWhereInput> | null
    UserActivityLogsToday?: UserActivityLogsTodayListRelationFilter
    logsNow?: LogsNowListRelationFilter
    historicLogs?: HistoricLogsListRelationFilter
    historicQuickLogs?: HistoricQuickLogsListRelationFilter
    logsToday?: LogsTodayListRelationFilter
  }

  export type ActivityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    rewards?: ActivityRewardsOrderByWithRelationInput
    UserActivityLogsToday?: UserActivityLogsTodayOrderByRelationAggregateInput
    logsNow?: logsNowOrderByRelationAggregateInput
    historicLogs?: historicLogsOrderByRelationAggregateInput
    historicQuickLogs?: historicQuickLogsOrderByRelationAggregateInput
    logsToday?: logsTodayOrderByRelationAggregateInput
  }

  export type ActivityWhereUniqueInput = {
    id?: number
  }

  export type ActivityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: ActivityCountOrderByAggregateInput
    _avg?: ActivityAvgOrderByAggregateInput
    _max?: ActivityMaxOrderByAggregateInput
    _min?: ActivityMinOrderByAggregateInput
    _sum?: ActivitySumOrderByAggregateInput
  }

  export type ActivityScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ActivityScalarWhereWithAggregatesInput>
    OR?: Enumerable<ActivityScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ActivityScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
  }

  export type ActivityRewardsWhereInput = {
    AND?: Enumerable<ActivityRewardsWhereInput>
    OR?: Enumerable<ActivityRewardsWhereInput>
    NOT?: Enumerable<ActivityRewardsWhereInput>
    Activity?: XOR<ActivityRelationFilter, ActivityWhereInput>
    activityID?: IntFilter | number
    id?: IntFilter | number
    rewardMinute?: IntFilter | number
    rewardMinuteCam?: IntFilter | number
    rewardMinuteLog?: IntFilter | number
    RewardStreak?: IntFilter | number
    RewardRestart?: IntFilter | number
    rewardMin?: IntFilter | number
    rewardMax?: IntFilter | number
    reward?: IntFilter | number
  }

  export type ActivityRewardsOrderByWithRelationInput = {
    Activity?: ActivityOrderByWithRelationInput
    activityID?: SortOrder
    id?: SortOrder
    rewardMinute?: SortOrder
    rewardMinuteCam?: SortOrder
    rewardMinuteLog?: SortOrder
    RewardStreak?: SortOrder
    RewardRestart?: SortOrder
    rewardMin?: SortOrder
    rewardMax?: SortOrder
    reward?: SortOrder
  }

  export type ActivityRewardsWhereUniqueInput = {
    activityID?: number
    id?: number
  }

  export type ActivityRewardsOrderByWithAggregationInput = {
    activityID?: SortOrder
    id?: SortOrder
    rewardMinute?: SortOrder
    rewardMinuteCam?: SortOrder
    rewardMinuteLog?: SortOrder
    RewardStreak?: SortOrder
    RewardRestart?: SortOrder
    rewardMin?: SortOrder
    rewardMax?: SortOrder
    reward?: SortOrder
    _count?: ActivityRewardsCountOrderByAggregateInput
    _avg?: ActivityRewardsAvgOrderByAggregateInput
    _max?: ActivityRewardsMaxOrderByAggregateInput
    _min?: ActivityRewardsMinOrderByAggregateInput
    _sum?: ActivityRewardsSumOrderByAggregateInput
  }

  export type ActivityRewardsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ActivityRewardsScalarWhereWithAggregatesInput>
    OR?: Enumerable<ActivityRewardsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ActivityRewardsScalarWhereWithAggregatesInput>
    activityID?: IntWithAggregatesFilter | number
    id?: IntWithAggregatesFilter | number
    rewardMinute?: IntWithAggregatesFilter | number
    rewardMinuteCam?: IntWithAggregatesFilter | number
    rewardMinuteLog?: IntWithAggregatesFilter | number
    RewardStreak?: IntWithAggregatesFilter | number
    RewardRestart?: IntWithAggregatesFilter | number
    rewardMin?: IntWithAggregatesFilter | number
    rewardMax?: IntWithAggregatesFilter | number
    reward?: IntWithAggregatesFilter | number
  }

  export type logsNowWhereInput = {
    AND?: Enumerable<logsNowWhereInput>
    OR?: Enumerable<logsNowWhereInput>
    NOT?: Enumerable<logsNowWhereInput>
    id?: IntFilter | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    activity?: XOR<ActivityRelationFilter, ActivityWhereInput>
    guild?: XOR<GuildRelationFilter, GuildWhereInput>
    timestamp?: DateTimeFilter | Date | string
    type?: EnumActivityTypeFilter | ActivityType
    userId?: IntFilter | number
    activityId?: IntFilter | number
    guildId?: StringFilter | string
  }

  export type logsNowOrderByWithRelationInput = {
    id?: SortOrder
    user?: UserOrderByWithRelationInput
    activity?: ActivityOrderByWithRelationInput
    guild?: GuildOrderByWithRelationInput
    timestamp?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    activityId?: SortOrder
    guildId?: SortOrder
  }

  export type logsNowWhereUniqueInput = {
    id?: number
  }

  export type logsNowOrderByWithAggregationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    activityId?: SortOrder
    guildId?: SortOrder
    _count?: logsNowCountOrderByAggregateInput
    _avg?: logsNowAvgOrderByAggregateInput
    _max?: logsNowMaxOrderByAggregateInput
    _min?: logsNowMinOrderByAggregateInput
    _sum?: logsNowSumOrderByAggregateInput
  }

  export type logsNowScalarWhereWithAggregatesInput = {
    AND?: Enumerable<logsNowScalarWhereWithAggregatesInput>
    OR?: Enumerable<logsNowScalarWhereWithAggregatesInput>
    NOT?: Enumerable<logsNowScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    timestamp?: DateTimeWithAggregatesFilter | Date | string
    type?: EnumActivityTypeWithAggregatesFilter | ActivityType
    userId?: IntWithAggregatesFilter | number
    activityId?: IntWithAggregatesFilter | number
    guildId?: StringWithAggregatesFilter | string
  }

  export type historicLogsWhereInput = {
    AND?: Enumerable<historicLogsWhereInput>
    OR?: Enumerable<historicLogsWhereInput>
    NOT?: Enumerable<historicLogsWhereInput>
    id?: IntFilter | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    activity?: XOR<ActivityRelationFilter, ActivityWhereInput>
    guild?: XOR<GuildRelationFilter, GuildWhereInput>
    date?: DateTimeFilter | Date | string
    type?: EnumActivityTypeFilter | ActivityType
    timeframe?: EnumTimeframeFilter | Timeframe
    userId?: IntFilter | number
    activityId?: IntFilter | number
    guildId?: StringFilter | string
  }

  export type historicLogsOrderByWithRelationInput = {
    id?: SortOrder
    user?: UserOrderByWithRelationInput
    activity?: ActivityOrderByWithRelationInput
    guild?: GuildOrderByWithRelationInput
    date?: SortOrder
    type?: SortOrder
    timeframe?: SortOrder
    userId?: SortOrder
    activityId?: SortOrder
    guildId?: SortOrder
  }

  export type historicLogsWhereUniqueInput = {
    id?: number
  }

  export type historicLogsOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    timeframe?: SortOrder
    userId?: SortOrder
    activityId?: SortOrder
    guildId?: SortOrder
    _count?: historicLogsCountOrderByAggregateInput
    _avg?: historicLogsAvgOrderByAggregateInput
    _max?: historicLogsMaxOrderByAggregateInput
    _min?: historicLogsMinOrderByAggregateInput
    _sum?: historicLogsSumOrderByAggregateInput
  }

  export type historicLogsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<historicLogsScalarWhereWithAggregatesInput>
    OR?: Enumerable<historicLogsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<historicLogsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    date?: DateTimeWithAggregatesFilter | Date | string
    type?: EnumActivityTypeWithAggregatesFilter | ActivityType
    timeframe?: EnumTimeframeWithAggregatesFilter | Timeframe
    userId?: IntWithAggregatesFilter | number
    activityId?: IntWithAggregatesFilter | number
    guildId?: StringWithAggregatesFilter | string
  }

  export type historicQuickLogsWhereInput = {
    AND?: Enumerable<historicQuickLogsWhereInput>
    OR?: Enumerable<historicQuickLogsWhereInput>
    NOT?: Enumerable<historicQuickLogsWhereInput>
    id?: IntFilter | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    activity?: XOR<ActivityRelationFilter, ActivityWhereInput>
    guild?: XOR<GuildRelationFilter, GuildWhereInput>
    date?: DateTimeFilter | Date | string
    type?: EnumActivityTypeFilter | ActivityType
    start?: DateTimeFilter | Date | string
    end?: DateTimeFilter | Date | string
    userId?: IntFilter | number
    activityId?: IntFilter | number
    guildId?: StringFilter | string
  }

  export type historicQuickLogsOrderByWithRelationInput = {
    id?: SortOrder
    user?: UserOrderByWithRelationInput
    activity?: ActivityOrderByWithRelationInput
    guild?: GuildOrderByWithRelationInput
    date?: SortOrder
    type?: SortOrder
    start?: SortOrder
    end?: SortOrder
    userId?: SortOrder
    activityId?: SortOrder
    guildId?: SortOrder
  }

  export type historicQuickLogsWhereUniqueInput = {
    id?: number
  }

  export type historicQuickLogsOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    start?: SortOrder
    end?: SortOrder
    userId?: SortOrder
    activityId?: SortOrder
    guildId?: SortOrder
    _count?: historicQuickLogsCountOrderByAggregateInput
    _avg?: historicQuickLogsAvgOrderByAggregateInput
    _max?: historicQuickLogsMaxOrderByAggregateInput
    _min?: historicQuickLogsMinOrderByAggregateInput
    _sum?: historicQuickLogsSumOrderByAggregateInput
  }

  export type historicQuickLogsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<historicQuickLogsScalarWhereWithAggregatesInput>
    OR?: Enumerable<historicQuickLogsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<historicQuickLogsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    date?: DateTimeWithAggregatesFilter | Date | string
    type?: EnumActivityTypeWithAggregatesFilter | ActivityType
    start?: DateTimeWithAggregatesFilter | Date | string
    end?: DateTimeWithAggregatesFilter | Date | string
    userId?: IntWithAggregatesFilter | number
    activityId?: IntWithAggregatesFilter | number
    guildId?: StringWithAggregatesFilter | string
  }

  export type logsTodayWhereInput = {
    AND?: Enumerable<logsTodayWhereInput>
    OR?: Enumerable<logsTodayWhereInput>
    NOT?: Enumerable<logsTodayWhereInput>
    id?: IntFilter | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    activity?: XOR<ActivityRelationFilter, ActivityWhereInput>
    date?: DateTimeFilter | Date | string
    Type?: StringFilter | string
    Timeframe?: EnumTimeframeFilter | Timeframe
    minutes?: IntFilter | number
    userId?: IntFilter | number
    activityId?: IntFilter | number
  }

  export type logsTodayOrderByWithRelationInput = {
    id?: SortOrder
    user?: UserOrderByWithRelationInput
    activity?: ActivityOrderByWithRelationInput
    date?: SortOrder
    Type?: SortOrder
    Timeframe?: SortOrder
    minutes?: SortOrder
    userId?: SortOrder
    activityId?: SortOrder
  }

  export type logsTodayWhereUniqueInput = {
    id?: number
  }

  export type logsTodayOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    Type?: SortOrder
    Timeframe?: SortOrder
    minutes?: SortOrder
    userId?: SortOrder
    activityId?: SortOrder
    _count?: logsTodayCountOrderByAggregateInput
    _avg?: logsTodayAvgOrderByAggregateInput
    _max?: logsTodayMaxOrderByAggregateInput
    _min?: logsTodayMinOrderByAggregateInput
    _sum?: logsTodaySumOrderByAggregateInput
  }

  export type logsTodayScalarWhereWithAggregatesInput = {
    AND?: Enumerable<logsTodayScalarWhereWithAggregatesInput>
    OR?: Enumerable<logsTodayScalarWhereWithAggregatesInput>
    NOT?: Enumerable<logsTodayScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    date?: DateTimeWithAggregatesFilter | Date | string
    Type?: StringWithAggregatesFilter | string
    Timeframe?: EnumTimeframeWithAggregatesFilter | Timeframe
    minutes?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    activityId?: IntWithAggregatesFilter | number
  }

  export type UserActivityLogsTodayWhereInput = {
    AND?: Enumerable<UserActivityLogsTodayWhereInput>
    OR?: Enumerable<UserActivityLogsTodayWhereInput>
    NOT?: Enumerable<UserActivityLogsTodayWhereInput>
    id?: IntFilter | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    type?: EnumActivityTypeFilter | ActivityType
    guild?: XOR<GuildRelationFilter, GuildWhereInput>
    activity?: XOR<ActivityRelationFilter, ActivityWhereInput>
    startedAt?: DateTimeFilter | Date | string
    endedAt?: DateTimeFilter | Date | string
    userId?: IntFilter | number
    guildId?: StringFilter | string
    activityId?: IntFilter | number
  }

  export type UserActivityLogsTodayOrderByWithRelationInput = {
    id?: SortOrder
    user?: UserOrderByWithRelationInput
    type?: SortOrder
    guild?: GuildOrderByWithRelationInput
    activity?: ActivityOrderByWithRelationInput
    startedAt?: SortOrder
    endedAt?: SortOrder
    userId?: SortOrder
    guildId?: SortOrder
    activityId?: SortOrder
  }

  export type UserActivityLogsTodayWhereUniqueInput = {
    id?: number
  }

  export type UserActivityLogsTodayOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    userId?: SortOrder
    guildId?: SortOrder
    activityId?: SortOrder
    _count?: UserActivityLogsTodayCountOrderByAggregateInput
    _avg?: UserActivityLogsTodayAvgOrderByAggregateInput
    _max?: UserActivityLogsTodayMaxOrderByAggregateInput
    _min?: UserActivityLogsTodayMinOrderByAggregateInput
    _sum?: UserActivityLogsTodaySumOrderByAggregateInput
  }

  export type UserActivityLogsTodayScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserActivityLogsTodayScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserActivityLogsTodayScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserActivityLogsTodayScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    type?: EnumActivityTypeWithAggregatesFilter | ActivityType
    startedAt?: DateTimeWithAggregatesFilter | Date | string
    endedAt?: DateTimeWithAggregatesFilter | Date | string
    userId?: IntWithAggregatesFilter | number
    guildId?: StringWithAggregatesFilter | string
    activityId?: IntWithAggregatesFilter | number
  }

  export type LevelRoleWhereInput = {
    AND?: Enumerable<LevelRoleWhereInput>
    OR?: Enumerable<LevelRoleWhereInput>
    NOT?: Enumerable<LevelRoleWhereInput>
    name?: EnumlevelRoleFilter | levelRole
    minlevel?: IntFilter | number
  }

  export type LevelRoleOrderByWithRelationInput = {
    name?: SortOrder
    minlevel?: SortOrder
  }

  export type LevelRoleWhereUniqueInput = {
    name?: levelRole
  }

  export type LevelRoleOrderByWithAggregationInput = {
    name?: SortOrder
    minlevel?: SortOrder
    _count?: LevelRoleCountOrderByAggregateInput
    _avg?: LevelRoleAvgOrderByAggregateInput
    _max?: LevelRoleMaxOrderByAggregateInput
    _min?: LevelRoleMinOrderByAggregateInput
    _sum?: LevelRoleSumOrderByAggregateInput
  }

  export type LevelRoleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LevelRoleScalarWhereWithAggregatesInput>
    OR?: Enumerable<LevelRoleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LevelRoleScalarWhereWithAggregatesInput>
    name?: EnumlevelRoleWithAggregatesFilter | levelRole
    minlevel?: IntWithAggregatesFilter | number
  }

  export type UserCreateInput = {
    id: number
    name: string
    nick: string
    timezone?: number
    role: role
    levelRole?: levelRole
    guilds?: GuildCreateNestedManyWithoutUsersInput
    logsNow?: logsNowCreateNestedManyWithoutUserInput
    historicLogs?: historicLogsCreateNestedManyWithoutUserInput
    historicQuickLogs?: historicQuickLogsCreateNestedManyWithoutUserInput
    logsToday?: logsTodayCreateNestedManyWithoutUserInput
    UserActivityLogsToday?: UserActivityLogsTodayCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id: number
    name: string
    nick: string
    timezone?: number
    role: role
    levelRole?: levelRole
    guilds?: GuildUncheckedCreateNestedManyWithoutUsersInput
    logsNow?: logsNowUncheckedCreateNestedManyWithoutUserInput
    historicLogs?: historicLogsUncheckedCreateNestedManyWithoutUserInput
    historicQuickLogs?: historicQuickLogsUncheckedCreateNestedManyWithoutUserInput
    logsToday?: logsTodayUncheckedCreateNestedManyWithoutUserInput
    UserActivityLogsToday?: UserActivityLogsTodayUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    nick?: StringFieldUpdateOperationsInput | string
    timezone?: IntFieldUpdateOperationsInput | number
    role?: EnumroleFieldUpdateOperationsInput | role
    levelRole?: EnumlevelRoleFieldUpdateOperationsInput | levelRole
    guilds?: GuildUpdateManyWithoutUsersNestedInput
    logsNow?: logsNowUpdateManyWithoutUserNestedInput
    historicLogs?: historicLogsUpdateManyWithoutUserNestedInput
    historicQuickLogs?: historicQuickLogsUpdateManyWithoutUserNestedInput
    logsToday?: logsTodayUpdateManyWithoutUserNestedInput
    UserActivityLogsToday?: UserActivityLogsTodayUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    nick?: StringFieldUpdateOperationsInput | string
    timezone?: IntFieldUpdateOperationsInput | number
    role?: EnumroleFieldUpdateOperationsInput | role
    levelRole?: EnumlevelRoleFieldUpdateOperationsInput | levelRole
    guilds?: GuildUncheckedUpdateManyWithoutUsersNestedInput
    logsNow?: logsNowUncheckedUpdateManyWithoutUserNestedInput
    historicLogs?: historicLogsUncheckedUpdateManyWithoutUserNestedInput
    historicQuickLogs?: historicQuickLogsUncheckedUpdateManyWithoutUserNestedInput
    logsToday?: logsTodayUncheckedUpdateManyWithoutUserNestedInput
    UserActivityLogsToday?: UserActivityLogsTodayUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id: number
    name: string
    nick: string
    timezone?: number
    role: role
    levelRole?: levelRole
  }

  export type UserUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    nick?: StringFieldUpdateOperationsInput | string
    timezone?: IntFieldUpdateOperationsInput | number
    role?: EnumroleFieldUpdateOperationsInput | role
    levelRole?: EnumlevelRoleFieldUpdateOperationsInput | levelRole
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    nick?: StringFieldUpdateOperationsInput | string
    timezone?: IntFieldUpdateOperationsInput | number
    role?: EnumroleFieldUpdateOperationsInput | role
    levelRole?: EnumlevelRoleFieldUpdateOperationsInput | levelRole
  }

  export type GuildCreateInput = {
    id: string
    name: string
    users?: UserCreateNestedManyWithoutGuildsInput
    GuildPreferences?: GuildPreferencesCreateNestedOneWithoutGuildInput
    preferenceID: number
    logsNow?: logsNowCreateNestedManyWithoutGuildInput
    historicLogs?: historicLogsCreateNestedManyWithoutGuildInput
    historicQuickLogs?: historicQuickLogsCreateNestedManyWithoutGuildInput
    UserActivityLogsToday?: UserActivityLogsTodayCreateNestedManyWithoutGuildInput
  }

  export type GuildUncheckedCreateInput = {
    id: string
    name: string
    users?: UserUncheckedCreateNestedManyWithoutGuildsInput
    GuildPreferences?: GuildPreferencesUncheckedCreateNestedOneWithoutGuildInput
    preferenceID: number
    logsNow?: logsNowUncheckedCreateNestedManyWithoutGuildInput
    historicLogs?: historicLogsUncheckedCreateNestedManyWithoutGuildInput
    historicQuickLogs?: historicQuickLogsUncheckedCreateNestedManyWithoutGuildInput
    UserActivityLogsToday?: UserActivityLogsTodayUncheckedCreateNestedManyWithoutGuildInput
  }

  export type GuildUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateManyWithoutGuildsNestedInput
    GuildPreferences?: GuildPreferencesUpdateOneWithoutGuildNestedInput
    preferenceID?: IntFieldUpdateOperationsInput | number
    logsNow?: logsNowUpdateManyWithoutGuildNestedInput
    historicLogs?: historicLogsUpdateManyWithoutGuildNestedInput
    historicQuickLogs?: historicQuickLogsUpdateManyWithoutGuildNestedInput
    UserActivityLogsToday?: UserActivityLogsTodayUpdateManyWithoutGuildNestedInput
  }

  export type GuildUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    users?: UserUncheckedUpdateManyWithoutGuildsNestedInput
    GuildPreferences?: GuildPreferencesUncheckedUpdateOneWithoutGuildNestedInput
    preferenceID?: IntFieldUpdateOperationsInput | number
    logsNow?: logsNowUncheckedUpdateManyWithoutGuildNestedInput
    historicLogs?: historicLogsUncheckedUpdateManyWithoutGuildNestedInput
    historicQuickLogs?: historicQuickLogsUncheckedUpdateManyWithoutGuildNestedInput
    UserActivityLogsToday?: UserActivityLogsTodayUncheckedUpdateManyWithoutGuildNestedInput
  }

  export type GuildCreateManyInput = {
    id: string
    name: string
    preferenceID: number
  }

  export type GuildUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    preferenceID?: IntFieldUpdateOperationsInput | number
  }

  export type GuildUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    preferenceID?: IntFieldUpdateOperationsInput | number
  }

  export type GuildPreferencesCreateInput = {
    guild?: GuildCreateNestedOneWithoutGuildPreferencesInput
  }

  export type GuildPreferencesUncheckedCreateInput = {
    id?: number
    guildID: string
  }

  export type GuildPreferencesUpdateInput = {
    guild?: GuildUpdateOneWithoutGuildPreferencesNestedInput
  }

  export type GuildPreferencesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    guildID?: StringFieldUpdateOperationsInput | string
  }

  export type GuildPreferencesCreateManyInput = {
    id?: number
    guildID: string
  }

  export type GuildPreferencesUpdateManyMutationInput = {

  }

  export type GuildPreferencesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    guildID?: StringFieldUpdateOperationsInput | string
  }

  export type ActivityCreateInput = {
    name: string
    rewards?: ActivityRewardsCreateNestedOneWithoutActivityInput
    UserActivityLogsToday?: UserActivityLogsTodayCreateNestedManyWithoutActivityInput
    logsNow?: logsNowCreateNestedManyWithoutActivityInput
    historicLogs?: historicLogsCreateNestedManyWithoutActivityInput
    historicQuickLogs?: historicQuickLogsCreateNestedManyWithoutActivityInput
    logsToday?: logsTodayCreateNestedManyWithoutActivityInput
  }

  export type ActivityUncheckedCreateInput = {
    id?: number
    name: string
    rewards?: ActivityRewardsUncheckedCreateNestedOneWithoutActivityInput
    UserActivityLogsToday?: UserActivityLogsTodayUncheckedCreateNestedManyWithoutActivityInput
    logsNow?: logsNowUncheckedCreateNestedManyWithoutActivityInput
    historicLogs?: historicLogsUncheckedCreateNestedManyWithoutActivityInput
    historicQuickLogs?: historicQuickLogsUncheckedCreateNestedManyWithoutActivityInput
    logsToday?: logsTodayUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    rewards?: ActivityRewardsUpdateOneWithoutActivityNestedInput
    UserActivityLogsToday?: UserActivityLogsTodayUpdateManyWithoutActivityNestedInput
    logsNow?: logsNowUpdateManyWithoutActivityNestedInput
    historicLogs?: historicLogsUpdateManyWithoutActivityNestedInput
    historicQuickLogs?: historicQuickLogsUpdateManyWithoutActivityNestedInput
    logsToday?: logsTodayUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    rewards?: ActivityRewardsUncheckedUpdateOneWithoutActivityNestedInput
    UserActivityLogsToday?: UserActivityLogsTodayUncheckedUpdateManyWithoutActivityNestedInput
    logsNow?: logsNowUncheckedUpdateManyWithoutActivityNestedInput
    historicLogs?: historicLogsUncheckedUpdateManyWithoutActivityNestedInput
    historicQuickLogs?: historicQuickLogsUncheckedUpdateManyWithoutActivityNestedInput
    logsToday?: logsTodayUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type ActivityCreateManyInput = {
    id?: number
    name: string
  }

  export type ActivityUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ActivityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ActivityRewardsCreateInput = {
    Activity: ActivityCreateNestedOneWithoutRewardsInput
    rewardMinute: number
    rewardMinuteCam: number
    rewardMinuteLog: number
    RewardStreak: number
    RewardRestart: number
    rewardMin: number
    rewardMax: number
    reward: number
  }

  export type ActivityRewardsUncheckedCreateInput = {
    activityID: number
    id?: number
    rewardMinute: number
    rewardMinuteCam: number
    rewardMinuteLog: number
    RewardStreak: number
    RewardRestart: number
    rewardMin: number
    rewardMax: number
    reward: number
  }

  export type ActivityRewardsUpdateInput = {
    Activity?: ActivityUpdateOneRequiredWithoutRewardsNestedInput
    rewardMinute?: IntFieldUpdateOperationsInput | number
    rewardMinuteCam?: IntFieldUpdateOperationsInput | number
    rewardMinuteLog?: IntFieldUpdateOperationsInput | number
    RewardStreak?: IntFieldUpdateOperationsInput | number
    RewardRestart?: IntFieldUpdateOperationsInput | number
    rewardMin?: IntFieldUpdateOperationsInput | number
    rewardMax?: IntFieldUpdateOperationsInput | number
    reward?: IntFieldUpdateOperationsInput | number
  }

  export type ActivityRewardsUncheckedUpdateInput = {
    activityID?: IntFieldUpdateOperationsInput | number
    id?: IntFieldUpdateOperationsInput | number
    rewardMinute?: IntFieldUpdateOperationsInput | number
    rewardMinuteCam?: IntFieldUpdateOperationsInput | number
    rewardMinuteLog?: IntFieldUpdateOperationsInput | number
    RewardStreak?: IntFieldUpdateOperationsInput | number
    RewardRestart?: IntFieldUpdateOperationsInput | number
    rewardMin?: IntFieldUpdateOperationsInput | number
    rewardMax?: IntFieldUpdateOperationsInput | number
    reward?: IntFieldUpdateOperationsInput | number
  }

  export type ActivityRewardsCreateManyInput = {
    activityID: number
    id?: number
    rewardMinute: number
    rewardMinuteCam: number
    rewardMinuteLog: number
    RewardStreak: number
    RewardRestart: number
    rewardMin: number
    rewardMax: number
    reward: number
  }

  export type ActivityRewardsUpdateManyMutationInput = {
    rewardMinute?: IntFieldUpdateOperationsInput | number
    rewardMinuteCam?: IntFieldUpdateOperationsInput | number
    rewardMinuteLog?: IntFieldUpdateOperationsInput | number
    RewardStreak?: IntFieldUpdateOperationsInput | number
    RewardRestart?: IntFieldUpdateOperationsInput | number
    rewardMin?: IntFieldUpdateOperationsInput | number
    rewardMax?: IntFieldUpdateOperationsInput | number
    reward?: IntFieldUpdateOperationsInput | number
  }

  export type ActivityRewardsUncheckedUpdateManyInput = {
    activityID?: IntFieldUpdateOperationsInput | number
    id?: IntFieldUpdateOperationsInput | number
    rewardMinute?: IntFieldUpdateOperationsInput | number
    rewardMinuteCam?: IntFieldUpdateOperationsInput | number
    rewardMinuteLog?: IntFieldUpdateOperationsInput | number
    RewardStreak?: IntFieldUpdateOperationsInput | number
    RewardRestart?: IntFieldUpdateOperationsInput | number
    rewardMin?: IntFieldUpdateOperationsInput | number
    rewardMax?: IntFieldUpdateOperationsInput | number
    reward?: IntFieldUpdateOperationsInput | number
  }

  export type logsNowCreateInput = {
    user: UserCreateNestedOneWithoutLogsNowInput
    activity: ActivityCreateNestedOneWithoutLogsNowInput
    guild: GuildCreateNestedOneWithoutLogsNowInput
    timestamp?: Date | string
    type: ActivityType
  }

  export type logsNowUncheckedCreateInput = {
    id?: number
    timestamp?: Date | string
    type: ActivityType
    userId: number
    activityId: number
    guildId: string
  }

  export type logsNowUpdateInput = {
    user?: UserUpdateOneRequiredWithoutLogsNowNestedInput
    activity?: ActivityUpdateOneRequiredWithoutLogsNowNestedInput
    guild?: GuildUpdateOneRequiredWithoutLogsNowNestedInput
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | ActivityType
  }

  export type logsNowUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | ActivityType
    userId?: IntFieldUpdateOperationsInput | number
    activityId?: IntFieldUpdateOperationsInput | number
    guildId?: StringFieldUpdateOperationsInput | string
  }

  export type logsNowCreateManyInput = {
    id?: number
    timestamp?: Date | string
    type: ActivityType
    userId: number
    activityId: number
    guildId: string
  }

  export type logsNowUpdateManyMutationInput = {
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | ActivityType
  }

  export type logsNowUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | ActivityType
    userId?: IntFieldUpdateOperationsInput | number
    activityId?: IntFieldUpdateOperationsInput | number
    guildId?: StringFieldUpdateOperationsInput | string
  }

  export type historicLogsCreateInput = {
    user: UserCreateNestedOneWithoutHistoricLogsInput
    activity: ActivityCreateNestedOneWithoutHistoricLogsInput
    guild: GuildCreateNestedOneWithoutHistoricLogsInput
    date: Date | string
    type: ActivityType
    timeframe: Timeframe
  }

  export type historicLogsUncheckedCreateInput = {
    id?: number
    date: Date | string
    type: ActivityType
    timeframe: Timeframe
    userId: number
    activityId: number
    guildId: string
  }

  export type historicLogsUpdateInput = {
    user?: UserUpdateOneRequiredWithoutHistoricLogsNestedInput
    activity?: ActivityUpdateOneRequiredWithoutHistoricLogsNestedInput
    guild?: GuildUpdateOneRequiredWithoutHistoricLogsNestedInput
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | ActivityType
    timeframe?: EnumTimeframeFieldUpdateOperationsInput | Timeframe
  }

  export type historicLogsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | ActivityType
    timeframe?: EnumTimeframeFieldUpdateOperationsInput | Timeframe
    userId?: IntFieldUpdateOperationsInput | number
    activityId?: IntFieldUpdateOperationsInput | number
    guildId?: StringFieldUpdateOperationsInput | string
  }

  export type historicLogsCreateManyInput = {
    id?: number
    date: Date | string
    type: ActivityType
    timeframe: Timeframe
    userId: number
    activityId: number
    guildId: string
  }

  export type historicLogsUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | ActivityType
    timeframe?: EnumTimeframeFieldUpdateOperationsInput | Timeframe
  }

  export type historicLogsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | ActivityType
    timeframe?: EnumTimeframeFieldUpdateOperationsInput | Timeframe
    userId?: IntFieldUpdateOperationsInput | number
    activityId?: IntFieldUpdateOperationsInput | number
    guildId?: StringFieldUpdateOperationsInput | string
  }

  export type historicQuickLogsCreateInput = {
    user: UserCreateNestedOneWithoutHistoricQuickLogsInput
    activity: ActivityCreateNestedOneWithoutHistoricQuickLogsInput
    guild: GuildCreateNestedOneWithoutHistoricQuickLogsInput
    date: Date | string
    type: ActivityType
    start: Date | string
    end: Date | string
  }

  export type historicQuickLogsUncheckedCreateInput = {
    id?: number
    date: Date | string
    type: ActivityType
    start: Date | string
    end: Date | string
    userId: number
    activityId: number
    guildId: string
  }

  export type historicQuickLogsUpdateInput = {
    user?: UserUpdateOneRequiredWithoutHistoricQuickLogsNestedInput
    activity?: ActivityUpdateOneRequiredWithoutHistoricQuickLogsNestedInput
    guild?: GuildUpdateOneRequiredWithoutHistoricQuickLogsNestedInput
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | ActivityType
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type historicQuickLogsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | ActivityType
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    activityId?: IntFieldUpdateOperationsInput | number
    guildId?: StringFieldUpdateOperationsInput | string
  }

  export type historicQuickLogsCreateManyInput = {
    id?: number
    date: Date | string
    type: ActivityType
    start: Date | string
    end: Date | string
    userId: number
    activityId: number
    guildId: string
  }

  export type historicQuickLogsUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | ActivityType
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type historicQuickLogsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | ActivityType
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    activityId?: IntFieldUpdateOperationsInput | number
    guildId?: StringFieldUpdateOperationsInput | string
  }

  export type logsTodayCreateInput = {
    user: UserCreateNestedOneWithoutLogsTodayInput
    activity: ActivityCreateNestedOneWithoutLogsTodayInput
    date: Date | string
    Type: string
    Timeframe: Timeframe
    minutes?: number
  }

  export type logsTodayUncheckedCreateInput = {
    id?: number
    date: Date | string
    Type: string
    Timeframe: Timeframe
    minutes?: number
    userId: number
    activityId: number
  }

  export type logsTodayUpdateInput = {
    user?: UserUpdateOneRequiredWithoutLogsTodayNestedInput
    activity?: ActivityUpdateOneRequiredWithoutLogsTodayNestedInput
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: StringFieldUpdateOperationsInput | string
    Timeframe?: EnumTimeframeFieldUpdateOperationsInput | Timeframe
    minutes?: IntFieldUpdateOperationsInput | number
  }

  export type logsTodayUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: StringFieldUpdateOperationsInput | string
    Timeframe?: EnumTimeframeFieldUpdateOperationsInput | Timeframe
    minutes?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    activityId?: IntFieldUpdateOperationsInput | number
  }

  export type logsTodayCreateManyInput = {
    id?: number
    date: Date | string
    Type: string
    Timeframe: Timeframe
    minutes?: number
    userId: number
    activityId: number
  }

  export type logsTodayUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: StringFieldUpdateOperationsInput | string
    Timeframe?: EnumTimeframeFieldUpdateOperationsInput | Timeframe
    minutes?: IntFieldUpdateOperationsInput | number
  }

  export type logsTodayUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: StringFieldUpdateOperationsInput | string
    Timeframe?: EnumTimeframeFieldUpdateOperationsInput | Timeframe
    minutes?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    activityId?: IntFieldUpdateOperationsInput | number
  }

  export type UserActivityLogsTodayCreateInput = {
    user: UserCreateNestedOneWithoutUserActivityLogsTodayInput
    type: ActivityType
    guild: GuildCreateNestedOneWithoutUserActivityLogsTodayInput
    activity: ActivityCreateNestedOneWithoutUserActivityLogsTodayInput
    startedAt: Date | string
    endedAt: Date | string
  }

  export type UserActivityLogsTodayUncheckedCreateInput = {
    id?: number
    type: ActivityType
    startedAt: Date | string
    endedAt: Date | string
    userId: number
    guildId: string
    activityId: number
  }

  export type UserActivityLogsTodayUpdateInput = {
    user?: UserUpdateOneRequiredWithoutUserActivityLogsTodayNestedInput
    type?: EnumActivityTypeFieldUpdateOperationsInput | ActivityType
    guild?: GuildUpdateOneRequiredWithoutUserActivityLogsTodayNestedInput
    activity?: ActivityUpdateOneRequiredWithoutUserActivityLogsTodayNestedInput
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserActivityLogsTodayUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumActivityTypeFieldUpdateOperationsInput | ActivityType
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    guildId?: StringFieldUpdateOperationsInput | string
    activityId?: IntFieldUpdateOperationsInput | number
  }

  export type UserActivityLogsTodayCreateManyInput = {
    id?: number
    type: ActivityType
    startedAt: Date | string
    endedAt: Date | string
    userId: number
    guildId: string
    activityId: number
  }

  export type UserActivityLogsTodayUpdateManyMutationInput = {
    type?: EnumActivityTypeFieldUpdateOperationsInput | ActivityType
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserActivityLogsTodayUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumActivityTypeFieldUpdateOperationsInput | ActivityType
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    guildId?: StringFieldUpdateOperationsInput | string
    activityId?: IntFieldUpdateOperationsInput | number
  }

  export type LevelRoleCreateInput = {
    name: levelRole
    minlevel: number
  }

  export type LevelRoleUncheckedCreateInput = {
    name: levelRole
    minlevel: number
  }

  export type LevelRoleUpdateInput = {
    name?: EnumlevelRoleFieldUpdateOperationsInput | levelRole
    minlevel?: IntFieldUpdateOperationsInput | number
  }

  export type LevelRoleUncheckedUpdateInput = {
    name?: EnumlevelRoleFieldUpdateOperationsInput | levelRole
    minlevel?: IntFieldUpdateOperationsInput | number
  }

  export type LevelRoleCreateManyInput = {
    name: levelRole
    minlevel: number
  }

  export type LevelRoleUpdateManyMutationInput = {
    name?: EnumlevelRoleFieldUpdateOperationsInput | levelRole
    minlevel?: IntFieldUpdateOperationsInput | number
  }

  export type LevelRoleUncheckedUpdateManyInput = {
    name?: EnumlevelRoleFieldUpdateOperationsInput | levelRole
    minlevel?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type EnumroleFilter = {
    equals?: role
    in?: Enumerable<role>
    notIn?: Enumerable<role>
    not?: NestedEnumroleFilter | role
  }

  export type EnumlevelRoleFilter = {
    equals?: levelRole
    in?: Enumerable<levelRole>
    notIn?: Enumerable<levelRole>
    not?: NestedEnumlevelRoleFilter | levelRole
  }

  export type GuildListRelationFilter = {
    every?: GuildWhereInput
    some?: GuildWhereInput
    none?: GuildWhereInput
  }

  export type LogsNowListRelationFilter = {
    every?: logsNowWhereInput
    some?: logsNowWhereInput
    none?: logsNowWhereInput
  }

  export type HistoricLogsListRelationFilter = {
    every?: historicLogsWhereInput
    some?: historicLogsWhereInput
    none?: historicLogsWhereInput
  }

  export type HistoricQuickLogsListRelationFilter = {
    every?: historicQuickLogsWhereInput
    some?: historicQuickLogsWhereInput
    none?: historicQuickLogsWhereInput
  }

  export type LogsTodayListRelationFilter = {
    every?: logsTodayWhereInput
    some?: logsTodayWhereInput
    none?: logsTodayWhereInput
  }

  export type UserActivityLogsTodayListRelationFilter = {
    every?: UserActivityLogsTodayWhereInput
    some?: UserActivityLogsTodayWhereInput
    none?: UserActivityLogsTodayWhereInput
  }

  export type GuildOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type logsNowOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type historicLogsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type historicQuickLogsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type logsTodayOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserActivityLogsTodayOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nick?: SortOrder
    timezone?: SortOrder
    role?: SortOrder
    levelRole?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    timezone?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nick?: SortOrder
    timezone?: SortOrder
    role?: SortOrder
    levelRole?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nick?: SortOrder
    timezone?: SortOrder
    role?: SortOrder
    levelRole?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    timezone?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type EnumroleWithAggregatesFilter = {
    equals?: role
    in?: Enumerable<role>
    notIn?: Enumerable<role>
    not?: NestedEnumroleWithAggregatesFilter | role
    _count?: NestedIntFilter
    _min?: NestedEnumroleFilter
    _max?: NestedEnumroleFilter
  }

  export type EnumlevelRoleWithAggregatesFilter = {
    equals?: levelRole
    in?: Enumerable<levelRole>
    notIn?: Enumerable<levelRole>
    not?: NestedEnumlevelRoleWithAggregatesFilter | levelRole
    _count?: NestedIntFilter
    _min?: NestedEnumlevelRoleFilter
    _max?: NestedEnumlevelRoleFilter
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type GuildPreferencesRelationFilter = {
    is?: GuildPreferencesWhereInput | null
    isNot?: GuildPreferencesWhereInput | null
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GuildCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    preferenceID?: SortOrder
  }

  export type GuildAvgOrderByAggregateInput = {
    preferenceID?: SortOrder
  }

  export type GuildMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    preferenceID?: SortOrder
  }

  export type GuildMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    preferenceID?: SortOrder
  }

  export type GuildSumOrderByAggregateInput = {
    preferenceID?: SortOrder
  }

  export type GuildRelationFilter = {
    is?: GuildWhereInput
    isNot?: GuildWhereInput
  }

  export type GuildPreferencesCountOrderByAggregateInput = {
    id?: SortOrder
    guildID?: SortOrder
  }

  export type GuildPreferencesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GuildPreferencesMaxOrderByAggregateInput = {
    id?: SortOrder
    guildID?: SortOrder
  }

  export type GuildPreferencesMinOrderByAggregateInput = {
    id?: SortOrder
    guildID?: SortOrder
  }

  export type GuildPreferencesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ActivityRewardsRelationFilter = {
    is?: ActivityRewardsWhereInput | null
    isNot?: ActivityRewardsWhereInput | null
  }

  export type ActivityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ActivityAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ActivityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ActivitySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ActivityRelationFilter = {
    is?: ActivityWhereInput
    isNot?: ActivityWhereInput
  }

  export type ActivityRewardsCountOrderByAggregateInput = {
    activityID?: SortOrder
    id?: SortOrder
    rewardMinute?: SortOrder
    rewardMinuteCam?: SortOrder
    rewardMinuteLog?: SortOrder
    RewardStreak?: SortOrder
    RewardRestart?: SortOrder
    rewardMin?: SortOrder
    rewardMax?: SortOrder
    reward?: SortOrder
  }

  export type ActivityRewardsAvgOrderByAggregateInput = {
    activityID?: SortOrder
    id?: SortOrder
    rewardMinute?: SortOrder
    rewardMinuteCam?: SortOrder
    rewardMinuteLog?: SortOrder
    RewardStreak?: SortOrder
    RewardRestart?: SortOrder
    rewardMin?: SortOrder
    rewardMax?: SortOrder
    reward?: SortOrder
  }

  export type ActivityRewardsMaxOrderByAggregateInput = {
    activityID?: SortOrder
    id?: SortOrder
    rewardMinute?: SortOrder
    rewardMinuteCam?: SortOrder
    rewardMinuteLog?: SortOrder
    RewardStreak?: SortOrder
    RewardRestart?: SortOrder
    rewardMin?: SortOrder
    rewardMax?: SortOrder
    reward?: SortOrder
  }

  export type ActivityRewardsMinOrderByAggregateInput = {
    activityID?: SortOrder
    id?: SortOrder
    rewardMinute?: SortOrder
    rewardMinuteCam?: SortOrder
    rewardMinuteLog?: SortOrder
    RewardStreak?: SortOrder
    RewardRestart?: SortOrder
    rewardMin?: SortOrder
    rewardMax?: SortOrder
    reward?: SortOrder
  }

  export type ActivityRewardsSumOrderByAggregateInput = {
    activityID?: SortOrder
    id?: SortOrder
    rewardMinute?: SortOrder
    rewardMinuteCam?: SortOrder
    rewardMinuteLog?: SortOrder
    RewardStreak?: SortOrder
    RewardRestart?: SortOrder
    rewardMin?: SortOrder
    rewardMax?: SortOrder
    reward?: SortOrder
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type EnumActivityTypeFilter = {
    equals?: ActivityType
    in?: Enumerable<ActivityType>
    notIn?: Enumerable<ActivityType>
    not?: NestedEnumActivityTypeFilter | ActivityType
  }

  export type logsNowCountOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    activityId?: SortOrder
    guildId?: SortOrder
  }

  export type logsNowAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    activityId?: SortOrder
  }

  export type logsNowMaxOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    activityId?: SortOrder
    guildId?: SortOrder
  }

  export type logsNowMinOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    activityId?: SortOrder
    guildId?: SortOrder
  }

  export type logsNowSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    activityId?: SortOrder
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type EnumActivityTypeWithAggregatesFilter = {
    equals?: ActivityType
    in?: Enumerable<ActivityType>
    notIn?: Enumerable<ActivityType>
    not?: NestedEnumActivityTypeWithAggregatesFilter | ActivityType
    _count?: NestedIntFilter
    _min?: NestedEnumActivityTypeFilter
    _max?: NestedEnumActivityTypeFilter
  }

  export type EnumTimeframeFilter = {
    equals?: Timeframe
    in?: Enumerable<Timeframe>
    notIn?: Enumerable<Timeframe>
    not?: NestedEnumTimeframeFilter | Timeframe
  }

  export type historicLogsCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    timeframe?: SortOrder
    userId?: SortOrder
    activityId?: SortOrder
    guildId?: SortOrder
  }

  export type historicLogsAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    activityId?: SortOrder
  }

  export type historicLogsMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    timeframe?: SortOrder
    userId?: SortOrder
    activityId?: SortOrder
    guildId?: SortOrder
  }

  export type historicLogsMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    timeframe?: SortOrder
    userId?: SortOrder
    activityId?: SortOrder
    guildId?: SortOrder
  }

  export type historicLogsSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    activityId?: SortOrder
  }

  export type EnumTimeframeWithAggregatesFilter = {
    equals?: Timeframe
    in?: Enumerable<Timeframe>
    notIn?: Enumerable<Timeframe>
    not?: NestedEnumTimeframeWithAggregatesFilter | Timeframe
    _count?: NestedIntFilter
    _min?: NestedEnumTimeframeFilter
    _max?: NestedEnumTimeframeFilter
  }

  export type historicQuickLogsCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    start?: SortOrder
    end?: SortOrder
    userId?: SortOrder
    activityId?: SortOrder
    guildId?: SortOrder
  }

  export type historicQuickLogsAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    activityId?: SortOrder
  }

  export type historicQuickLogsMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    start?: SortOrder
    end?: SortOrder
    userId?: SortOrder
    activityId?: SortOrder
    guildId?: SortOrder
  }

  export type historicQuickLogsMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    start?: SortOrder
    end?: SortOrder
    userId?: SortOrder
    activityId?: SortOrder
    guildId?: SortOrder
  }

  export type historicQuickLogsSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    activityId?: SortOrder
  }

  export type logsTodayCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    Type?: SortOrder
    Timeframe?: SortOrder
    minutes?: SortOrder
    userId?: SortOrder
    activityId?: SortOrder
  }

  export type logsTodayAvgOrderByAggregateInput = {
    id?: SortOrder
    minutes?: SortOrder
    userId?: SortOrder
    activityId?: SortOrder
  }

  export type logsTodayMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    Type?: SortOrder
    Timeframe?: SortOrder
    minutes?: SortOrder
    userId?: SortOrder
    activityId?: SortOrder
  }

  export type logsTodayMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    Type?: SortOrder
    Timeframe?: SortOrder
    minutes?: SortOrder
    userId?: SortOrder
    activityId?: SortOrder
  }

  export type logsTodaySumOrderByAggregateInput = {
    id?: SortOrder
    minutes?: SortOrder
    userId?: SortOrder
    activityId?: SortOrder
  }

  export type UserActivityLogsTodayCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    userId?: SortOrder
    guildId?: SortOrder
    activityId?: SortOrder
  }

  export type UserActivityLogsTodayAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    activityId?: SortOrder
  }

  export type UserActivityLogsTodayMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    userId?: SortOrder
    guildId?: SortOrder
    activityId?: SortOrder
  }

  export type UserActivityLogsTodayMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    userId?: SortOrder
    guildId?: SortOrder
    activityId?: SortOrder
  }

  export type UserActivityLogsTodaySumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    activityId?: SortOrder
  }

  export type LevelRoleCountOrderByAggregateInput = {
    name?: SortOrder
    minlevel?: SortOrder
  }

  export type LevelRoleAvgOrderByAggregateInput = {
    minlevel?: SortOrder
  }

  export type LevelRoleMaxOrderByAggregateInput = {
    name?: SortOrder
    minlevel?: SortOrder
  }

  export type LevelRoleMinOrderByAggregateInput = {
    name?: SortOrder
    minlevel?: SortOrder
  }

  export type LevelRoleSumOrderByAggregateInput = {
    minlevel?: SortOrder
  }

  export type GuildCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<GuildCreateWithoutUsersInput>, Enumerable<GuildUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<GuildCreateOrConnectWithoutUsersInput>
    connect?: Enumerable<GuildWhereUniqueInput>
  }

  export type logsNowCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<logsNowCreateWithoutUserInput>, Enumerable<logsNowUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<logsNowCreateOrConnectWithoutUserInput>
    createMany?: logsNowCreateManyUserInputEnvelope
    connect?: Enumerable<logsNowWhereUniqueInput>
  }

  export type historicLogsCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<historicLogsCreateWithoutUserInput>, Enumerable<historicLogsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<historicLogsCreateOrConnectWithoutUserInput>
    createMany?: historicLogsCreateManyUserInputEnvelope
    connect?: Enumerable<historicLogsWhereUniqueInput>
  }

  export type historicQuickLogsCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<historicQuickLogsCreateWithoutUserInput>, Enumerable<historicQuickLogsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<historicQuickLogsCreateOrConnectWithoutUserInput>
    createMany?: historicQuickLogsCreateManyUserInputEnvelope
    connect?: Enumerable<historicQuickLogsWhereUniqueInput>
  }

  export type logsTodayCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<logsTodayCreateWithoutUserInput>, Enumerable<logsTodayUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<logsTodayCreateOrConnectWithoutUserInput>
    createMany?: logsTodayCreateManyUserInputEnvelope
    connect?: Enumerable<logsTodayWhereUniqueInput>
  }

  export type UserActivityLogsTodayCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserActivityLogsTodayCreateWithoutUserInput>, Enumerable<UserActivityLogsTodayUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserActivityLogsTodayCreateOrConnectWithoutUserInput>
    createMany?: UserActivityLogsTodayCreateManyUserInputEnvelope
    connect?: Enumerable<UserActivityLogsTodayWhereUniqueInput>
  }

  export type GuildUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<GuildCreateWithoutUsersInput>, Enumerable<GuildUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<GuildCreateOrConnectWithoutUsersInput>
    connect?: Enumerable<GuildWhereUniqueInput>
  }

  export type logsNowUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<logsNowCreateWithoutUserInput>, Enumerable<logsNowUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<logsNowCreateOrConnectWithoutUserInput>
    createMany?: logsNowCreateManyUserInputEnvelope
    connect?: Enumerable<logsNowWhereUniqueInput>
  }

  export type historicLogsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<historicLogsCreateWithoutUserInput>, Enumerable<historicLogsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<historicLogsCreateOrConnectWithoutUserInput>
    createMany?: historicLogsCreateManyUserInputEnvelope
    connect?: Enumerable<historicLogsWhereUniqueInput>
  }

  export type historicQuickLogsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<historicQuickLogsCreateWithoutUserInput>, Enumerable<historicQuickLogsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<historicQuickLogsCreateOrConnectWithoutUserInput>
    createMany?: historicQuickLogsCreateManyUserInputEnvelope
    connect?: Enumerable<historicQuickLogsWhereUniqueInput>
  }

  export type logsTodayUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<logsTodayCreateWithoutUserInput>, Enumerable<logsTodayUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<logsTodayCreateOrConnectWithoutUserInput>
    createMany?: logsTodayCreateManyUserInputEnvelope
    connect?: Enumerable<logsTodayWhereUniqueInput>
  }

  export type UserActivityLogsTodayUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserActivityLogsTodayCreateWithoutUserInput>, Enumerable<UserActivityLogsTodayUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserActivityLogsTodayCreateOrConnectWithoutUserInput>
    createMany?: UserActivityLogsTodayCreateManyUserInputEnvelope
    connect?: Enumerable<UserActivityLogsTodayWhereUniqueInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumroleFieldUpdateOperationsInput = {
    set?: role
  }

  export type EnumlevelRoleFieldUpdateOperationsInput = {
    set?: levelRole
  }

  export type GuildUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<GuildCreateWithoutUsersInput>, Enumerable<GuildUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<GuildCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<GuildUpsertWithWhereUniqueWithoutUsersInput>
    set?: Enumerable<GuildWhereUniqueInput>
    disconnect?: Enumerable<GuildWhereUniqueInput>
    delete?: Enumerable<GuildWhereUniqueInput>
    connect?: Enumerable<GuildWhereUniqueInput>
    update?: Enumerable<GuildUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<GuildUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<GuildScalarWhereInput>
  }

  export type logsNowUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<logsNowCreateWithoutUserInput>, Enumerable<logsNowUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<logsNowCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<logsNowUpsertWithWhereUniqueWithoutUserInput>
    createMany?: logsNowCreateManyUserInputEnvelope
    set?: Enumerable<logsNowWhereUniqueInput>
    disconnect?: Enumerable<logsNowWhereUniqueInput>
    delete?: Enumerable<logsNowWhereUniqueInput>
    connect?: Enumerable<logsNowWhereUniqueInput>
    update?: Enumerable<logsNowUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<logsNowUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<logsNowScalarWhereInput>
  }

  export type historicLogsUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<historicLogsCreateWithoutUserInput>, Enumerable<historicLogsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<historicLogsCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<historicLogsUpsertWithWhereUniqueWithoutUserInput>
    createMany?: historicLogsCreateManyUserInputEnvelope
    set?: Enumerable<historicLogsWhereUniqueInput>
    disconnect?: Enumerable<historicLogsWhereUniqueInput>
    delete?: Enumerable<historicLogsWhereUniqueInput>
    connect?: Enumerable<historicLogsWhereUniqueInput>
    update?: Enumerable<historicLogsUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<historicLogsUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<historicLogsScalarWhereInput>
  }

  export type historicQuickLogsUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<historicQuickLogsCreateWithoutUserInput>, Enumerable<historicQuickLogsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<historicQuickLogsCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<historicQuickLogsUpsertWithWhereUniqueWithoutUserInput>
    createMany?: historicQuickLogsCreateManyUserInputEnvelope
    set?: Enumerable<historicQuickLogsWhereUniqueInput>
    disconnect?: Enumerable<historicQuickLogsWhereUniqueInput>
    delete?: Enumerable<historicQuickLogsWhereUniqueInput>
    connect?: Enumerable<historicQuickLogsWhereUniqueInput>
    update?: Enumerable<historicQuickLogsUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<historicQuickLogsUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<historicQuickLogsScalarWhereInput>
  }

  export type logsTodayUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<logsTodayCreateWithoutUserInput>, Enumerable<logsTodayUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<logsTodayCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<logsTodayUpsertWithWhereUniqueWithoutUserInput>
    createMany?: logsTodayCreateManyUserInputEnvelope
    set?: Enumerable<logsTodayWhereUniqueInput>
    disconnect?: Enumerable<logsTodayWhereUniqueInput>
    delete?: Enumerable<logsTodayWhereUniqueInput>
    connect?: Enumerable<logsTodayWhereUniqueInput>
    update?: Enumerable<logsTodayUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<logsTodayUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<logsTodayScalarWhereInput>
  }

  export type UserActivityLogsTodayUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserActivityLogsTodayCreateWithoutUserInput>, Enumerable<UserActivityLogsTodayUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserActivityLogsTodayCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserActivityLogsTodayUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserActivityLogsTodayCreateManyUserInputEnvelope
    set?: Enumerable<UserActivityLogsTodayWhereUniqueInput>
    disconnect?: Enumerable<UserActivityLogsTodayWhereUniqueInput>
    delete?: Enumerable<UserActivityLogsTodayWhereUniqueInput>
    connect?: Enumerable<UserActivityLogsTodayWhereUniqueInput>
    update?: Enumerable<UserActivityLogsTodayUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserActivityLogsTodayUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserActivityLogsTodayScalarWhereInput>
  }

  export type GuildUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<GuildCreateWithoutUsersInput>, Enumerable<GuildUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<GuildCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<GuildUpsertWithWhereUniqueWithoutUsersInput>
    set?: Enumerable<GuildWhereUniqueInput>
    disconnect?: Enumerable<GuildWhereUniqueInput>
    delete?: Enumerable<GuildWhereUniqueInput>
    connect?: Enumerable<GuildWhereUniqueInput>
    update?: Enumerable<GuildUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<GuildUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<GuildScalarWhereInput>
  }

  export type logsNowUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<logsNowCreateWithoutUserInput>, Enumerable<logsNowUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<logsNowCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<logsNowUpsertWithWhereUniqueWithoutUserInput>
    createMany?: logsNowCreateManyUserInputEnvelope
    set?: Enumerable<logsNowWhereUniqueInput>
    disconnect?: Enumerable<logsNowWhereUniqueInput>
    delete?: Enumerable<logsNowWhereUniqueInput>
    connect?: Enumerable<logsNowWhereUniqueInput>
    update?: Enumerable<logsNowUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<logsNowUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<logsNowScalarWhereInput>
  }

  export type historicLogsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<historicLogsCreateWithoutUserInput>, Enumerable<historicLogsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<historicLogsCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<historicLogsUpsertWithWhereUniqueWithoutUserInput>
    createMany?: historicLogsCreateManyUserInputEnvelope
    set?: Enumerable<historicLogsWhereUniqueInput>
    disconnect?: Enumerable<historicLogsWhereUniqueInput>
    delete?: Enumerable<historicLogsWhereUniqueInput>
    connect?: Enumerable<historicLogsWhereUniqueInput>
    update?: Enumerable<historicLogsUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<historicLogsUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<historicLogsScalarWhereInput>
  }

  export type historicQuickLogsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<historicQuickLogsCreateWithoutUserInput>, Enumerable<historicQuickLogsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<historicQuickLogsCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<historicQuickLogsUpsertWithWhereUniqueWithoutUserInput>
    createMany?: historicQuickLogsCreateManyUserInputEnvelope
    set?: Enumerable<historicQuickLogsWhereUniqueInput>
    disconnect?: Enumerable<historicQuickLogsWhereUniqueInput>
    delete?: Enumerable<historicQuickLogsWhereUniqueInput>
    connect?: Enumerable<historicQuickLogsWhereUniqueInput>
    update?: Enumerable<historicQuickLogsUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<historicQuickLogsUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<historicQuickLogsScalarWhereInput>
  }

  export type logsTodayUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<logsTodayCreateWithoutUserInput>, Enumerable<logsTodayUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<logsTodayCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<logsTodayUpsertWithWhereUniqueWithoutUserInput>
    createMany?: logsTodayCreateManyUserInputEnvelope
    set?: Enumerable<logsTodayWhereUniqueInput>
    disconnect?: Enumerable<logsTodayWhereUniqueInput>
    delete?: Enumerable<logsTodayWhereUniqueInput>
    connect?: Enumerable<logsTodayWhereUniqueInput>
    update?: Enumerable<logsTodayUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<logsTodayUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<logsTodayScalarWhereInput>
  }

  export type UserActivityLogsTodayUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserActivityLogsTodayCreateWithoutUserInput>, Enumerable<UserActivityLogsTodayUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserActivityLogsTodayCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserActivityLogsTodayUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserActivityLogsTodayCreateManyUserInputEnvelope
    set?: Enumerable<UserActivityLogsTodayWhereUniqueInput>
    disconnect?: Enumerable<UserActivityLogsTodayWhereUniqueInput>
    delete?: Enumerable<UserActivityLogsTodayWhereUniqueInput>
    connect?: Enumerable<UserActivityLogsTodayWhereUniqueInput>
    update?: Enumerable<UserActivityLogsTodayUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserActivityLogsTodayUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserActivityLogsTodayScalarWhereInput>
  }

  export type UserCreateNestedManyWithoutGuildsInput = {
    create?: XOR<Enumerable<UserCreateWithoutGuildsInput>, Enumerable<UserUncheckedCreateWithoutGuildsInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutGuildsInput>
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type GuildPreferencesCreateNestedOneWithoutGuildInput = {
    create?: XOR<GuildPreferencesCreateWithoutGuildInput, GuildPreferencesUncheckedCreateWithoutGuildInput>
    connectOrCreate?: GuildPreferencesCreateOrConnectWithoutGuildInput
    connect?: GuildPreferencesWhereUniqueInput
  }

  export type logsNowCreateNestedManyWithoutGuildInput = {
    create?: XOR<Enumerable<logsNowCreateWithoutGuildInput>, Enumerable<logsNowUncheckedCreateWithoutGuildInput>>
    connectOrCreate?: Enumerable<logsNowCreateOrConnectWithoutGuildInput>
    createMany?: logsNowCreateManyGuildInputEnvelope
    connect?: Enumerable<logsNowWhereUniqueInput>
  }

  export type historicLogsCreateNestedManyWithoutGuildInput = {
    create?: XOR<Enumerable<historicLogsCreateWithoutGuildInput>, Enumerable<historicLogsUncheckedCreateWithoutGuildInput>>
    connectOrCreate?: Enumerable<historicLogsCreateOrConnectWithoutGuildInput>
    createMany?: historicLogsCreateManyGuildInputEnvelope
    connect?: Enumerable<historicLogsWhereUniqueInput>
  }

  export type historicQuickLogsCreateNestedManyWithoutGuildInput = {
    create?: XOR<Enumerable<historicQuickLogsCreateWithoutGuildInput>, Enumerable<historicQuickLogsUncheckedCreateWithoutGuildInput>>
    connectOrCreate?: Enumerable<historicQuickLogsCreateOrConnectWithoutGuildInput>
    createMany?: historicQuickLogsCreateManyGuildInputEnvelope
    connect?: Enumerable<historicQuickLogsWhereUniqueInput>
  }

  export type UserActivityLogsTodayCreateNestedManyWithoutGuildInput = {
    create?: XOR<Enumerable<UserActivityLogsTodayCreateWithoutGuildInput>, Enumerable<UserActivityLogsTodayUncheckedCreateWithoutGuildInput>>
    connectOrCreate?: Enumerable<UserActivityLogsTodayCreateOrConnectWithoutGuildInput>
    createMany?: UserActivityLogsTodayCreateManyGuildInputEnvelope
    connect?: Enumerable<UserActivityLogsTodayWhereUniqueInput>
  }

  export type UserUncheckedCreateNestedManyWithoutGuildsInput = {
    create?: XOR<Enumerable<UserCreateWithoutGuildsInput>, Enumerable<UserUncheckedCreateWithoutGuildsInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutGuildsInput>
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type GuildPreferencesUncheckedCreateNestedOneWithoutGuildInput = {
    create?: XOR<GuildPreferencesCreateWithoutGuildInput, GuildPreferencesUncheckedCreateWithoutGuildInput>
    connectOrCreate?: GuildPreferencesCreateOrConnectWithoutGuildInput
    connect?: GuildPreferencesWhereUniqueInput
  }

  export type logsNowUncheckedCreateNestedManyWithoutGuildInput = {
    create?: XOR<Enumerable<logsNowCreateWithoutGuildInput>, Enumerable<logsNowUncheckedCreateWithoutGuildInput>>
    connectOrCreate?: Enumerable<logsNowCreateOrConnectWithoutGuildInput>
    createMany?: logsNowCreateManyGuildInputEnvelope
    connect?: Enumerable<logsNowWhereUniqueInput>
  }

  export type historicLogsUncheckedCreateNestedManyWithoutGuildInput = {
    create?: XOR<Enumerable<historicLogsCreateWithoutGuildInput>, Enumerable<historicLogsUncheckedCreateWithoutGuildInput>>
    connectOrCreate?: Enumerable<historicLogsCreateOrConnectWithoutGuildInput>
    createMany?: historicLogsCreateManyGuildInputEnvelope
    connect?: Enumerable<historicLogsWhereUniqueInput>
  }

  export type historicQuickLogsUncheckedCreateNestedManyWithoutGuildInput = {
    create?: XOR<Enumerable<historicQuickLogsCreateWithoutGuildInput>, Enumerable<historicQuickLogsUncheckedCreateWithoutGuildInput>>
    connectOrCreate?: Enumerable<historicQuickLogsCreateOrConnectWithoutGuildInput>
    createMany?: historicQuickLogsCreateManyGuildInputEnvelope
    connect?: Enumerable<historicQuickLogsWhereUniqueInput>
  }

  export type UserActivityLogsTodayUncheckedCreateNestedManyWithoutGuildInput = {
    create?: XOR<Enumerable<UserActivityLogsTodayCreateWithoutGuildInput>, Enumerable<UserActivityLogsTodayUncheckedCreateWithoutGuildInput>>
    connectOrCreate?: Enumerable<UserActivityLogsTodayCreateOrConnectWithoutGuildInput>
    createMany?: UserActivityLogsTodayCreateManyGuildInputEnvelope
    connect?: Enumerable<UserActivityLogsTodayWhereUniqueInput>
  }

  export type UserUpdateManyWithoutGuildsNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutGuildsInput>, Enumerable<UserUncheckedCreateWithoutGuildsInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutGuildsInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutGuildsInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutGuildsInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutGuildsInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type GuildPreferencesUpdateOneWithoutGuildNestedInput = {
    create?: XOR<GuildPreferencesCreateWithoutGuildInput, GuildPreferencesUncheckedCreateWithoutGuildInput>
    connectOrCreate?: GuildPreferencesCreateOrConnectWithoutGuildInput
    upsert?: GuildPreferencesUpsertWithoutGuildInput
    disconnect?: boolean
    delete?: boolean
    connect?: GuildPreferencesWhereUniqueInput
    update?: XOR<GuildPreferencesUpdateWithoutGuildInput, GuildPreferencesUncheckedUpdateWithoutGuildInput>
  }

  export type logsNowUpdateManyWithoutGuildNestedInput = {
    create?: XOR<Enumerable<logsNowCreateWithoutGuildInput>, Enumerable<logsNowUncheckedCreateWithoutGuildInput>>
    connectOrCreate?: Enumerable<logsNowCreateOrConnectWithoutGuildInput>
    upsert?: Enumerable<logsNowUpsertWithWhereUniqueWithoutGuildInput>
    createMany?: logsNowCreateManyGuildInputEnvelope
    set?: Enumerable<logsNowWhereUniqueInput>
    disconnect?: Enumerable<logsNowWhereUniqueInput>
    delete?: Enumerable<logsNowWhereUniqueInput>
    connect?: Enumerable<logsNowWhereUniqueInput>
    update?: Enumerable<logsNowUpdateWithWhereUniqueWithoutGuildInput>
    updateMany?: Enumerable<logsNowUpdateManyWithWhereWithoutGuildInput>
    deleteMany?: Enumerable<logsNowScalarWhereInput>
  }

  export type historicLogsUpdateManyWithoutGuildNestedInput = {
    create?: XOR<Enumerable<historicLogsCreateWithoutGuildInput>, Enumerable<historicLogsUncheckedCreateWithoutGuildInput>>
    connectOrCreate?: Enumerable<historicLogsCreateOrConnectWithoutGuildInput>
    upsert?: Enumerable<historicLogsUpsertWithWhereUniqueWithoutGuildInput>
    createMany?: historicLogsCreateManyGuildInputEnvelope
    set?: Enumerable<historicLogsWhereUniqueInput>
    disconnect?: Enumerable<historicLogsWhereUniqueInput>
    delete?: Enumerable<historicLogsWhereUniqueInput>
    connect?: Enumerable<historicLogsWhereUniqueInput>
    update?: Enumerable<historicLogsUpdateWithWhereUniqueWithoutGuildInput>
    updateMany?: Enumerable<historicLogsUpdateManyWithWhereWithoutGuildInput>
    deleteMany?: Enumerable<historicLogsScalarWhereInput>
  }

  export type historicQuickLogsUpdateManyWithoutGuildNestedInput = {
    create?: XOR<Enumerable<historicQuickLogsCreateWithoutGuildInput>, Enumerable<historicQuickLogsUncheckedCreateWithoutGuildInput>>
    connectOrCreate?: Enumerable<historicQuickLogsCreateOrConnectWithoutGuildInput>
    upsert?: Enumerable<historicQuickLogsUpsertWithWhereUniqueWithoutGuildInput>
    createMany?: historicQuickLogsCreateManyGuildInputEnvelope
    set?: Enumerable<historicQuickLogsWhereUniqueInput>
    disconnect?: Enumerable<historicQuickLogsWhereUniqueInput>
    delete?: Enumerable<historicQuickLogsWhereUniqueInput>
    connect?: Enumerable<historicQuickLogsWhereUniqueInput>
    update?: Enumerable<historicQuickLogsUpdateWithWhereUniqueWithoutGuildInput>
    updateMany?: Enumerable<historicQuickLogsUpdateManyWithWhereWithoutGuildInput>
    deleteMany?: Enumerable<historicQuickLogsScalarWhereInput>
  }

  export type UserActivityLogsTodayUpdateManyWithoutGuildNestedInput = {
    create?: XOR<Enumerable<UserActivityLogsTodayCreateWithoutGuildInput>, Enumerable<UserActivityLogsTodayUncheckedCreateWithoutGuildInput>>
    connectOrCreate?: Enumerable<UserActivityLogsTodayCreateOrConnectWithoutGuildInput>
    upsert?: Enumerable<UserActivityLogsTodayUpsertWithWhereUniqueWithoutGuildInput>
    createMany?: UserActivityLogsTodayCreateManyGuildInputEnvelope
    set?: Enumerable<UserActivityLogsTodayWhereUniqueInput>
    disconnect?: Enumerable<UserActivityLogsTodayWhereUniqueInput>
    delete?: Enumerable<UserActivityLogsTodayWhereUniqueInput>
    connect?: Enumerable<UserActivityLogsTodayWhereUniqueInput>
    update?: Enumerable<UserActivityLogsTodayUpdateWithWhereUniqueWithoutGuildInput>
    updateMany?: Enumerable<UserActivityLogsTodayUpdateManyWithWhereWithoutGuildInput>
    deleteMany?: Enumerable<UserActivityLogsTodayScalarWhereInput>
  }

  export type UserUncheckedUpdateManyWithoutGuildsNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutGuildsInput>, Enumerable<UserUncheckedCreateWithoutGuildsInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutGuildsInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutGuildsInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutGuildsInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutGuildsInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type GuildPreferencesUncheckedUpdateOneWithoutGuildNestedInput = {
    create?: XOR<GuildPreferencesCreateWithoutGuildInput, GuildPreferencesUncheckedCreateWithoutGuildInput>
    connectOrCreate?: GuildPreferencesCreateOrConnectWithoutGuildInput
    upsert?: GuildPreferencesUpsertWithoutGuildInput
    disconnect?: boolean
    delete?: boolean
    connect?: GuildPreferencesWhereUniqueInput
    update?: XOR<GuildPreferencesUpdateWithoutGuildInput, GuildPreferencesUncheckedUpdateWithoutGuildInput>
  }

  export type logsNowUncheckedUpdateManyWithoutGuildNestedInput = {
    create?: XOR<Enumerable<logsNowCreateWithoutGuildInput>, Enumerable<logsNowUncheckedCreateWithoutGuildInput>>
    connectOrCreate?: Enumerable<logsNowCreateOrConnectWithoutGuildInput>
    upsert?: Enumerable<logsNowUpsertWithWhereUniqueWithoutGuildInput>
    createMany?: logsNowCreateManyGuildInputEnvelope
    set?: Enumerable<logsNowWhereUniqueInput>
    disconnect?: Enumerable<logsNowWhereUniqueInput>
    delete?: Enumerable<logsNowWhereUniqueInput>
    connect?: Enumerable<logsNowWhereUniqueInput>
    update?: Enumerable<logsNowUpdateWithWhereUniqueWithoutGuildInput>
    updateMany?: Enumerable<logsNowUpdateManyWithWhereWithoutGuildInput>
    deleteMany?: Enumerable<logsNowScalarWhereInput>
  }

  export type historicLogsUncheckedUpdateManyWithoutGuildNestedInput = {
    create?: XOR<Enumerable<historicLogsCreateWithoutGuildInput>, Enumerable<historicLogsUncheckedCreateWithoutGuildInput>>
    connectOrCreate?: Enumerable<historicLogsCreateOrConnectWithoutGuildInput>
    upsert?: Enumerable<historicLogsUpsertWithWhereUniqueWithoutGuildInput>
    createMany?: historicLogsCreateManyGuildInputEnvelope
    set?: Enumerable<historicLogsWhereUniqueInput>
    disconnect?: Enumerable<historicLogsWhereUniqueInput>
    delete?: Enumerable<historicLogsWhereUniqueInput>
    connect?: Enumerable<historicLogsWhereUniqueInput>
    update?: Enumerable<historicLogsUpdateWithWhereUniqueWithoutGuildInput>
    updateMany?: Enumerable<historicLogsUpdateManyWithWhereWithoutGuildInput>
    deleteMany?: Enumerable<historicLogsScalarWhereInput>
  }

  export type historicQuickLogsUncheckedUpdateManyWithoutGuildNestedInput = {
    create?: XOR<Enumerable<historicQuickLogsCreateWithoutGuildInput>, Enumerable<historicQuickLogsUncheckedCreateWithoutGuildInput>>
    connectOrCreate?: Enumerable<historicQuickLogsCreateOrConnectWithoutGuildInput>
    upsert?: Enumerable<historicQuickLogsUpsertWithWhereUniqueWithoutGuildInput>
    createMany?: historicQuickLogsCreateManyGuildInputEnvelope
    set?: Enumerable<historicQuickLogsWhereUniqueInput>
    disconnect?: Enumerable<historicQuickLogsWhereUniqueInput>
    delete?: Enumerable<historicQuickLogsWhereUniqueInput>
    connect?: Enumerable<historicQuickLogsWhereUniqueInput>
    update?: Enumerable<historicQuickLogsUpdateWithWhereUniqueWithoutGuildInput>
    updateMany?: Enumerable<historicQuickLogsUpdateManyWithWhereWithoutGuildInput>
    deleteMany?: Enumerable<historicQuickLogsScalarWhereInput>
  }

  export type UserActivityLogsTodayUncheckedUpdateManyWithoutGuildNestedInput = {
    create?: XOR<Enumerable<UserActivityLogsTodayCreateWithoutGuildInput>, Enumerable<UserActivityLogsTodayUncheckedCreateWithoutGuildInput>>
    connectOrCreate?: Enumerable<UserActivityLogsTodayCreateOrConnectWithoutGuildInput>
    upsert?: Enumerable<UserActivityLogsTodayUpsertWithWhereUniqueWithoutGuildInput>
    createMany?: UserActivityLogsTodayCreateManyGuildInputEnvelope
    set?: Enumerable<UserActivityLogsTodayWhereUniqueInput>
    disconnect?: Enumerable<UserActivityLogsTodayWhereUniqueInput>
    delete?: Enumerable<UserActivityLogsTodayWhereUniqueInput>
    connect?: Enumerable<UserActivityLogsTodayWhereUniqueInput>
    update?: Enumerable<UserActivityLogsTodayUpdateWithWhereUniqueWithoutGuildInput>
    updateMany?: Enumerable<UserActivityLogsTodayUpdateManyWithWhereWithoutGuildInput>
    deleteMany?: Enumerable<UserActivityLogsTodayScalarWhereInput>
  }

  export type GuildCreateNestedOneWithoutGuildPreferencesInput = {
    create?: XOR<GuildCreateWithoutGuildPreferencesInput, GuildUncheckedCreateWithoutGuildPreferencesInput>
    connectOrCreate?: GuildCreateOrConnectWithoutGuildPreferencesInput
    connect?: GuildWhereUniqueInput
  }

  export type GuildUpdateOneWithoutGuildPreferencesNestedInput = {
    create?: XOR<GuildCreateWithoutGuildPreferencesInput, GuildUncheckedCreateWithoutGuildPreferencesInput>
    connectOrCreate?: GuildCreateOrConnectWithoutGuildPreferencesInput
    upsert?: GuildUpsertWithoutGuildPreferencesInput
    disconnect?: boolean
    delete?: boolean
    connect?: GuildWhereUniqueInput
    update?: XOR<GuildUpdateWithoutGuildPreferencesInput, GuildUncheckedUpdateWithoutGuildPreferencesInput>
  }

  export type ActivityRewardsCreateNestedOneWithoutActivityInput = {
    create?: XOR<ActivityRewardsCreateWithoutActivityInput, ActivityRewardsUncheckedCreateWithoutActivityInput>
    connectOrCreate?: ActivityRewardsCreateOrConnectWithoutActivityInput
    connect?: ActivityRewardsWhereUniqueInput
  }

  export type UserActivityLogsTodayCreateNestedManyWithoutActivityInput = {
    create?: XOR<Enumerable<UserActivityLogsTodayCreateWithoutActivityInput>, Enumerable<UserActivityLogsTodayUncheckedCreateWithoutActivityInput>>
    connectOrCreate?: Enumerable<UserActivityLogsTodayCreateOrConnectWithoutActivityInput>
    createMany?: UserActivityLogsTodayCreateManyActivityInputEnvelope
    connect?: Enumerable<UserActivityLogsTodayWhereUniqueInput>
  }

  export type logsNowCreateNestedManyWithoutActivityInput = {
    create?: XOR<Enumerable<logsNowCreateWithoutActivityInput>, Enumerable<logsNowUncheckedCreateWithoutActivityInput>>
    connectOrCreate?: Enumerable<logsNowCreateOrConnectWithoutActivityInput>
    createMany?: logsNowCreateManyActivityInputEnvelope
    connect?: Enumerable<logsNowWhereUniqueInput>
  }

  export type historicLogsCreateNestedManyWithoutActivityInput = {
    create?: XOR<Enumerable<historicLogsCreateWithoutActivityInput>, Enumerable<historicLogsUncheckedCreateWithoutActivityInput>>
    connectOrCreate?: Enumerable<historicLogsCreateOrConnectWithoutActivityInput>
    createMany?: historicLogsCreateManyActivityInputEnvelope
    connect?: Enumerable<historicLogsWhereUniqueInput>
  }

  export type historicQuickLogsCreateNestedManyWithoutActivityInput = {
    create?: XOR<Enumerable<historicQuickLogsCreateWithoutActivityInput>, Enumerable<historicQuickLogsUncheckedCreateWithoutActivityInput>>
    connectOrCreate?: Enumerable<historicQuickLogsCreateOrConnectWithoutActivityInput>
    createMany?: historicQuickLogsCreateManyActivityInputEnvelope
    connect?: Enumerable<historicQuickLogsWhereUniqueInput>
  }

  export type logsTodayCreateNestedManyWithoutActivityInput = {
    create?: XOR<Enumerable<logsTodayCreateWithoutActivityInput>, Enumerable<logsTodayUncheckedCreateWithoutActivityInput>>
    connectOrCreate?: Enumerable<logsTodayCreateOrConnectWithoutActivityInput>
    createMany?: logsTodayCreateManyActivityInputEnvelope
    connect?: Enumerable<logsTodayWhereUniqueInput>
  }

  export type ActivityRewardsUncheckedCreateNestedOneWithoutActivityInput = {
    create?: XOR<ActivityRewardsCreateWithoutActivityInput, ActivityRewardsUncheckedCreateWithoutActivityInput>
    connectOrCreate?: ActivityRewardsCreateOrConnectWithoutActivityInput
    connect?: ActivityRewardsWhereUniqueInput
  }

  export type UserActivityLogsTodayUncheckedCreateNestedManyWithoutActivityInput = {
    create?: XOR<Enumerable<UserActivityLogsTodayCreateWithoutActivityInput>, Enumerable<UserActivityLogsTodayUncheckedCreateWithoutActivityInput>>
    connectOrCreate?: Enumerable<UserActivityLogsTodayCreateOrConnectWithoutActivityInput>
    createMany?: UserActivityLogsTodayCreateManyActivityInputEnvelope
    connect?: Enumerable<UserActivityLogsTodayWhereUniqueInput>
  }

  export type logsNowUncheckedCreateNestedManyWithoutActivityInput = {
    create?: XOR<Enumerable<logsNowCreateWithoutActivityInput>, Enumerable<logsNowUncheckedCreateWithoutActivityInput>>
    connectOrCreate?: Enumerable<logsNowCreateOrConnectWithoutActivityInput>
    createMany?: logsNowCreateManyActivityInputEnvelope
    connect?: Enumerable<logsNowWhereUniqueInput>
  }

  export type historicLogsUncheckedCreateNestedManyWithoutActivityInput = {
    create?: XOR<Enumerable<historicLogsCreateWithoutActivityInput>, Enumerable<historicLogsUncheckedCreateWithoutActivityInput>>
    connectOrCreate?: Enumerable<historicLogsCreateOrConnectWithoutActivityInput>
    createMany?: historicLogsCreateManyActivityInputEnvelope
    connect?: Enumerable<historicLogsWhereUniqueInput>
  }

  export type historicQuickLogsUncheckedCreateNestedManyWithoutActivityInput = {
    create?: XOR<Enumerable<historicQuickLogsCreateWithoutActivityInput>, Enumerable<historicQuickLogsUncheckedCreateWithoutActivityInput>>
    connectOrCreate?: Enumerable<historicQuickLogsCreateOrConnectWithoutActivityInput>
    createMany?: historicQuickLogsCreateManyActivityInputEnvelope
    connect?: Enumerable<historicQuickLogsWhereUniqueInput>
  }

  export type logsTodayUncheckedCreateNestedManyWithoutActivityInput = {
    create?: XOR<Enumerable<logsTodayCreateWithoutActivityInput>, Enumerable<logsTodayUncheckedCreateWithoutActivityInput>>
    connectOrCreate?: Enumerable<logsTodayCreateOrConnectWithoutActivityInput>
    createMany?: logsTodayCreateManyActivityInputEnvelope
    connect?: Enumerable<logsTodayWhereUniqueInput>
  }

  export type ActivityRewardsUpdateOneWithoutActivityNestedInput = {
    create?: XOR<ActivityRewardsCreateWithoutActivityInput, ActivityRewardsUncheckedCreateWithoutActivityInput>
    connectOrCreate?: ActivityRewardsCreateOrConnectWithoutActivityInput
    upsert?: ActivityRewardsUpsertWithoutActivityInput
    disconnect?: boolean
    delete?: boolean
    connect?: ActivityRewardsWhereUniqueInput
    update?: XOR<ActivityRewardsUpdateWithoutActivityInput, ActivityRewardsUncheckedUpdateWithoutActivityInput>
  }

  export type UserActivityLogsTodayUpdateManyWithoutActivityNestedInput = {
    create?: XOR<Enumerable<UserActivityLogsTodayCreateWithoutActivityInput>, Enumerable<UserActivityLogsTodayUncheckedCreateWithoutActivityInput>>
    connectOrCreate?: Enumerable<UserActivityLogsTodayCreateOrConnectWithoutActivityInput>
    upsert?: Enumerable<UserActivityLogsTodayUpsertWithWhereUniqueWithoutActivityInput>
    createMany?: UserActivityLogsTodayCreateManyActivityInputEnvelope
    set?: Enumerable<UserActivityLogsTodayWhereUniqueInput>
    disconnect?: Enumerable<UserActivityLogsTodayWhereUniqueInput>
    delete?: Enumerable<UserActivityLogsTodayWhereUniqueInput>
    connect?: Enumerable<UserActivityLogsTodayWhereUniqueInput>
    update?: Enumerable<UserActivityLogsTodayUpdateWithWhereUniqueWithoutActivityInput>
    updateMany?: Enumerable<UserActivityLogsTodayUpdateManyWithWhereWithoutActivityInput>
    deleteMany?: Enumerable<UserActivityLogsTodayScalarWhereInput>
  }

  export type logsNowUpdateManyWithoutActivityNestedInput = {
    create?: XOR<Enumerable<logsNowCreateWithoutActivityInput>, Enumerable<logsNowUncheckedCreateWithoutActivityInput>>
    connectOrCreate?: Enumerable<logsNowCreateOrConnectWithoutActivityInput>
    upsert?: Enumerable<logsNowUpsertWithWhereUniqueWithoutActivityInput>
    createMany?: logsNowCreateManyActivityInputEnvelope
    set?: Enumerable<logsNowWhereUniqueInput>
    disconnect?: Enumerable<logsNowWhereUniqueInput>
    delete?: Enumerable<logsNowWhereUniqueInput>
    connect?: Enumerable<logsNowWhereUniqueInput>
    update?: Enumerable<logsNowUpdateWithWhereUniqueWithoutActivityInput>
    updateMany?: Enumerable<logsNowUpdateManyWithWhereWithoutActivityInput>
    deleteMany?: Enumerable<logsNowScalarWhereInput>
  }

  export type historicLogsUpdateManyWithoutActivityNestedInput = {
    create?: XOR<Enumerable<historicLogsCreateWithoutActivityInput>, Enumerable<historicLogsUncheckedCreateWithoutActivityInput>>
    connectOrCreate?: Enumerable<historicLogsCreateOrConnectWithoutActivityInput>
    upsert?: Enumerable<historicLogsUpsertWithWhereUniqueWithoutActivityInput>
    createMany?: historicLogsCreateManyActivityInputEnvelope
    set?: Enumerable<historicLogsWhereUniqueInput>
    disconnect?: Enumerable<historicLogsWhereUniqueInput>
    delete?: Enumerable<historicLogsWhereUniqueInput>
    connect?: Enumerable<historicLogsWhereUniqueInput>
    update?: Enumerable<historicLogsUpdateWithWhereUniqueWithoutActivityInput>
    updateMany?: Enumerable<historicLogsUpdateManyWithWhereWithoutActivityInput>
    deleteMany?: Enumerable<historicLogsScalarWhereInput>
  }

  export type historicQuickLogsUpdateManyWithoutActivityNestedInput = {
    create?: XOR<Enumerable<historicQuickLogsCreateWithoutActivityInput>, Enumerable<historicQuickLogsUncheckedCreateWithoutActivityInput>>
    connectOrCreate?: Enumerable<historicQuickLogsCreateOrConnectWithoutActivityInput>
    upsert?: Enumerable<historicQuickLogsUpsertWithWhereUniqueWithoutActivityInput>
    createMany?: historicQuickLogsCreateManyActivityInputEnvelope
    set?: Enumerable<historicQuickLogsWhereUniqueInput>
    disconnect?: Enumerable<historicQuickLogsWhereUniqueInput>
    delete?: Enumerable<historicQuickLogsWhereUniqueInput>
    connect?: Enumerable<historicQuickLogsWhereUniqueInput>
    update?: Enumerable<historicQuickLogsUpdateWithWhereUniqueWithoutActivityInput>
    updateMany?: Enumerable<historicQuickLogsUpdateManyWithWhereWithoutActivityInput>
    deleteMany?: Enumerable<historicQuickLogsScalarWhereInput>
  }

  export type logsTodayUpdateManyWithoutActivityNestedInput = {
    create?: XOR<Enumerable<logsTodayCreateWithoutActivityInput>, Enumerable<logsTodayUncheckedCreateWithoutActivityInput>>
    connectOrCreate?: Enumerable<logsTodayCreateOrConnectWithoutActivityInput>
    upsert?: Enumerable<logsTodayUpsertWithWhereUniqueWithoutActivityInput>
    createMany?: logsTodayCreateManyActivityInputEnvelope
    set?: Enumerable<logsTodayWhereUniqueInput>
    disconnect?: Enumerable<logsTodayWhereUniqueInput>
    delete?: Enumerable<logsTodayWhereUniqueInput>
    connect?: Enumerable<logsTodayWhereUniqueInput>
    update?: Enumerable<logsTodayUpdateWithWhereUniqueWithoutActivityInput>
    updateMany?: Enumerable<logsTodayUpdateManyWithWhereWithoutActivityInput>
    deleteMany?: Enumerable<logsTodayScalarWhereInput>
  }

  export type ActivityRewardsUncheckedUpdateOneWithoutActivityNestedInput = {
    create?: XOR<ActivityRewardsCreateWithoutActivityInput, ActivityRewardsUncheckedCreateWithoutActivityInput>
    connectOrCreate?: ActivityRewardsCreateOrConnectWithoutActivityInput
    upsert?: ActivityRewardsUpsertWithoutActivityInput
    disconnect?: boolean
    delete?: boolean
    connect?: ActivityRewardsWhereUniqueInput
    update?: XOR<ActivityRewardsUpdateWithoutActivityInput, ActivityRewardsUncheckedUpdateWithoutActivityInput>
  }

  export type UserActivityLogsTodayUncheckedUpdateManyWithoutActivityNestedInput = {
    create?: XOR<Enumerable<UserActivityLogsTodayCreateWithoutActivityInput>, Enumerable<UserActivityLogsTodayUncheckedCreateWithoutActivityInput>>
    connectOrCreate?: Enumerable<UserActivityLogsTodayCreateOrConnectWithoutActivityInput>
    upsert?: Enumerable<UserActivityLogsTodayUpsertWithWhereUniqueWithoutActivityInput>
    createMany?: UserActivityLogsTodayCreateManyActivityInputEnvelope
    set?: Enumerable<UserActivityLogsTodayWhereUniqueInput>
    disconnect?: Enumerable<UserActivityLogsTodayWhereUniqueInput>
    delete?: Enumerable<UserActivityLogsTodayWhereUniqueInput>
    connect?: Enumerable<UserActivityLogsTodayWhereUniqueInput>
    update?: Enumerable<UserActivityLogsTodayUpdateWithWhereUniqueWithoutActivityInput>
    updateMany?: Enumerable<UserActivityLogsTodayUpdateManyWithWhereWithoutActivityInput>
    deleteMany?: Enumerable<UserActivityLogsTodayScalarWhereInput>
  }

  export type logsNowUncheckedUpdateManyWithoutActivityNestedInput = {
    create?: XOR<Enumerable<logsNowCreateWithoutActivityInput>, Enumerable<logsNowUncheckedCreateWithoutActivityInput>>
    connectOrCreate?: Enumerable<logsNowCreateOrConnectWithoutActivityInput>
    upsert?: Enumerable<logsNowUpsertWithWhereUniqueWithoutActivityInput>
    createMany?: logsNowCreateManyActivityInputEnvelope
    set?: Enumerable<logsNowWhereUniqueInput>
    disconnect?: Enumerable<logsNowWhereUniqueInput>
    delete?: Enumerable<logsNowWhereUniqueInput>
    connect?: Enumerable<logsNowWhereUniqueInput>
    update?: Enumerable<logsNowUpdateWithWhereUniqueWithoutActivityInput>
    updateMany?: Enumerable<logsNowUpdateManyWithWhereWithoutActivityInput>
    deleteMany?: Enumerable<logsNowScalarWhereInput>
  }

  export type historicLogsUncheckedUpdateManyWithoutActivityNestedInput = {
    create?: XOR<Enumerable<historicLogsCreateWithoutActivityInput>, Enumerable<historicLogsUncheckedCreateWithoutActivityInput>>
    connectOrCreate?: Enumerable<historicLogsCreateOrConnectWithoutActivityInput>
    upsert?: Enumerable<historicLogsUpsertWithWhereUniqueWithoutActivityInput>
    createMany?: historicLogsCreateManyActivityInputEnvelope
    set?: Enumerable<historicLogsWhereUniqueInput>
    disconnect?: Enumerable<historicLogsWhereUniqueInput>
    delete?: Enumerable<historicLogsWhereUniqueInput>
    connect?: Enumerable<historicLogsWhereUniqueInput>
    update?: Enumerable<historicLogsUpdateWithWhereUniqueWithoutActivityInput>
    updateMany?: Enumerable<historicLogsUpdateManyWithWhereWithoutActivityInput>
    deleteMany?: Enumerable<historicLogsScalarWhereInput>
  }

  export type historicQuickLogsUncheckedUpdateManyWithoutActivityNestedInput = {
    create?: XOR<Enumerable<historicQuickLogsCreateWithoutActivityInput>, Enumerable<historicQuickLogsUncheckedCreateWithoutActivityInput>>
    connectOrCreate?: Enumerable<historicQuickLogsCreateOrConnectWithoutActivityInput>
    upsert?: Enumerable<historicQuickLogsUpsertWithWhereUniqueWithoutActivityInput>
    createMany?: historicQuickLogsCreateManyActivityInputEnvelope
    set?: Enumerable<historicQuickLogsWhereUniqueInput>
    disconnect?: Enumerable<historicQuickLogsWhereUniqueInput>
    delete?: Enumerable<historicQuickLogsWhereUniqueInput>
    connect?: Enumerable<historicQuickLogsWhereUniqueInput>
    update?: Enumerable<historicQuickLogsUpdateWithWhereUniqueWithoutActivityInput>
    updateMany?: Enumerable<historicQuickLogsUpdateManyWithWhereWithoutActivityInput>
    deleteMany?: Enumerable<historicQuickLogsScalarWhereInput>
  }

  export type logsTodayUncheckedUpdateManyWithoutActivityNestedInput = {
    create?: XOR<Enumerable<logsTodayCreateWithoutActivityInput>, Enumerable<logsTodayUncheckedCreateWithoutActivityInput>>
    connectOrCreate?: Enumerable<logsTodayCreateOrConnectWithoutActivityInput>
    upsert?: Enumerable<logsTodayUpsertWithWhereUniqueWithoutActivityInput>
    createMany?: logsTodayCreateManyActivityInputEnvelope
    set?: Enumerable<logsTodayWhereUniqueInput>
    disconnect?: Enumerable<logsTodayWhereUniqueInput>
    delete?: Enumerable<logsTodayWhereUniqueInput>
    connect?: Enumerable<logsTodayWhereUniqueInput>
    update?: Enumerable<logsTodayUpdateWithWhereUniqueWithoutActivityInput>
    updateMany?: Enumerable<logsTodayUpdateManyWithWhereWithoutActivityInput>
    deleteMany?: Enumerable<logsTodayScalarWhereInput>
  }

  export type ActivityCreateNestedOneWithoutRewardsInput = {
    create?: XOR<ActivityCreateWithoutRewardsInput, ActivityUncheckedCreateWithoutRewardsInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutRewardsInput
    connect?: ActivityWhereUniqueInput
  }

  export type ActivityUpdateOneRequiredWithoutRewardsNestedInput = {
    create?: XOR<ActivityCreateWithoutRewardsInput, ActivityUncheckedCreateWithoutRewardsInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutRewardsInput
    upsert?: ActivityUpsertWithoutRewardsInput
    connect?: ActivityWhereUniqueInput
    update?: XOR<ActivityUpdateWithoutRewardsInput, ActivityUncheckedUpdateWithoutRewardsInput>
  }

  export type UserCreateNestedOneWithoutLogsNowInput = {
    create?: XOR<UserCreateWithoutLogsNowInput, UserUncheckedCreateWithoutLogsNowInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogsNowInput
    connect?: UserWhereUniqueInput
  }

  export type ActivityCreateNestedOneWithoutLogsNowInput = {
    create?: XOR<ActivityCreateWithoutLogsNowInput, ActivityUncheckedCreateWithoutLogsNowInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutLogsNowInput
    connect?: ActivityWhereUniqueInput
  }

  export type GuildCreateNestedOneWithoutLogsNowInput = {
    create?: XOR<GuildCreateWithoutLogsNowInput, GuildUncheckedCreateWithoutLogsNowInput>
    connectOrCreate?: GuildCreateOrConnectWithoutLogsNowInput
    connect?: GuildWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLogsNowNestedInput = {
    create?: XOR<UserCreateWithoutLogsNowInput, UserUncheckedCreateWithoutLogsNowInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogsNowInput
    upsert?: UserUpsertWithoutLogsNowInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutLogsNowInput, UserUncheckedUpdateWithoutLogsNowInput>
  }

  export type ActivityUpdateOneRequiredWithoutLogsNowNestedInput = {
    create?: XOR<ActivityCreateWithoutLogsNowInput, ActivityUncheckedCreateWithoutLogsNowInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutLogsNowInput
    upsert?: ActivityUpsertWithoutLogsNowInput
    connect?: ActivityWhereUniqueInput
    update?: XOR<ActivityUpdateWithoutLogsNowInput, ActivityUncheckedUpdateWithoutLogsNowInput>
  }

  export type GuildUpdateOneRequiredWithoutLogsNowNestedInput = {
    create?: XOR<GuildCreateWithoutLogsNowInput, GuildUncheckedCreateWithoutLogsNowInput>
    connectOrCreate?: GuildCreateOrConnectWithoutLogsNowInput
    upsert?: GuildUpsertWithoutLogsNowInput
    connect?: GuildWhereUniqueInput
    update?: XOR<GuildUpdateWithoutLogsNowInput, GuildUncheckedUpdateWithoutLogsNowInput>
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EnumActivityTypeFieldUpdateOperationsInput = {
    set?: ActivityType
  }

  export type UserCreateNestedOneWithoutHistoricLogsInput = {
    create?: XOR<UserCreateWithoutHistoricLogsInput, UserUncheckedCreateWithoutHistoricLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutHistoricLogsInput
    connect?: UserWhereUniqueInput
  }

  export type ActivityCreateNestedOneWithoutHistoricLogsInput = {
    create?: XOR<ActivityCreateWithoutHistoricLogsInput, ActivityUncheckedCreateWithoutHistoricLogsInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutHistoricLogsInput
    connect?: ActivityWhereUniqueInput
  }

  export type GuildCreateNestedOneWithoutHistoricLogsInput = {
    create?: XOR<GuildCreateWithoutHistoricLogsInput, GuildUncheckedCreateWithoutHistoricLogsInput>
    connectOrCreate?: GuildCreateOrConnectWithoutHistoricLogsInput
    connect?: GuildWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutHistoricLogsNestedInput = {
    create?: XOR<UserCreateWithoutHistoricLogsInput, UserUncheckedCreateWithoutHistoricLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutHistoricLogsInput
    upsert?: UserUpsertWithoutHistoricLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutHistoricLogsInput, UserUncheckedUpdateWithoutHistoricLogsInput>
  }

  export type ActivityUpdateOneRequiredWithoutHistoricLogsNestedInput = {
    create?: XOR<ActivityCreateWithoutHistoricLogsInput, ActivityUncheckedCreateWithoutHistoricLogsInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutHistoricLogsInput
    upsert?: ActivityUpsertWithoutHistoricLogsInput
    connect?: ActivityWhereUniqueInput
    update?: XOR<ActivityUpdateWithoutHistoricLogsInput, ActivityUncheckedUpdateWithoutHistoricLogsInput>
  }

  export type GuildUpdateOneRequiredWithoutHistoricLogsNestedInput = {
    create?: XOR<GuildCreateWithoutHistoricLogsInput, GuildUncheckedCreateWithoutHistoricLogsInput>
    connectOrCreate?: GuildCreateOrConnectWithoutHistoricLogsInput
    upsert?: GuildUpsertWithoutHistoricLogsInput
    connect?: GuildWhereUniqueInput
    update?: XOR<GuildUpdateWithoutHistoricLogsInput, GuildUncheckedUpdateWithoutHistoricLogsInput>
  }

  export type EnumTimeframeFieldUpdateOperationsInput = {
    set?: Timeframe
  }

  export type UserCreateNestedOneWithoutHistoricQuickLogsInput = {
    create?: XOR<UserCreateWithoutHistoricQuickLogsInput, UserUncheckedCreateWithoutHistoricQuickLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutHistoricQuickLogsInput
    connect?: UserWhereUniqueInput
  }

  export type ActivityCreateNestedOneWithoutHistoricQuickLogsInput = {
    create?: XOR<ActivityCreateWithoutHistoricQuickLogsInput, ActivityUncheckedCreateWithoutHistoricQuickLogsInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutHistoricQuickLogsInput
    connect?: ActivityWhereUniqueInput
  }

  export type GuildCreateNestedOneWithoutHistoricQuickLogsInput = {
    create?: XOR<GuildCreateWithoutHistoricQuickLogsInput, GuildUncheckedCreateWithoutHistoricQuickLogsInput>
    connectOrCreate?: GuildCreateOrConnectWithoutHistoricQuickLogsInput
    connect?: GuildWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutHistoricQuickLogsNestedInput = {
    create?: XOR<UserCreateWithoutHistoricQuickLogsInput, UserUncheckedCreateWithoutHistoricQuickLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutHistoricQuickLogsInput
    upsert?: UserUpsertWithoutHistoricQuickLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutHistoricQuickLogsInput, UserUncheckedUpdateWithoutHistoricQuickLogsInput>
  }

  export type ActivityUpdateOneRequiredWithoutHistoricQuickLogsNestedInput = {
    create?: XOR<ActivityCreateWithoutHistoricQuickLogsInput, ActivityUncheckedCreateWithoutHistoricQuickLogsInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutHistoricQuickLogsInput
    upsert?: ActivityUpsertWithoutHistoricQuickLogsInput
    connect?: ActivityWhereUniqueInput
    update?: XOR<ActivityUpdateWithoutHistoricQuickLogsInput, ActivityUncheckedUpdateWithoutHistoricQuickLogsInput>
  }

  export type GuildUpdateOneRequiredWithoutHistoricQuickLogsNestedInput = {
    create?: XOR<GuildCreateWithoutHistoricQuickLogsInput, GuildUncheckedCreateWithoutHistoricQuickLogsInput>
    connectOrCreate?: GuildCreateOrConnectWithoutHistoricQuickLogsInput
    upsert?: GuildUpsertWithoutHistoricQuickLogsInput
    connect?: GuildWhereUniqueInput
    update?: XOR<GuildUpdateWithoutHistoricQuickLogsInput, GuildUncheckedUpdateWithoutHistoricQuickLogsInput>
  }

  export type UserCreateNestedOneWithoutLogsTodayInput = {
    create?: XOR<UserCreateWithoutLogsTodayInput, UserUncheckedCreateWithoutLogsTodayInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogsTodayInput
    connect?: UserWhereUniqueInput
  }

  export type ActivityCreateNestedOneWithoutLogsTodayInput = {
    create?: XOR<ActivityCreateWithoutLogsTodayInput, ActivityUncheckedCreateWithoutLogsTodayInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutLogsTodayInput
    connect?: ActivityWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLogsTodayNestedInput = {
    create?: XOR<UserCreateWithoutLogsTodayInput, UserUncheckedCreateWithoutLogsTodayInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogsTodayInput
    upsert?: UserUpsertWithoutLogsTodayInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutLogsTodayInput, UserUncheckedUpdateWithoutLogsTodayInput>
  }

  export type ActivityUpdateOneRequiredWithoutLogsTodayNestedInput = {
    create?: XOR<ActivityCreateWithoutLogsTodayInput, ActivityUncheckedCreateWithoutLogsTodayInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutLogsTodayInput
    upsert?: ActivityUpsertWithoutLogsTodayInput
    connect?: ActivityWhereUniqueInput
    update?: XOR<ActivityUpdateWithoutLogsTodayInput, ActivityUncheckedUpdateWithoutLogsTodayInput>
  }

  export type UserCreateNestedOneWithoutUserActivityLogsTodayInput = {
    create?: XOR<UserCreateWithoutUserActivityLogsTodayInput, UserUncheckedCreateWithoutUserActivityLogsTodayInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserActivityLogsTodayInput
    connect?: UserWhereUniqueInput
  }

  export type GuildCreateNestedOneWithoutUserActivityLogsTodayInput = {
    create?: XOR<GuildCreateWithoutUserActivityLogsTodayInput, GuildUncheckedCreateWithoutUserActivityLogsTodayInput>
    connectOrCreate?: GuildCreateOrConnectWithoutUserActivityLogsTodayInput
    connect?: GuildWhereUniqueInput
  }

  export type ActivityCreateNestedOneWithoutUserActivityLogsTodayInput = {
    create?: XOR<ActivityCreateWithoutUserActivityLogsTodayInput, ActivityUncheckedCreateWithoutUserActivityLogsTodayInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutUserActivityLogsTodayInput
    connect?: ActivityWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserActivityLogsTodayNestedInput = {
    create?: XOR<UserCreateWithoutUserActivityLogsTodayInput, UserUncheckedCreateWithoutUserActivityLogsTodayInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserActivityLogsTodayInput
    upsert?: UserUpsertWithoutUserActivityLogsTodayInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutUserActivityLogsTodayInput, UserUncheckedUpdateWithoutUserActivityLogsTodayInput>
  }

  export type GuildUpdateOneRequiredWithoutUserActivityLogsTodayNestedInput = {
    create?: XOR<GuildCreateWithoutUserActivityLogsTodayInput, GuildUncheckedCreateWithoutUserActivityLogsTodayInput>
    connectOrCreate?: GuildCreateOrConnectWithoutUserActivityLogsTodayInput
    upsert?: GuildUpsertWithoutUserActivityLogsTodayInput
    connect?: GuildWhereUniqueInput
    update?: XOR<GuildUpdateWithoutUserActivityLogsTodayInput, GuildUncheckedUpdateWithoutUserActivityLogsTodayInput>
  }

  export type ActivityUpdateOneRequiredWithoutUserActivityLogsTodayNestedInput = {
    create?: XOR<ActivityCreateWithoutUserActivityLogsTodayInput, ActivityUncheckedCreateWithoutUserActivityLogsTodayInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutUserActivityLogsTodayInput
    upsert?: ActivityUpsertWithoutUserActivityLogsTodayInput
    connect?: ActivityWhereUniqueInput
    update?: XOR<ActivityUpdateWithoutUserActivityLogsTodayInput, ActivityUncheckedUpdateWithoutUserActivityLogsTodayInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedEnumroleFilter = {
    equals?: role
    in?: Enumerable<role>
    notIn?: Enumerable<role>
    not?: NestedEnumroleFilter | role
  }

  export type NestedEnumlevelRoleFilter = {
    equals?: levelRole
    in?: Enumerable<levelRole>
    notIn?: Enumerable<levelRole>
    not?: NestedEnumlevelRoleFilter | levelRole
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedEnumroleWithAggregatesFilter = {
    equals?: role
    in?: Enumerable<role>
    notIn?: Enumerable<role>
    not?: NestedEnumroleWithAggregatesFilter | role
    _count?: NestedIntFilter
    _min?: NestedEnumroleFilter
    _max?: NestedEnumroleFilter
  }

  export type NestedEnumlevelRoleWithAggregatesFilter = {
    equals?: levelRole
    in?: Enumerable<levelRole>
    notIn?: Enumerable<levelRole>
    not?: NestedEnumlevelRoleWithAggregatesFilter | levelRole
    _count?: NestedIntFilter
    _min?: NestedEnumlevelRoleFilter
    _max?: NestedEnumlevelRoleFilter
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedEnumActivityTypeFilter = {
    equals?: ActivityType
    in?: Enumerable<ActivityType>
    notIn?: Enumerable<ActivityType>
    not?: NestedEnumActivityTypeFilter | ActivityType
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedEnumActivityTypeWithAggregatesFilter = {
    equals?: ActivityType
    in?: Enumerable<ActivityType>
    notIn?: Enumerable<ActivityType>
    not?: NestedEnumActivityTypeWithAggregatesFilter | ActivityType
    _count?: NestedIntFilter
    _min?: NestedEnumActivityTypeFilter
    _max?: NestedEnumActivityTypeFilter
  }

  export type NestedEnumTimeframeFilter = {
    equals?: Timeframe
    in?: Enumerable<Timeframe>
    notIn?: Enumerable<Timeframe>
    not?: NestedEnumTimeframeFilter | Timeframe
  }

  export type NestedEnumTimeframeWithAggregatesFilter = {
    equals?: Timeframe
    in?: Enumerable<Timeframe>
    notIn?: Enumerable<Timeframe>
    not?: NestedEnumTimeframeWithAggregatesFilter | Timeframe
    _count?: NestedIntFilter
    _min?: NestedEnumTimeframeFilter
    _max?: NestedEnumTimeframeFilter
  }

  export type GuildCreateWithoutUsersInput = {
    id: string
    name: string
    GuildPreferences?: GuildPreferencesCreateNestedOneWithoutGuildInput
    preferenceID: number
    logsNow?: logsNowCreateNestedManyWithoutGuildInput
    historicLogs?: historicLogsCreateNestedManyWithoutGuildInput
    historicQuickLogs?: historicQuickLogsCreateNestedManyWithoutGuildInput
    UserActivityLogsToday?: UserActivityLogsTodayCreateNestedManyWithoutGuildInput
  }

  export type GuildUncheckedCreateWithoutUsersInput = {
    id: string
    name: string
    GuildPreferences?: GuildPreferencesUncheckedCreateNestedOneWithoutGuildInput
    preferenceID: number
    logsNow?: logsNowUncheckedCreateNestedManyWithoutGuildInput
    historicLogs?: historicLogsUncheckedCreateNestedManyWithoutGuildInput
    historicQuickLogs?: historicQuickLogsUncheckedCreateNestedManyWithoutGuildInput
    UserActivityLogsToday?: UserActivityLogsTodayUncheckedCreateNestedManyWithoutGuildInput
  }

  export type GuildCreateOrConnectWithoutUsersInput = {
    where: GuildWhereUniqueInput
    create: XOR<GuildCreateWithoutUsersInput, GuildUncheckedCreateWithoutUsersInput>
  }

  export type logsNowCreateWithoutUserInput = {
    activity: ActivityCreateNestedOneWithoutLogsNowInput
    guild: GuildCreateNestedOneWithoutLogsNowInput
    timestamp?: Date | string
    type: ActivityType
  }

  export type logsNowUncheckedCreateWithoutUserInput = {
    id?: number
    timestamp?: Date | string
    type: ActivityType
    activityId: number
    guildId: string
  }

  export type logsNowCreateOrConnectWithoutUserInput = {
    where: logsNowWhereUniqueInput
    create: XOR<logsNowCreateWithoutUserInput, logsNowUncheckedCreateWithoutUserInput>
  }

  export type logsNowCreateManyUserInputEnvelope = {
    data: Enumerable<logsNowCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type historicLogsCreateWithoutUserInput = {
    activity: ActivityCreateNestedOneWithoutHistoricLogsInput
    guild: GuildCreateNestedOneWithoutHistoricLogsInput
    date: Date | string
    type: ActivityType
    timeframe: Timeframe
  }

  export type historicLogsUncheckedCreateWithoutUserInput = {
    id?: number
    date: Date | string
    type: ActivityType
    timeframe: Timeframe
    activityId: number
    guildId: string
  }

  export type historicLogsCreateOrConnectWithoutUserInput = {
    where: historicLogsWhereUniqueInput
    create: XOR<historicLogsCreateWithoutUserInput, historicLogsUncheckedCreateWithoutUserInput>
  }

  export type historicLogsCreateManyUserInputEnvelope = {
    data: Enumerable<historicLogsCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type historicQuickLogsCreateWithoutUserInput = {
    activity: ActivityCreateNestedOneWithoutHistoricQuickLogsInput
    guild: GuildCreateNestedOneWithoutHistoricQuickLogsInput
    date: Date | string
    type: ActivityType
    start: Date | string
    end: Date | string
  }

  export type historicQuickLogsUncheckedCreateWithoutUserInput = {
    id?: number
    date: Date | string
    type: ActivityType
    start: Date | string
    end: Date | string
    activityId: number
    guildId: string
  }

  export type historicQuickLogsCreateOrConnectWithoutUserInput = {
    where: historicQuickLogsWhereUniqueInput
    create: XOR<historicQuickLogsCreateWithoutUserInput, historicQuickLogsUncheckedCreateWithoutUserInput>
  }

  export type historicQuickLogsCreateManyUserInputEnvelope = {
    data: Enumerable<historicQuickLogsCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type logsTodayCreateWithoutUserInput = {
    activity: ActivityCreateNestedOneWithoutLogsTodayInput
    date: Date | string
    Type: string
    Timeframe: Timeframe
    minutes?: number
  }

  export type logsTodayUncheckedCreateWithoutUserInput = {
    id?: number
    date: Date | string
    Type: string
    Timeframe: Timeframe
    minutes?: number
    activityId: number
  }

  export type logsTodayCreateOrConnectWithoutUserInput = {
    where: logsTodayWhereUniqueInput
    create: XOR<logsTodayCreateWithoutUserInput, logsTodayUncheckedCreateWithoutUserInput>
  }

  export type logsTodayCreateManyUserInputEnvelope = {
    data: Enumerable<logsTodayCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type UserActivityLogsTodayCreateWithoutUserInput = {
    type: ActivityType
    guild: GuildCreateNestedOneWithoutUserActivityLogsTodayInput
    activity: ActivityCreateNestedOneWithoutUserActivityLogsTodayInput
    startedAt: Date | string
    endedAt: Date | string
  }

  export type UserActivityLogsTodayUncheckedCreateWithoutUserInput = {
    id?: number
    type: ActivityType
    startedAt: Date | string
    endedAt: Date | string
    guildId: string
    activityId: number
  }

  export type UserActivityLogsTodayCreateOrConnectWithoutUserInput = {
    where: UserActivityLogsTodayWhereUniqueInput
    create: XOR<UserActivityLogsTodayCreateWithoutUserInput, UserActivityLogsTodayUncheckedCreateWithoutUserInput>
  }

  export type UserActivityLogsTodayCreateManyUserInputEnvelope = {
    data: Enumerable<UserActivityLogsTodayCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type GuildUpsertWithWhereUniqueWithoutUsersInput = {
    where: GuildWhereUniqueInput
    update: XOR<GuildUpdateWithoutUsersInput, GuildUncheckedUpdateWithoutUsersInput>
    create: XOR<GuildCreateWithoutUsersInput, GuildUncheckedCreateWithoutUsersInput>
  }

  export type GuildUpdateWithWhereUniqueWithoutUsersInput = {
    where: GuildWhereUniqueInput
    data: XOR<GuildUpdateWithoutUsersInput, GuildUncheckedUpdateWithoutUsersInput>
  }

  export type GuildUpdateManyWithWhereWithoutUsersInput = {
    where: GuildScalarWhereInput
    data: XOR<GuildUpdateManyMutationInput, GuildUncheckedUpdateManyWithoutGuildsInput>
  }

  export type GuildScalarWhereInput = {
    AND?: Enumerable<GuildScalarWhereInput>
    OR?: Enumerable<GuildScalarWhereInput>
    NOT?: Enumerable<GuildScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    preferenceID?: IntFilter | number
  }

  export type logsNowUpsertWithWhereUniqueWithoutUserInput = {
    where: logsNowWhereUniqueInput
    update: XOR<logsNowUpdateWithoutUserInput, logsNowUncheckedUpdateWithoutUserInput>
    create: XOR<logsNowCreateWithoutUserInput, logsNowUncheckedCreateWithoutUserInput>
  }

  export type logsNowUpdateWithWhereUniqueWithoutUserInput = {
    where: logsNowWhereUniqueInput
    data: XOR<logsNowUpdateWithoutUserInput, logsNowUncheckedUpdateWithoutUserInput>
  }

  export type logsNowUpdateManyWithWhereWithoutUserInput = {
    where: logsNowScalarWhereInput
    data: XOR<logsNowUpdateManyMutationInput, logsNowUncheckedUpdateManyWithoutLogsNowInput>
  }

  export type logsNowScalarWhereInput = {
    AND?: Enumerable<logsNowScalarWhereInput>
    OR?: Enumerable<logsNowScalarWhereInput>
    NOT?: Enumerable<logsNowScalarWhereInput>
    id?: IntFilter | number
    timestamp?: DateTimeFilter | Date | string
    type?: EnumActivityTypeFilter | ActivityType
    userId?: IntFilter | number
    activityId?: IntFilter | number
    guildId?: StringFilter | string
  }

  export type historicLogsUpsertWithWhereUniqueWithoutUserInput = {
    where: historicLogsWhereUniqueInput
    update: XOR<historicLogsUpdateWithoutUserInput, historicLogsUncheckedUpdateWithoutUserInput>
    create: XOR<historicLogsCreateWithoutUserInput, historicLogsUncheckedCreateWithoutUserInput>
  }

  export type historicLogsUpdateWithWhereUniqueWithoutUserInput = {
    where: historicLogsWhereUniqueInput
    data: XOR<historicLogsUpdateWithoutUserInput, historicLogsUncheckedUpdateWithoutUserInput>
  }

  export type historicLogsUpdateManyWithWhereWithoutUserInput = {
    where: historicLogsScalarWhereInput
    data: XOR<historicLogsUpdateManyMutationInput, historicLogsUncheckedUpdateManyWithoutHistoricLogsInput>
  }

  export type historicLogsScalarWhereInput = {
    AND?: Enumerable<historicLogsScalarWhereInput>
    OR?: Enumerable<historicLogsScalarWhereInput>
    NOT?: Enumerable<historicLogsScalarWhereInput>
    id?: IntFilter | number
    date?: DateTimeFilter | Date | string
    type?: EnumActivityTypeFilter | ActivityType
    timeframe?: EnumTimeframeFilter | Timeframe
    userId?: IntFilter | number
    activityId?: IntFilter | number
    guildId?: StringFilter | string
  }

  export type historicQuickLogsUpsertWithWhereUniqueWithoutUserInput = {
    where: historicQuickLogsWhereUniqueInput
    update: XOR<historicQuickLogsUpdateWithoutUserInput, historicQuickLogsUncheckedUpdateWithoutUserInput>
    create: XOR<historicQuickLogsCreateWithoutUserInput, historicQuickLogsUncheckedCreateWithoutUserInput>
  }

  export type historicQuickLogsUpdateWithWhereUniqueWithoutUserInput = {
    where: historicQuickLogsWhereUniqueInput
    data: XOR<historicQuickLogsUpdateWithoutUserInput, historicQuickLogsUncheckedUpdateWithoutUserInput>
  }

  export type historicQuickLogsUpdateManyWithWhereWithoutUserInput = {
    where: historicQuickLogsScalarWhereInput
    data: XOR<historicQuickLogsUpdateManyMutationInput, historicQuickLogsUncheckedUpdateManyWithoutHistoricQuickLogsInput>
  }

  export type historicQuickLogsScalarWhereInput = {
    AND?: Enumerable<historicQuickLogsScalarWhereInput>
    OR?: Enumerable<historicQuickLogsScalarWhereInput>
    NOT?: Enumerable<historicQuickLogsScalarWhereInput>
    id?: IntFilter | number
    date?: DateTimeFilter | Date | string
    type?: EnumActivityTypeFilter | ActivityType
    start?: DateTimeFilter | Date | string
    end?: DateTimeFilter | Date | string
    userId?: IntFilter | number
    activityId?: IntFilter | number
    guildId?: StringFilter | string
  }

  export type logsTodayUpsertWithWhereUniqueWithoutUserInput = {
    where: logsTodayWhereUniqueInput
    update: XOR<logsTodayUpdateWithoutUserInput, logsTodayUncheckedUpdateWithoutUserInput>
    create: XOR<logsTodayCreateWithoutUserInput, logsTodayUncheckedCreateWithoutUserInput>
  }

  export type logsTodayUpdateWithWhereUniqueWithoutUserInput = {
    where: logsTodayWhereUniqueInput
    data: XOR<logsTodayUpdateWithoutUserInput, logsTodayUncheckedUpdateWithoutUserInput>
  }

  export type logsTodayUpdateManyWithWhereWithoutUserInput = {
    where: logsTodayScalarWhereInput
    data: XOR<logsTodayUpdateManyMutationInput, logsTodayUncheckedUpdateManyWithoutLogsTodayInput>
  }

  export type logsTodayScalarWhereInput = {
    AND?: Enumerable<logsTodayScalarWhereInput>
    OR?: Enumerable<logsTodayScalarWhereInput>
    NOT?: Enumerable<logsTodayScalarWhereInput>
    id?: IntFilter | number
    date?: DateTimeFilter | Date | string
    Type?: StringFilter | string
    Timeframe?: EnumTimeframeFilter | Timeframe
    minutes?: IntFilter | number
    userId?: IntFilter | number
    activityId?: IntFilter | number
  }

  export type UserActivityLogsTodayUpsertWithWhereUniqueWithoutUserInput = {
    where: UserActivityLogsTodayWhereUniqueInput
    update: XOR<UserActivityLogsTodayUpdateWithoutUserInput, UserActivityLogsTodayUncheckedUpdateWithoutUserInput>
    create: XOR<UserActivityLogsTodayCreateWithoutUserInput, UserActivityLogsTodayUncheckedCreateWithoutUserInput>
  }

  export type UserActivityLogsTodayUpdateWithWhereUniqueWithoutUserInput = {
    where: UserActivityLogsTodayWhereUniqueInput
    data: XOR<UserActivityLogsTodayUpdateWithoutUserInput, UserActivityLogsTodayUncheckedUpdateWithoutUserInput>
  }

  export type UserActivityLogsTodayUpdateManyWithWhereWithoutUserInput = {
    where: UserActivityLogsTodayScalarWhereInput
    data: XOR<UserActivityLogsTodayUpdateManyMutationInput, UserActivityLogsTodayUncheckedUpdateManyWithoutUserActivityLogsTodayInput>
  }

  export type UserActivityLogsTodayScalarWhereInput = {
    AND?: Enumerable<UserActivityLogsTodayScalarWhereInput>
    OR?: Enumerable<UserActivityLogsTodayScalarWhereInput>
    NOT?: Enumerable<UserActivityLogsTodayScalarWhereInput>
    id?: IntFilter | number
    type?: EnumActivityTypeFilter | ActivityType
    startedAt?: DateTimeFilter | Date | string
    endedAt?: DateTimeFilter | Date | string
    userId?: IntFilter | number
    guildId?: StringFilter | string
    activityId?: IntFilter | number
  }

  export type UserCreateWithoutGuildsInput = {
    id: number
    name: string
    nick: string
    timezone?: number
    role: role
    levelRole?: levelRole
    logsNow?: logsNowCreateNestedManyWithoutUserInput
    historicLogs?: historicLogsCreateNestedManyWithoutUserInput
    historicQuickLogs?: historicQuickLogsCreateNestedManyWithoutUserInput
    logsToday?: logsTodayCreateNestedManyWithoutUserInput
    UserActivityLogsToday?: UserActivityLogsTodayCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGuildsInput = {
    id: number
    name: string
    nick: string
    timezone?: number
    role: role
    levelRole?: levelRole
    logsNow?: logsNowUncheckedCreateNestedManyWithoutUserInput
    historicLogs?: historicLogsUncheckedCreateNestedManyWithoutUserInput
    historicQuickLogs?: historicQuickLogsUncheckedCreateNestedManyWithoutUserInput
    logsToday?: logsTodayUncheckedCreateNestedManyWithoutUserInput
    UserActivityLogsToday?: UserActivityLogsTodayUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGuildsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGuildsInput, UserUncheckedCreateWithoutGuildsInput>
  }

  export type GuildPreferencesCreateWithoutGuildInput = {

  }

  export type GuildPreferencesUncheckedCreateWithoutGuildInput = {
    id?: number
  }

  export type GuildPreferencesCreateOrConnectWithoutGuildInput = {
    where: GuildPreferencesWhereUniqueInput
    create: XOR<GuildPreferencesCreateWithoutGuildInput, GuildPreferencesUncheckedCreateWithoutGuildInput>
  }

  export type logsNowCreateWithoutGuildInput = {
    user: UserCreateNestedOneWithoutLogsNowInput
    activity: ActivityCreateNestedOneWithoutLogsNowInput
    timestamp?: Date | string
    type: ActivityType
  }

  export type logsNowUncheckedCreateWithoutGuildInput = {
    id?: number
    timestamp?: Date | string
    type: ActivityType
    userId: number
    activityId: number
  }

  export type logsNowCreateOrConnectWithoutGuildInput = {
    where: logsNowWhereUniqueInput
    create: XOR<logsNowCreateWithoutGuildInput, logsNowUncheckedCreateWithoutGuildInput>
  }

  export type logsNowCreateManyGuildInputEnvelope = {
    data: Enumerable<logsNowCreateManyGuildInput>
    skipDuplicates?: boolean
  }

  export type historicLogsCreateWithoutGuildInput = {
    user: UserCreateNestedOneWithoutHistoricLogsInput
    activity: ActivityCreateNestedOneWithoutHistoricLogsInput
    date: Date | string
    type: ActivityType
    timeframe: Timeframe
  }

  export type historicLogsUncheckedCreateWithoutGuildInput = {
    id?: number
    date: Date | string
    type: ActivityType
    timeframe: Timeframe
    userId: number
    activityId: number
  }

  export type historicLogsCreateOrConnectWithoutGuildInput = {
    where: historicLogsWhereUniqueInput
    create: XOR<historicLogsCreateWithoutGuildInput, historicLogsUncheckedCreateWithoutGuildInput>
  }

  export type historicLogsCreateManyGuildInputEnvelope = {
    data: Enumerable<historicLogsCreateManyGuildInput>
    skipDuplicates?: boolean
  }

  export type historicQuickLogsCreateWithoutGuildInput = {
    user: UserCreateNestedOneWithoutHistoricQuickLogsInput
    activity: ActivityCreateNestedOneWithoutHistoricQuickLogsInput
    date: Date | string
    type: ActivityType
    start: Date | string
    end: Date | string
  }

  export type historicQuickLogsUncheckedCreateWithoutGuildInput = {
    id?: number
    date: Date | string
    type: ActivityType
    start: Date | string
    end: Date | string
    userId: number
    activityId: number
  }

  export type historicQuickLogsCreateOrConnectWithoutGuildInput = {
    where: historicQuickLogsWhereUniqueInput
    create: XOR<historicQuickLogsCreateWithoutGuildInput, historicQuickLogsUncheckedCreateWithoutGuildInput>
  }

  export type historicQuickLogsCreateManyGuildInputEnvelope = {
    data: Enumerable<historicQuickLogsCreateManyGuildInput>
    skipDuplicates?: boolean
  }

  export type UserActivityLogsTodayCreateWithoutGuildInput = {
    user: UserCreateNestedOneWithoutUserActivityLogsTodayInput
    type: ActivityType
    activity: ActivityCreateNestedOneWithoutUserActivityLogsTodayInput
    startedAt: Date | string
    endedAt: Date | string
  }

  export type UserActivityLogsTodayUncheckedCreateWithoutGuildInput = {
    id?: number
    type: ActivityType
    startedAt: Date | string
    endedAt: Date | string
    userId: number
    activityId: number
  }

  export type UserActivityLogsTodayCreateOrConnectWithoutGuildInput = {
    where: UserActivityLogsTodayWhereUniqueInput
    create: XOR<UserActivityLogsTodayCreateWithoutGuildInput, UserActivityLogsTodayUncheckedCreateWithoutGuildInput>
  }

  export type UserActivityLogsTodayCreateManyGuildInputEnvelope = {
    data: Enumerable<UserActivityLogsTodayCreateManyGuildInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutGuildsInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutGuildsInput, UserUncheckedUpdateWithoutGuildsInput>
    create: XOR<UserCreateWithoutGuildsInput, UserUncheckedCreateWithoutGuildsInput>
  }

  export type UserUpdateWithWhereUniqueWithoutGuildsInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutGuildsInput, UserUncheckedUpdateWithoutGuildsInput>
  }

  export type UserUpdateManyWithWhereWithoutGuildsInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutUsersInput>
  }

  export type UserScalarWhereInput = {
    AND?: Enumerable<UserScalarWhereInput>
    OR?: Enumerable<UserScalarWhereInput>
    NOT?: Enumerable<UserScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    nick?: StringFilter | string
    timezone?: IntFilter | number
    role?: EnumroleFilter | role
    levelRole?: EnumlevelRoleFilter | levelRole
  }

  export type GuildPreferencesUpsertWithoutGuildInput = {
    update: XOR<GuildPreferencesUpdateWithoutGuildInput, GuildPreferencesUncheckedUpdateWithoutGuildInput>
    create: XOR<GuildPreferencesCreateWithoutGuildInput, GuildPreferencesUncheckedCreateWithoutGuildInput>
  }

  export type GuildPreferencesUpdateWithoutGuildInput = {

  }

  export type GuildPreferencesUncheckedUpdateWithoutGuildInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type logsNowUpsertWithWhereUniqueWithoutGuildInput = {
    where: logsNowWhereUniqueInput
    update: XOR<logsNowUpdateWithoutGuildInput, logsNowUncheckedUpdateWithoutGuildInput>
    create: XOR<logsNowCreateWithoutGuildInput, logsNowUncheckedCreateWithoutGuildInput>
  }

  export type logsNowUpdateWithWhereUniqueWithoutGuildInput = {
    where: logsNowWhereUniqueInput
    data: XOR<logsNowUpdateWithoutGuildInput, logsNowUncheckedUpdateWithoutGuildInput>
  }

  export type logsNowUpdateManyWithWhereWithoutGuildInput = {
    where: logsNowScalarWhereInput
    data: XOR<logsNowUpdateManyMutationInput, logsNowUncheckedUpdateManyWithoutLogsNowInput>
  }

  export type historicLogsUpsertWithWhereUniqueWithoutGuildInput = {
    where: historicLogsWhereUniqueInput
    update: XOR<historicLogsUpdateWithoutGuildInput, historicLogsUncheckedUpdateWithoutGuildInput>
    create: XOR<historicLogsCreateWithoutGuildInput, historicLogsUncheckedCreateWithoutGuildInput>
  }

  export type historicLogsUpdateWithWhereUniqueWithoutGuildInput = {
    where: historicLogsWhereUniqueInput
    data: XOR<historicLogsUpdateWithoutGuildInput, historicLogsUncheckedUpdateWithoutGuildInput>
  }

  export type historicLogsUpdateManyWithWhereWithoutGuildInput = {
    where: historicLogsScalarWhereInput
    data: XOR<historicLogsUpdateManyMutationInput, historicLogsUncheckedUpdateManyWithoutHistoricLogsInput>
  }

  export type historicQuickLogsUpsertWithWhereUniqueWithoutGuildInput = {
    where: historicQuickLogsWhereUniqueInput
    update: XOR<historicQuickLogsUpdateWithoutGuildInput, historicQuickLogsUncheckedUpdateWithoutGuildInput>
    create: XOR<historicQuickLogsCreateWithoutGuildInput, historicQuickLogsUncheckedCreateWithoutGuildInput>
  }

  export type historicQuickLogsUpdateWithWhereUniqueWithoutGuildInput = {
    where: historicQuickLogsWhereUniqueInput
    data: XOR<historicQuickLogsUpdateWithoutGuildInput, historicQuickLogsUncheckedUpdateWithoutGuildInput>
  }

  export type historicQuickLogsUpdateManyWithWhereWithoutGuildInput = {
    where: historicQuickLogsScalarWhereInput
    data: XOR<historicQuickLogsUpdateManyMutationInput, historicQuickLogsUncheckedUpdateManyWithoutHistoricQuickLogsInput>
  }

  export type UserActivityLogsTodayUpsertWithWhereUniqueWithoutGuildInput = {
    where: UserActivityLogsTodayWhereUniqueInput
    update: XOR<UserActivityLogsTodayUpdateWithoutGuildInput, UserActivityLogsTodayUncheckedUpdateWithoutGuildInput>
    create: XOR<UserActivityLogsTodayCreateWithoutGuildInput, UserActivityLogsTodayUncheckedCreateWithoutGuildInput>
  }

  export type UserActivityLogsTodayUpdateWithWhereUniqueWithoutGuildInput = {
    where: UserActivityLogsTodayWhereUniqueInput
    data: XOR<UserActivityLogsTodayUpdateWithoutGuildInput, UserActivityLogsTodayUncheckedUpdateWithoutGuildInput>
  }

  export type UserActivityLogsTodayUpdateManyWithWhereWithoutGuildInput = {
    where: UserActivityLogsTodayScalarWhereInput
    data: XOR<UserActivityLogsTodayUpdateManyMutationInput, UserActivityLogsTodayUncheckedUpdateManyWithoutUserActivityLogsTodayInput>
  }

  export type GuildCreateWithoutGuildPreferencesInput = {
    id: string
    name: string
    users?: UserCreateNestedManyWithoutGuildsInput
    preferenceID: number
    logsNow?: logsNowCreateNestedManyWithoutGuildInput
    historicLogs?: historicLogsCreateNestedManyWithoutGuildInput
    historicQuickLogs?: historicQuickLogsCreateNestedManyWithoutGuildInput
    UserActivityLogsToday?: UserActivityLogsTodayCreateNestedManyWithoutGuildInput
  }

  export type GuildUncheckedCreateWithoutGuildPreferencesInput = {
    id: string
    name: string
    users?: UserUncheckedCreateNestedManyWithoutGuildsInput
    preferenceID: number
    logsNow?: logsNowUncheckedCreateNestedManyWithoutGuildInput
    historicLogs?: historicLogsUncheckedCreateNestedManyWithoutGuildInput
    historicQuickLogs?: historicQuickLogsUncheckedCreateNestedManyWithoutGuildInput
    UserActivityLogsToday?: UserActivityLogsTodayUncheckedCreateNestedManyWithoutGuildInput
  }

  export type GuildCreateOrConnectWithoutGuildPreferencesInput = {
    where: GuildWhereUniqueInput
    create: XOR<GuildCreateWithoutGuildPreferencesInput, GuildUncheckedCreateWithoutGuildPreferencesInput>
  }

  export type GuildUpsertWithoutGuildPreferencesInput = {
    update: XOR<GuildUpdateWithoutGuildPreferencesInput, GuildUncheckedUpdateWithoutGuildPreferencesInput>
    create: XOR<GuildCreateWithoutGuildPreferencesInput, GuildUncheckedCreateWithoutGuildPreferencesInput>
  }

  export type GuildUpdateWithoutGuildPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateManyWithoutGuildsNestedInput
    preferenceID?: IntFieldUpdateOperationsInput | number
    logsNow?: logsNowUpdateManyWithoutGuildNestedInput
    historicLogs?: historicLogsUpdateManyWithoutGuildNestedInput
    historicQuickLogs?: historicQuickLogsUpdateManyWithoutGuildNestedInput
    UserActivityLogsToday?: UserActivityLogsTodayUpdateManyWithoutGuildNestedInput
  }

  export type GuildUncheckedUpdateWithoutGuildPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    users?: UserUncheckedUpdateManyWithoutGuildsNestedInput
    preferenceID?: IntFieldUpdateOperationsInput | number
    logsNow?: logsNowUncheckedUpdateManyWithoutGuildNestedInput
    historicLogs?: historicLogsUncheckedUpdateManyWithoutGuildNestedInput
    historicQuickLogs?: historicQuickLogsUncheckedUpdateManyWithoutGuildNestedInput
    UserActivityLogsToday?: UserActivityLogsTodayUncheckedUpdateManyWithoutGuildNestedInput
  }

  export type ActivityRewardsCreateWithoutActivityInput = {
    rewardMinute: number
    rewardMinuteCam: number
    rewardMinuteLog: number
    RewardStreak: number
    RewardRestart: number
    rewardMin: number
    rewardMax: number
    reward: number
  }

  export type ActivityRewardsUncheckedCreateWithoutActivityInput = {
    id?: number
    rewardMinute: number
    rewardMinuteCam: number
    rewardMinuteLog: number
    RewardStreak: number
    RewardRestart: number
    rewardMin: number
    rewardMax: number
    reward: number
  }

  export type ActivityRewardsCreateOrConnectWithoutActivityInput = {
    where: ActivityRewardsWhereUniqueInput
    create: XOR<ActivityRewardsCreateWithoutActivityInput, ActivityRewardsUncheckedCreateWithoutActivityInput>
  }

  export type UserActivityLogsTodayCreateWithoutActivityInput = {
    user: UserCreateNestedOneWithoutUserActivityLogsTodayInput
    type: ActivityType
    guild: GuildCreateNestedOneWithoutUserActivityLogsTodayInput
    startedAt: Date | string
    endedAt: Date | string
  }

  export type UserActivityLogsTodayUncheckedCreateWithoutActivityInput = {
    id?: number
    type: ActivityType
    startedAt: Date | string
    endedAt: Date | string
    userId: number
    guildId: string
  }

  export type UserActivityLogsTodayCreateOrConnectWithoutActivityInput = {
    where: UserActivityLogsTodayWhereUniqueInput
    create: XOR<UserActivityLogsTodayCreateWithoutActivityInput, UserActivityLogsTodayUncheckedCreateWithoutActivityInput>
  }

  export type UserActivityLogsTodayCreateManyActivityInputEnvelope = {
    data: Enumerable<UserActivityLogsTodayCreateManyActivityInput>
    skipDuplicates?: boolean
  }

  export type logsNowCreateWithoutActivityInput = {
    user: UserCreateNestedOneWithoutLogsNowInput
    guild: GuildCreateNestedOneWithoutLogsNowInput
    timestamp?: Date | string
    type: ActivityType
  }

  export type logsNowUncheckedCreateWithoutActivityInput = {
    id?: number
    timestamp?: Date | string
    type: ActivityType
    userId: number
    guildId: string
  }

  export type logsNowCreateOrConnectWithoutActivityInput = {
    where: logsNowWhereUniqueInput
    create: XOR<logsNowCreateWithoutActivityInput, logsNowUncheckedCreateWithoutActivityInput>
  }

  export type logsNowCreateManyActivityInputEnvelope = {
    data: Enumerable<logsNowCreateManyActivityInput>
    skipDuplicates?: boolean
  }

  export type historicLogsCreateWithoutActivityInput = {
    user: UserCreateNestedOneWithoutHistoricLogsInput
    guild: GuildCreateNestedOneWithoutHistoricLogsInput
    date: Date | string
    type: ActivityType
    timeframe: Timeframe
  }

  export type historicLogsUncheckedCreateWithoutActivityInput = {
    id?: number
    date: Date | string
    type: ActivityType
    timeframe: Timeframe
    userId: number
    guildId: string
  }

  export type historicLogsCreateOrConnectWithoutActivityInput = {
    where: historicLogsWhereUniqueInput
    create: XOR<historicLogsCreateWithoutActivityInput, historicLogsUncheckedCreateWithoutActivityInput>
  }

  export type historicLogsCreateManyActivityInputEnvelope = {
    data: Enumerable<historicLogsCreateManyActivityInput>
    skipDuplicates?: boolean
  }

  export type historicQuickLogsCreateWithoutActivityInput = {
    user: UserCreateNestedOneWithoutHistoricQuickLogsInput
    guild: GuildCreateNestedOneWithoutHistoricQuickLogsInput
    date: Date | string
    type: ActivityType
    start: Date | string
    end: Date | string
  }

  export type historicQuickLogsUncheckedCreateWithoutActivityInput = {
    id?: number
    date: Date | string
    type: ActivityType
    start: Date | string
    end: Date | string
    userId: number
    guildId: string
  }

  export type historicQuickLogsCreateOrConnectWithoutActivityInput = {
    where: historicQuickLogsWhereUniqueInput
    create: XOR<historicQuickLogsCreateWithoutActivityInput, historicQuickLogsUncheckedCreateWithoutActivityInput>
  }

  export type historicQuickLogsCreateManyActivityInputEnvelope = {
    data: Enumerable<historicQuickLogsCreateManyActivityInput>
    skipDuplicates?: boolean
  }

  export type logsTodayCreateWithoutActivityInput = {
    user: UserCreateNestedOneWithoutLogsTodayInput
    date: Date | string
    Type: string
    Timeframe: Timeframe
    minutes?: number
  }

  export type logsTodayUncheckedCreateWithoutActivityInput = {
    id?: number
    date: Date | string
    Type: string
    Timeframe: Timeframe
    minutes?: number
    userId: number
  }

  export type logsTodayCreateOrConnectWithoutActivityInput = {
    where: logsTodayWhereUniqueInput
    create: XOR<logsTodayCreateWithoutActivityInput, logsTodayUncheckedCreateWithoutActivityInput>
  }

  export type logsTodayCreateManyActivityInputEnvelope = {
    data: Enumerable<logsTodayCreateManyActivityInput>
    skipDuplicates?: boolean
  }

  export type ActivityRewardsUpsertWithoutActivityInput = {
    update: XOR<ActivityRewardsUpdateWithoutActivityInput, ActivityRewardsUncheckedUpdateWithoutActivityInput>
    create: XOR<ActivityRewardsCreateWithoutActivityInput, ActivityRewardsUncheckedCreateWithoutActivityInput>
  }

  export type ActivityRewardsUpdateWithoutActivityInput = {
    rewardMinute?: IntFieldUpdateOperationsInput | number
    rewardMinuteCam?: IntFieldUpdateOperationsInput | number
    rewardMinuteLog?: IntFieldUpdateOperationsInput | number
    RewardStreak?: IntFieldUpdateOperationsInput | number
    RewardRestart?: IntFieldUpdateOperationsInput | number
    rewardMin?: IntFieldUpdateOperationsInput | number
    rewardMax?: IntFieldUpdateOperationsInput | number
    reward?: IntFieldUpdateOperationsInput | number
  }

  export type ActivityRewardsUncheckedUpdateWithoutActivityInput = {
    id?: IntFieldUpdateOperationsInput | number
    rewardMinute?: IntFieldUpdateOperationsInput | number
    rewardMinuteCam?: IntFieldUpdateOperationsInput | number
    rewardMinuteLog?: IntFieldUpdateOperationsInput | number
    RewardStreak?: IntFieldUpdateOperationsInput | number
    RewardRestart?: IntFieldUpdateOperationsInput | number
    rewardMin?: IntFieldUpdateOperationsInput | number
    rewardMax?: IntFieldUpdateOperationsInput | number
    reward?: IntFieldUpdateOperationsInput | number
  }

  export type UserActivityLogsTodayUpsertWithWhereUniqueWithoutActivityInput = {
    where: UserActivityLogsTodayWhereUniqueInput
    update: XOR<UserActivityLogsTodayUpdateWithoutActivityInput, UserActivityLogsTodayUncheckedUpdateWithoutActivityInput>
    create: XOR<UserActivityLogsTodayCreateWithoutActivityInput, UserActivityLogsTodayUncheckedCreateWithoutActivityInput>
  }

  export type UserActivityLogsTodayUpdateWithWhereUniqueWithoutActivityInput = {
    where: UserActivityLogsTodayWhereUniqueInput
    data: XOR<UserActivityLogsTodayUpdateWithoutActivityInput, UserActivityLogsTodayUncheckedUpdateWithoutActivityInput>
  }

  export type UserActivityLogsTodayUpdateManyWithWhereWithoutActivityInput = {
    where: UserActivityLogsTodayScalarWhereInput
    data: XOR<UserActivityLogsTodayUpdateManyMutationInput, UserActivityLogsTodayUncheckedUpdateManyWithoutUserActivityLogsTodayInput>
  }

  export type logsNowUpsertWithWhereUniqueWithoutActivityInput = {
    where: logsNowWhereUniqueInput
    update: XOR<logsNowUpdateWithoutActivityInput, logsNowUncheckedUpdateWithoutActivityInput>
    create: XOR<logsNowCreateWithoutActivityInput, logsNowUncheckedCreateWithoutActivityInput>
  }

  export type logsNowUpdateWithWhereUniqueWithoutActivityInput = {
    where: logsNowWhereUniqueInput
    data: XOR<logsNowUpdateWithoutActivityInput, logsNowUncheckedUpdateWithoutActivityInput>
  }

  export type logsNowUpdateManyWithWhereWithoutActivityInput = {
    where: logsNowScalarWhereInput
    data: XOR<logsNowUpdateManyMutationInput, logsNowUncheckedUpdateManyWithoutLogsNowInput>
  }

  export type historicLogsUpsertWithWhereUniqueWithoutActivityInput = {
    where: historicLogsWhereUniqueInput
    update: XOR<historicLogsUpdateWithoutActivityInput, historicLogsUncheckedUpdateWithoutActivityInput>
    create: XOR<historicLogsCreateWithoutActivityInput, historicLogsUncheckedCreateWithoutActivityInput>
  }

  export type historicLogsUpdateWithWhereUniqueWithoutActivityInput = {
    where: historicLogsWhereUniqueInput
    data: XOR<historicLogsUpdateWithoutActivityInput, historicLogsUncheckedUpdateWithoutActivityInput>
  }

  export type historicLogsUpdateManyWithWhereWithoutActivityInput = {
    where: historicLogsScalarWhereInput
    data: XOR<historicLogsUpdateManyMutationInput, historicLogsUncheckedUpdateManyWithoutHistoricLogsInput>
  }

  export type historicQuickLogsUpsertWithWhereUniqueWithoutActivityInput = {
    where: historicQuickLogsWhereUniqueInput
    update: XOR<historicQuickLogsUpdateWithoutActivityInput, historicQuickLogsUncheckedUpdateWithoutActivityInput>
    create: XOR<historicQuickLogsCreateWithoutActivityInput, historicQuickLogsUncheckedCreateWithoutActivityInput>
  }

  export type historicQuickLogsUpdateWithWhereUniqueWithoutActivityInput = {
    where: historicQuickLogsWhereUniqueInput
    data: XOR<historicQuickLogsUpdateWithoutActivityInput, historicQuickLogsUncheckedUpdateWithoutActivityInput>
  }

  export type historicQuickLogsUpdateManyWithWhereWithoutActivityInput = {
    where: historicQuickLogsScalarWhereInput
    data: XOR<historicQuickLogsUpdateManyMutationInput, historicQuickLogsUncheckedUpdateManyWithoutHistoricQuickLogsInput>
  }

  export type logsTodayUpsertWithWhereUniqueWithoutActivityInput = {
    where: logsTodayWhereUniqueInput
    update: XOR<logsTodayUpdateWithoutActivityInput, logsTodayUncheckedUpdateWithoutActivityInput>
    create: XOR<logsTodayCreateWithoutActivityInput, logsTodayUncheckedCreateWithoutActivityInput>
  }

  export type logsTodayUpdateWithWhereUniqueWithoutActivityInput = {
    where: logsTodayWhereUniqueInput
    data: XOR<logsTodayUpdateWithoutActivityInput, logsTodayUncheckedUpdateWithoutActivityInput>
  }

  export type logsTodayUpdateManyWithWhereWithoutActivityInput = {
    where: logsTodayScalarWhereInput
    data: XOR<logsTodayUpdateManyMutationInput, logsTodayUncheckedUpdateManyWithoutLogsTodayInput>
  }

  export type ActivityCreateWithoutRewardsInput = {
    name: string
    UserActivityLogsToday?: UserActivityLogsTodayCreateNestedManyWithoutActivityInput
    logsNow?: logsNowCreateNestedManyWithoutActivityInput
    historicLogs?: historicLogsCreateNestedManyWithoutActivityInput
    historicQuickLogs?: historicQuickLogsCreateNestedManyWithoutActivityInput
    logsToday?: logsTodayCreateNestedManyWithoutActivityInput
  }

  export type ActivityUncheckedCreateWithoutRewardsInput = {
    id?: number
    name: string
    UserActivityLogsToday?: UserActivityLogsTodayUncheckedCreateNestedManyWithoutActivityInput
    logsNow?: logsNowUncheckedCreateNestedManyWithoutActivityInput
    historicLogs?: historicLogsUncheckedCreateNestedManyWithoutActivityInput
    historicQuickLogs?: historicQuickLogsUncheckedCreateNestedManyWithoutActivityInput
    logsToday?: logsTodayUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityCreateOrConnectWithoutRewardsInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutRewardsInput, ActivityUncheckedCreateWithoutRewardsInput>
  }

  export type ActivityUpsertWithoutRewardsInput = {
    update: XOR<ActivityUpdateWithoutRewardsInput, ActivityUncheckedUpdateWithoutRewardsInput>
    create: XOR<ActivityCreateWithoutRewardsInput, ActivityUncheckedCreateWithoutRewardsInput>
  }

  export type ActivityUpdateWithoutRewardsInput = {
    name?: StringFieldUpdateOperationsInput | string
    UserActivityLogsToday?: UserActivityLogsTodayUpdateManyWithoutActivityNestedInput
    logsNow?: logsNowUpdateManyWithoutActivityNestedInput
    historicLogs?: historicLogsUpdateManyWithoutActivityNestedInput
    historicQuickLogs?: historicQuickLogsUpdateManyWithoutActivityNestedInput
    logsToday?: logsTodayUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateWithoutRewardsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    UserActivityLogsToday?: UserActivityLogsTodayUncheckedUpdateManyWithoutActivityNestedInput
    logsNow?: logsNowUncheckedUpdateManyWithoutActivityNestedInput
    historicLogs?: historicLogsUncheckedUpdateManyWithoutActivityNestedInput
    historicQuickLogs?: historicQuickLogsUncheckedUpdateManyWithoutActivityNestedInput
    logsToday?: logsTodayUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type UserCreateWithoutLogsNowInput = {
    id: number
    name: string
    nick: string
    timezone?: number
    role: role
    levelRole?: levelRole
    guilds?: GuildCreateNestedManyWithoutUsersInput
    historicLogs?: historicLogsCreateNestedManyWithoutUserInput
    historicQuickLogs?: historicQuickLogsCreateNestedManyWithoutUserInput
    logsToday?: logsTodayCreateNestedManyWithoutUserInput
    UserActivityLogsToday?: UserActivityLogsTodayCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLogsNowInput = {
    id: number
    name: string
    nick: string
    timezone?: number
    role: role
    levelRole?: levelRole
    guilds?: GuildUncheckedCreateNestedManyWithoutUsersInput
    historicLogs?: historicLogsUncheckedCreateNestedManyWithoutUserInput
    historicQuickLogs?: historicQuickLogsUncheckedCreateNestedManyWithoutUserInput
    logsToday?: logsTodayUncheckedCreateNestedManyWithoutUserInput
    UserActivityLogsToday?: UserActivityLogsTodayUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLogsNowInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLogsNowInput, UserUncheckedCreateWithoutLogsNowInput>
  }

  export type ActivityCreateWithoutLogsNowInput = {
    name: string
    rewards?: ActivityRewardsCreateNestedOneWithoutActivityInput
    UserActivityLogsToday?: UserActivityLogsTodayCreateNestedManyWithoutActivityInput
    historicLogs?: historicLogsCreateNestedManyWithoutActivityInput
    historicQuickLogs?: historicQuickLogsCreateNestedManyWithoutActivityInput
    logsToday?: logsTodayCreateNestedManyWithoutActivityInput
  }

  export type ActivityUncheckedCreateWithoutLogsNowInput = {
    id?: number
    name: string
    rewards?: ActivityRewardsUncheckedCreateNestedOneWithoutActivityInput
    UserActivityLogsToday?: UserActivityLogsTodayUncheckedCreateNestedManyWithoutActivityInput
    historicLogs?: historicLogsUncheckedCreateNestedManyWithoutActivityInput
    historicQuickLogs?: historicQuickLogsUncheckedCreateNestedManyWithoutActivityInput
    logsToday?: logsTodayUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityCreateOrConnectWithoutLogsNowInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutLogsNowInput, ActivityUncheckedCreateWithoutLogsNowInput>
  }

  export type GuildCreateWithoutLogsNowInput = {
    id: string
    name: string
    users?: UserCreateNestedManyWithoutGuildsInput
    GuildPreferences?: GuildPreferencesCreateNestedOneWithoutGuildInput
    preferenceID: number
    historicLogs?: historicLogsCreateNestedManyWithoutGuildInput
    historicQuickLogs?: historicQuickLogsCreateNestedManyWithoutGuildInput
    UserActivityLogsToday?: UserActivityLogsTodayCreateNestedManyWithoutGuildInput
  }

  export type GuildUncheckedCreateWithoutLogsNowInput = {
    id: string
    name: string
    users?: UserUncheckedCreateNestedManyWithoutGuildsInput
    GuildPreferences?: GuildPreferencesUncheckedCreateNestedOneWithoutGuildInput
    preferenceID: number
    historicLogs?: historicLogsUncheckedCreateNestedManyWithoutGuildInput
    historicQuickLogs?: historicQuickLogsUncheckedCreateNestedManyWithoutGuildInput
    UserActivityLogsToday?: UserActivityLogsTodayUncheckedCreateNestedManyWithoutGuildInput
  }

  export type GuildCreateOrConnectWithoutLogsNowInput = {
    where: GuildWhereUniqueInput
    create: XOR<GuildCreateWithoutLogsNowInput, GuildUncheckedCreateWithoutLogsNowInput>
  }

  export type UserUpsertWithoutLogsNowInput = {
    update: XOR<UserUpdateWithoutLogsNowInput, UserUncheckedUpdateWithoutLogsNowInput>
    create: XOR<UserCreateWithoutLogsNowInput, UserUncheckedCreateWithoutLogsNowInput>
  }

  export type UserUpdateWithoutLogsNowInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    nick?: StringFieldUpdateOperationsInput | string
    timezone?: IntFieldUpdateOperationsInput | number
    role?: EnumroleFieldUpdateOperationsInput | role
    levelRole?: EnumlevelRoleFieldUpdateOperationsInput | levelRole
    guilds?: GuildUpdateManyWithoutUsersNestedInput
    historicLogs?: historicLogsUpdateManyWithoutUserNestedInput
    historicQuickLogs?: historicQuickLogsUpdateManyWithoutUserNestedInput
    logsToday?: logsTodayUpdateManyWithoutUserNestedInput
    UserActivityLogsToday?: UserActivityLogsTodayUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLogsNowInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    nick?: StringFieldUpdateOperationsInput | string
    timezone?: IntFieldUpdateOperationsInput | number
    role?: EnumroleFieldUpdateOperationsInput | role
    levelRole?: EnumlevelRoleFieldUpdateOperationsInput | levelRole
    guilds?: GuildUncheckedUpdateManyWithoutUsersNestedInput
    historicLogs?: historicLogsUncheckedUpdateManyWithoutUserNestedInput
    historicQuickLogs?: historicQuickLogsUncheckedUpdateManyWithoutUserNestedInput
    logsToday?: logsTodayUncheckedUpdateManyWithoutUserNestedInput
    UserActivityLogsToday?: UserActivityLogsTodayUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ActivityUpsertWithoutLogsNowInput = {
    update: XOR<ActivityUpdateWithoutLogsNowInput, ActivityUncheckedUpdateWithoutLogsNowInput>
    create: XOR<ActivityCreateWithoutLogsNowInput, ActivityUncheckedCreateWithoutLogsNowInput>
  }

  export type ActivityUpdateWithoutLogsNowInput = {
    name?: StringFieldUpdateOperationsInput | string
    rewards?: ActivityRewardsUpdateOneWithoutActivityNestedInput
    UserActivityLogsToday?: UserActivityLogsTodayUpdateManyWithoutActivityNestedInput
    historicLogs?: historicLogsUpdateManyWithoutActivityNestedInput
    historicQuickLogs?: historicQuickLogsUpdateManyWithoutActivityNestedInput
    logsToday?: logsTodayUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateWithoutLogsNowInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    rewards?: ActivityRewardsUncheckedUpdateOneWithoutActivityNestedInput
    UserActivityLogsToday?: UserActivityLogsTodayUncheckedUpdateManyWithoutActivityNestedInput
    historicLogs?: historicLogsUncheckedUpdateManyWithoutActivityNestedInput
    historicQuickLogs?: historicQuickLogsUncheckedUpdateManyWithoutActivityNestedInput
    logsToday?: logsTodayUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type GuildUpsertWithoutLogsNowInput = {
    update: XOR<GuildUpdateWithoutLogsNowInput, GuildUncheckedUpdateWithoutLogsNowInput>
    create: XOR<GuildCreateWithoutLogsNowInput, GuildUncheckedCreateWithoutLogsNowInput>
  }

  export type GuildUpdateWithoutLogsNowInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateManyWithoutGuildsNestedInput
    GuildPreferences?: GuildPreferencesUpdateOneWithoutGuildNestedInput
    preferenceID?: IntFieldUpdateOperationsInput | number
    historicLogs?: historicLogsUpdateManyWithoutGuildNestedInput
    historicQuickLogs?: historicQuickLogsUpdateManyWithoutGuildNestedInput
    UserActivityLogsToday?: UserActivityLogsTodayUpdateManyWithoutGuildNestedInput
  }

  export type GuildUncheckedUpdateWithoutLogsNowInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    users?: UserUncheckedUpdateManyWithoutGuildsNestedInput
    GuildPreferences?: GuildPreferencesUncheckedUpdateOneWithoutGuildNestedInput
    preferenceID?: IntFieldUpdateOperationsInput | number
    historicLogs?: historicLogsUncheckedUpdateManyWithoutGuildNestedInput
    historicQuickLogs?: historicQuickLogsUncheckedUpdateManyWithoutGuildNestedInput
    UserActivityLogsToday?: UserActivityLogsTodayUncheckedUpdateManyWithoutGuildNestedInput
  }

  export type UserCreateWithoutHistoricLogsInput = {
    id: number
    name: string
    nick: string
    timezone?: number
    role: role
    levelRole?: levelRole
    guilds?: GuildCreateNestedManyWithoutUsersInput
    logsNow?: logsNowCreateNestedManyWithoutUserInput
    historicQuickLogs?: historicQuickLogsCreateNestedManyWithoutUserInput
    logsToday?: logsTodayCreateNestedManyWithoutUserInput
    UserActivityLogsToday?: UserActivityLogsTodayCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutHistoricLogsInput = {
    id: number
    name: string
    nick: string
    timezone?: number
    role: role
    levelRole?: levelRole
    guilds?: GuildUncheckedCreateNestedManyWithoutUsersInput
    logsNow?: logsNowUncheckedCreateNestedManyWithoutUserInput
    historicQuickLogs?: historicQuickLogsUncheckedCreateNestedManyWithoutUserInput
    logsToday?: logsTodayUncheckedCreateNestedManyWithoutUserInput
    UserActivityLogsToday?: UserActivityLogsTodayUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutHistoricLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHistoricLogsInput, UserUncheckedCreateWithoutHistoricLogsInput>
  }

  export type ActivityCreateWithoutHistoricLogsInput = {
    name: string
    rewards?: ActivityRewardsCreateNestedOneWithoutActivityInput
    UserActivityLogsToday?: UserActivityLogsTodayCreateNestedManyWithoutActivityInput
    logsNow?: logsNowCreateNestedManyWithoutActivityInput
    historicQuickLogs?: historicQuickLogsCreateNestedManyWithoutActivityInput
    logsToday?: logsTodayCreateNestedManyWithoutActivityInput
  }

  export type ActivityUncheckedCreateWithoutHistoricLogsInput = {
    id?: number
    name: string
    rewards?: ActivityRewardsUncheckedCreateNestedOneWithoutActivityInput
    UserActivityLogsToday?: UserActivityLogsTodayUncheckedCreateNestedManyWithoutActivityInput
    logsNow?: logsNowUncheckedCreateNestedManyWithoutActivityInput
    historicQuickLogs?: historicQuickLogsUncheckedCreateNestedManyWithoutActivityInput
    logsToday?: logsTodayUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityCreateOrConnectWithoutHistoricLogsInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutHistoricLogsInput, ActivityUncheckedCreateWithoutHistoricLogsInput>
  }

  export type GuildCreateWithoutHistoricLogsInput = {
    id: string
    name: string
    users?: UserCreateNestedManyWithoutGuildsInput
    GuildPreferences?: GuildPreferencesCreateNestedOneWithoutGuildInput
    preferenceID: number
    logsNow?: logsNowCreateNestedManyWithoutGuildInput
    historicQuickLogs?: historicQuickLogsCreateNestedManyWithoutGuildInput
    UserActivityLogsToday?: UserActivityLogsTodayCreateNestedManyWithoutGuildInput
  }

  export type GuildUncheckedCreateWithoutHistoricLogsInput = {
    id: string
    name: string
    users?: UserUncheckedCreateNestedManyWithoutGuildsInput
    GuildPreferences?: GuildPreferencesUncheckedCreateNestedOneWithoutGuildInput
    preferenceID: number
    logsNow?: logsNowUncheckedCreateNestedManyWithoutGuildInput
    historicQuickLogs?: historicQuickLogsUncheckedCreateNestedManyWithoutGuildInput
    UserActivityLogsToday?: UserActivityLogsTodayUncheckedCreateNestedManyWithoutGuildInput
  }

  export type GuildCreateOrConnectWithoutHistoricLogsInput = {
    where: GuildWhereUniqueInput
    create: XOR<GuildCreateWithoutHistoricLogsInput, GuildUncheckedCreateWithoutHistoricLogsInput>
  }

  export type UserUpsertWithoutHistoricLogsInput = {
    update: XOR<UserUpdateWithoutHistoricLogsInput, UserUncheckedUpdateWithoutHistoricLogsInput>
    create: XOR<UserCreateWithoutHistoricLogsInput, UserUncheckedCreateWithoutHistoricLogsInput>
  }

  export type UserUpdateWithoutHistoricLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    nick?: StringFieldUpdateOperationsInput | string
    timezone?: IntFieldUpdateOperationsInput | number
    role?: EnumroleFieldUpdateOperationsInput | role
    levelRole?: EnumlevelRoleFieldUpdateOperationsInput | levelRole
    guilds?: GuildUpdateManyWithoutUsersNestedInput
    logsNow?: logsNowUpdateManyWithoutUserNestedInput
    historicQuickLogs?: historicQuickLogsUpdateManyWithoutUserNestedInput
    logsToday?: logsTodayUpdateManyWithoutUserNestedInput
    UserActivityLogsToday?: UserActivityLogsTodayUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutHistoricLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    nick?: StringFieldUpdateOperationsInput | string
    timezone?: IntFieldUpdateOperationsInput | number
    role?: EnumroleFieldUpdateOperationsInput | role
    levelRole?: EnumlevelRoleFieldUpdateOperationsInput | levelRole
    guilds?: GuildUncheckedUpdateManyWithoutUsersNestedInput
    logsNow?: logsNowUncheckedUpdateManyWithoutUserNestedInput
    historicQuickLogs?: historicQuickLogsUncheckedUpdateManyWithoutUserNestedInput
    logsToday?: logsTodayUncheckedUpdateManyWithoutUserNestedInput
    UserActivityLogsToday?: UserActivityLogsTodayUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ActivityUpsertWithoutHistoricLogsInput = {
    update: XOR<ActivityUpdateWithoutHistoricLogsInput, ActivityUncheckedUpdateWithoutHistoricLogsInput>
    create: XOR<ActivityCreateWithoutHistoricLogsInput, ActivityUncheckedCreateWithoutHistoricLogsInput>
  }

  export type ActivityUpdateWithoutHistoricLogsInput = {
    name?: StringFieldUpdateOperationsInput | string
    rewards?: ActivityRewardsUpdateOneWithoutActivityNestedInput
    UserActivityLogsToday?: UserActivityLogsTodayUpdateManyWithoutActivityNestedInput
    logsNow?: logsNowUpdateManyWithoutActivityNestedInput
    historicQuickLogs?: historicQuickLogsUpdateManyWithoutActivityNestedInput
    logsToday?: logsTodayUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateWithoutHistoricLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    rewards?: ActivityRewardsUncheckedUpdateOneWithoutActivityNestedInput
    UserActivityLogsToday?: UserActivityLogsTodayUncheckedUpdateManyWithoutActivityNestedInput
    logsNow?: logsNowUncheckedUpdateManyWithoutActivityNestedInput
    historicQuickLogs?: historicQuickLogsUncheckedUpdateManyWithoutActivityNestedInput
    logsToday?: logsTodayUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type GuildUpsertWithoutHistoricLogsInput = {
    update: XOR<GuildUpdateWithoutHistoricLogsInput, GuildUncheckedUpdateWithoutHistoricLogsInput>
    create: XOR<GuildCreateWithoutHistoricLogsInput, GuildUncheckedCreateWithoutHistoricLogsInput>
  }

  export type GuildUpdateWithoutHistoricLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateManyWithoutGuildsNestedInput
    GuildPreferences?: GuildPreferencesUpdateOneWithoutGuildNestedInput
    preferenceID?: IntFieldUpdateOperationsInput | number
    logsNow?: logsNowUpdateManyWithoutGuildNestedInput
    historicQuickLogs?: historicQuickLogsUpdateManyWithoutGuildNestedInput
    UserActivityLogsToday?: UserActivityLogsTodayUpdateManyWithoutGuildNestedInput
  }

  export type GuildUncheckedUpdateWithoutHistoricLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    users?: UserUncheckedUpdateManyWithoutGuildsNestedInput
    GuildPreferences?: GuildPreferencesUncheckedUpdateOneWithoutGuildNestedInput
    preferenceID?: IntFieldUpdateOperationsInput | number
    logsNow?: logsNowUncheckedUpdateManyWithoutGuildNestedInput
    historicQuickLogs?: historicQuickLogsUncheckedUpdateManyWithoutGuildNestedInput
    UserActivityLogsToday?: UserActivityLogsTodayUncheckedUpdateManyWithoutGuildNestedInput
  }

  export type UserCreateWithoutHistoricQuickLogsInput = {
    id: number
    name: string
    nick: string
    timezone?: number
    role: role
    levelRole?: levelRole
    guilds?: GuildCreateNestedManyWithoutUsersInput
    logsNow?: logsNowCreateNestedManyWithoutUserInput
    historicLogs?: historicLogsCreateNestedManyWithoutUserInput
    logsToday?: logsTodayCreateNestedManyWithoutUserInput
    UserActivityLogsToday?: UserActivityLogsTodayCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutHistoricQuickLogsInput = {
    id: number
    name: string
    nick: string
    timezone?: number
    role: role
    levelRole?: levelRole
    guilds?: GuildUncheckedCreateNestedManyWithoutUsersInput
    logsNow?: logsNowUncheckedCreateNestedManyWithoutUserInput
    historicLogs?: historicLogsUncheckedCreateNestedManyWithoutUserInput
    logsToday?: logsTodayUncheckedCreateNestedManyWithoutUserInput
    UserActivityLogsToday?: UserActivityLogsTodayUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutHistoricQuickLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHistoricQuickLogsInput, UserUncheckedCreateWithoutHistoricQuickLogsInput>
  }

  export type ActivityCreateWithoutHistoricQuickLogsInput = {
    name: string
    rewards?: ActivityRewardsCreateNestedOneWithoutActivityInput
    UserActivityLogsToday?: UserActivityLogsTodayCreateNestedManyWithoutActivityInput
    logsNow?: logsNowCreateNestedManyWithoutActivityInput
    historicLogs?: historicLogsCreateNestedManyWithoutActivityInput
    logsToday?: logsTodayCreateNestedManyWithoutActivityInput
  }

  export type ActivityUncheckedCreateWithoutHistoricQuickLogsInput = {
    id?: number
    name: string
    rewards?: ActivityRewardsUncheckedCreateNestedOneWithoutActivityInput
    UserActivityLogsToday?: UserActivityLogsTodayUncheckedCreateNestedManyWithoutActivityInput
    logsNow?: logsNowUncheckedCreateNestedManyWithoutActivityInput
    historicLogs?: historicLogsUncheckedCreateNestedManyWithoutActivityInput
    logsToday?: logsTodayUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityCreateOrConnectWithoutHistoricQuickLogsInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutHistoricQuickLogsInput, ActivityUncheckedCreateWithoutHistoricQuickLogsInput>
  }

  export type GuildCreateWithoutHistoricQuickLogsInput = {
    id: string
    name: string
    users?: UserCreateNestedManyWithoutGuildsInput
    GuildPreferences?: GuildPreferencesCreateNestedOneWithoutGuildInput
    preferenceID: number
    logsNow?: logsNowCreateNestedManyWithoutGuildInput
    historicLogs?: historicLogsCreateNestedManyWithoutGuildInput
    UserActivityLogsToday?: UserActivityLogsTodayCreateNestedManyWithoutGuildInput
  }

  export type GuildUncheckedCreateWithoutHistoricQuickLogsInput = {
    id: string
    name: string
    users?: UserUncheckedCreateNestedManyWithoutGuildsInput
    GuildPreferences?: GuildPreferencesUncheckedCreateNestedOneWithoutGuildInput
    preferenceID: number
    logsNow?: logsNowUncheckedCreateNestedManyWithoutGuildInput
    historicLogs?: historicLogsUncheckedCreateNestedManyWithoutGuildInput
    UserActivityLogsToday?: UserActivityLogsTodayUncheckedCreateNestedManyWithoutGuildInput
  }

  export type GuildCreateOrConnectWithoutHistoricQuickLogsInput = {
    where: GuildWhereUniqueInput
    create: XOR<GuildCreateWithoutHistoricQuickLogsInput, GuildUncheckedCreateWithoutHistoricQuickLogsInput>
  }

  export type UserUpsertWithoutHistoricQuickLogsInput = {
    update: XOR<UserUpdateWithoutHistoricQuickLogsInput, UserUncheckedUpdateWithoutHistoricQuickLogsInput>
    create: XOR<UserCreateWithoutHistoricQuickLogsInput, UserUncheckedCreateWithoutHistoricQuickLogsInput>
  }

  export type UserUpdateWithoutHistoricQuickLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    nick?: StringFieldUpdateOperationsInput | string
    timezone?: IntFieldUpdateOperationsInput | number
    role?: EnumroleFieldUpdateOperationsInput | role
    levelRole?: EnumlevelRoleFieldUpdateOperationsInput | levelRole
    guilds?: GuildUpdateManyWithoutUsersNestedInput
    logsNow?: logsNowUpdateManyWithoutUserNestedInput
    historicLogs?: historicLogsUpdateManyWithoutUserNestedInput
    logsToday?: logsTodayUpdateManyWithoutUserNestedInput
    UserActivityLogsToday?: UserActivityLogsTodayUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutHistoricQuickLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    nick?: StringFieldUpdateOperationsInput | string
    timezone?: IntFieldUpdateOperationsInput | number
    role?: EnumroleFieldUpdateOperationsInput | role
    levelRole?: EnumlevelRoleFieldUpdateOperationsInput | levelRole
    guilds?: GuildUncheckedUpdateManyWithoutUsersNestedInput
    logsNow?: logsNowUncheckedUpdateManyWithoutUserNestedInput
    historicLogs?: historicLogsUncheckedUpdateManyWithoutUserNestedInput
    logsToday?: logsTodayUncheckedUpdateManyWithoutUserNestedInput
    UserActivityLogsToday?: UserActivityLogsTodayUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ActivityUpsertWithoutHistoricQuickLogsInput = {
    update: XOR<ActivityUpdateWithoutHistoricQuickLogsInput, ActivityUncheckedUpdateWithoutHistoricQuickLogsInput>
    create: XOR<ActivityCreateWithoutHistoricQuickLogsInput, ActivityUncheckedCreateWithoutHistoricQuickLogsInput>
  }

  export type ActivityUpdateWithoutHistoricQuickLogsInput = {
    name?: StringFieldUpdateOperationsInput | string
    rewards?: ActivityRewardsUpdateOneWithoutActivityNestedInput
    UserActivityLogsToday?: UserActivityLogsTodayUpdateManyWithoutActivityNestedInput
    logsNow?: logsNowUpdateManyWithoutActivityNestedInput
    historicLogs?: historicLogsUpdateManyWithoutActivityNestedInput
    logsToday?: logsTodayUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateWithoutHistoricQuickLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    rewards?: ActivityRewardsUncheckedUpdateOneWithoutActivityNestedInput
    UserActivityLogsToday?: UserActivityLogsTodayUncheckedUpdateManyWithoutActivityNestedInput
    logsNow?: logsNowUncheckedUpdateManyWithoutActivityNestedInput
    historicLogs?: historicLogsUncheckedUpdateManyWithoutActivityNestedInput
    logsToday?: logsTodayUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type GuildUpsertWithoutHistoricQuickLogsInput = {
    update: XOR<GuildUpdateWithoutHistoricQuickLogsInput, GuildUncheckedUpdateWithoutHistoricQuickLogsInput>
    create: XOR<GuildCreateWithoutHistoricQuickLogsInput, GuildUncheckedCreateWithoutHistoricQuickLogsInput>
  }

  export type GuildUpdateWithoutHistoricQuickLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateManyWithoutGuildsNestedInput
    GuildPreferences?: GuildPreferencesUpdateOneWithoutGuildNestedInput
    preferenceID?: IntFieldUpdateOperationsInput | number
    logsNow?: logsNowUpdateManyWithoutGuildNestedInput
    historicLogs?: historicLogsUpdateManyWithoutGuildNestedInput
    UserActivityLogsToday?: UserActivityLogsTodayUpdateManyWithoutGuildNestedInput
  }

  export type GuildUncheckedUpdateWithoutHistoricQuickLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    users?: UserUncheckedUpdateManyWithoutGuildsNestedInput
    GuildPreferences?: GuildPreferencesUncheckedUpdateOneWithoutGuildNestedInput
    preferenceID?: IntFieldUpdateOperationsInput | number
    logsNow?: logsNowUncheckedUpdateManyWithoutGuildNestedInput
    historicLogs?: historicLogsUncheckedUpdateManyWithoutGuildNestedInput
    UserActivityLogsToday?: UserActivityLogsTodayUncheckedUpdateManyWithoutGuildNestedInput
  }

  export type UserCreateWithoutLogsTodayInput = {
    id: number
    name: string
    nick: string
    timezone?: number
    role: role
    levelRole?: levelRole
    guilds?: GuildCreateNestedManyWithoutUsersInput
    logsNow?: logsNowCreateNestedManyWithoutUserInput
    historicLogs?: historicLogsCreateNestedManyWithoutUserInput
    historicQuickLogs?: historicQuickLogsCreateNestedManyWithoutUserInput
    UserActivityLogsToday?: UserActivityLogsTodayCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLogsTodayInput = {
    id: number
    name: string
    nick: string
    timezone?: number
    role: role
    levelRole?: levelRole
    guilds?: GuildUncheckedCreateNestedManyWithoutUsersInput
    logsNow?: logsNowUncheckedCreateNestedManyWithoutUserInput
    historicLogs?: historicLogsUncheckedCreateNestedManyWithoutUserInput
    historicQuickLogs?: historicQuickLogsUncheckedCreateNestedManyWithoutUserInput
    UserActivityLogsToday?: UserActivityLogsTodayUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLogsTodayInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLogsTodayInput, UserUncheckedCreateWithoutLogsTodayInput>
  }

  export type ActivityCreateWithoutLogsTodayInput = {
    name: string
    rewards?: ActivityRewardsCreateNestedOneWithoutActivityInput
    UserActivityLogsToday?: UserActivityLogsTodayCreateNestedManyWithoutActivityInput
    logsNow?: logsNowCreateNestedManyWithoutActivityInput
    historicLogs?: historicLogsCreateNestedManyWithoutActivityInput
    historicQuickLogs?: historicQuickLogsCreateNestedManyWithoutActivityInput
  }

  export type ActivityUncheckedCreateWithoutLogsTodayInput = {
    id?: number
    name: string
    rewards?: ActivityRewardsUncheckedCreateNestedOneWithoutActivityInput
    UserActivityLogsToday?: UserActivityLogsTodayUncheckedCreateNestedManyWithoutActivityInput
    logsNow?: logsNowUncheckedCreateNestedManyWithoutActivityInput
    historicLogs?: historicLogsUncheckedCreateNestedManyWithoutActivityInput
    historicQuickLogs?: historicQuickLogsUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityCreateOrConnectWithoutLogsTodayInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutLogsTodayInput, ActivityUncheckedCreateWithoutLogsTodayInput>
  }

  export type UserUpsertWithoutLogsTodayInput = {
    update: XOR<UserUpdateWithoutLogsTodayInput, UserUncheckedUpdateWithoutLogsTodayInput>
    create: XOR<UserCreateWithoutLogsTodayInput, UserUncheckedCreateWithoutLogsTodayInput>
  }

  export type UserUpdateWithoutLogsTodayInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    nick?: StringFieldUpdateOperationsInput | string
    timezone?: IntFieldUpdateOperationsInput | number
    role?: EnumroleFieldUpdateOperationsInput | role
    levelRole?: EnumlevelRoleFieldUpdateOperationsInput | levelRole
    guilds?: GuildUpdateManyWithoutUsersNestedInput
    logsNow?: logsNowUpdateManyWithoutUserNestedInput
    historicLogs?: historicLogsUpdateManyWithoutUserNestedInput
    historicQuickLogs?: historicQuickLogsUpdateManyWithoutUserNestedInput
    UserActivityLogsToday?: UserActivityLogsTodayUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLogsTodayInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    nick?: StringFieldUpdateOperationsInput | string
    timezone?: IntFieldUpdateOperationsInput | number
    role?: EnumroleFieldUpdateOperationsInput | role
    levelRole?: EnumlevelRoleFieldUpdateOperationsInput | levelRole
    guilds?: GuildUncheckedUpdateManyWithoutUsersNestedInput
    logsNow?: logsNowUncheckedUpdateManyWithoutUserNestedInput
    historicLogs?: historicLogsUncheckedUpdateManyWithoutUserNestedInput
    historicQuickLogs?: historicQuickLogsUncheckedUpdateManyWithoutUserNestedInput
    UserActivityLogsToday?: UserActivityLogsTodayUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ActivityUpsertWithoutLogsTodayInput = {
    update: XOR<ActivityUpdateWithoutLogsTodayInput, ActivityUncheckedUpdateWithoutLogsTodayInput>
    create: XOR<ActivityCreateWithoutLogsTodayInput, ActivityUncheckedCreateWithoutLogsTodayInput>
  }

  export type ActivityUpdateWithoutLogsTodayInput = {
    name?: StringFieldUpdateOperationsInput | string
    rewards?: ActivityRewardsUpdateOneWithoutActivityNestedInput
    UserActivityLogsToday?: UserActivityLogsTodayUpdateManyWithoutActivityNestedInput
    logsNow?: logsNowUpdateManyWithoutActivityNestedInput
    historicLogs?: historicLogsUpdateManyWithoutActivityNestedInput
    historicQuickLogs?: historicQuickLogsUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateWithoutLogsTodayInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    rewards?: ActivityRewardsUncheckedUpdateOneWithoutActivityNestedInput
    UserActivityLogsToday?: UserActivityLogsTodayUncheckedUpdateManyWithoutActivityNestedInput
    logsNow?: logsNowUncheckedUpdateManyWithoutActivityNestedInput
    historicLogs?: historicLogsUncheckedUpdateManyWithoutActivityNestedInput
    historicQuickLogs?: historicQuickLogsUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type UserCreateWithoutUserActivityLogsTodayInput = {
    id: number
    name: string
    nick: string
    timezone?: number
    role: role
    levelRole?: levelRole
    guilds?: GuildCreateNestedManyWithoutUsersInput
    logsNow?: logsNowCreateNestedManyWithoutUserInput
    historicLogs?: historicLogsCreateNestedManyWithoutUserInput
    historicQuickLogs?: historicQuickLogsCreateNestedManyWithoutUserInput
    logsToday?: logsTodayCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserActivityLogsTodayInput = {
    id: number
    name: string
    nick: string
    timezone?: number
    role: role
    levelRole?: levelRole
    guilds?: GuildUncheckedCreateNestedManyWithoutUsersInput
    logsNow?: logsNowUncheckedCreateNestedManyWithoutUserInput
    historicLogs?: historicLogsUncheckedCreateNestedManyWithoutUserInput
    historicQuickLogs?: historicQuickLogsUncheckedCreateNestedManyWithoutUserInput
    logsToday?: logsTodayUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserActivityLogsTodayInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserActivityLogsTodayInput, UserUncheckedCreateWithoutUserActivityLogsTodayInput>
  }

  export type GuildCreateWithoutUserActivityLogsTodayInput = {
    id: string
    name: string
    users?: UserCreateNestedManyWithoutGuildsInput
    GuildPreferences?: GuildPreferencesCreateNestedOneWithoutGuildInput
    preferenceID: number
    logsNow?: logsNowCreateNestedManyWithoutGuildInput
    historicLogs?: historicLogsCreateNestedManyWithoutGuildInput
    historicQuickLogs?: historicQuickLogsCreateNestedManyWithoutGuildInput
  }

  export type GuildUncheckedCreateWithoutUserActivityLogsTodayInput = {
    id: string
    name: string
    users?: UserUncheckedCreateNestedManyWithoutGuildsInput
    GuildPreferences?: GuildPreferencesUncheckedCreateNestedOneWithoutGuildInput
    preferenceID: number
    logsNow?: logsNowUncheckedCreateNestedManyWithoutGuildInput
    historicLogs?: historicLogsUncheckedCreateNestedManyWithoutGuildInput
    historicQuickLogs?: historicQuickLogsUncheckedCreateNestedManyWithoutGuildInput
  }

  export type GuildCreateOrConnectWithoutUserActivityLogsTodayInput = {
    where: GuildWhereUniqueInput
    create: XOR<GuildCreateWithoutUserActivityLogsTodayInput, GuildUncheckedCreateWithoutUserActivityLogsTodayInput>
  }

  export type ActivityCreateWithoutUserActivityLogsTodayInput = {
    name: string
    rewards?: ActivityRewardsCreateNestedOneWithoutActivityInput
    logsNow?: logsNowCreateNestedManyWithoutActivityInput
    historicLogs?: historicLogsCreateNestedManyWithoutActivityInput
    historicQuickLogs?: historicQuickLogsCreateNestedManyWithoutActivityInput
    logsToday?: logsTodayCreateNestedManyWithoutActivityInput
  }

  export type ActivityUncheckedCreateWithoutUserActivityLogsTodayInput = {
    id?: number
    name: string
    rewards?: ActivityRewardsUncheckedCreateNestedOneWithoutActivityInput
    logsNow?: logsNowUncheckedCreateNestedManyWithoutActivityInput
    historicLogs?: historicLogsUncheckedCreateNestedManyWithoutActivityInput
    historicQuickLogs?: historicQuickLogsUncheckedCreateNestedManyWithoutActivityInput
    logsToday?: logsTodayUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityCreateOrConnectWithoutUserActivityLogsTodayInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutUserActivityLogsTodayInput, ActivityUncheckedCreateWithoutUserActivityLogsTodayInput>
  }

  export type UserUpsertWithoutUserActivityLogsTodayInput = {
    update: XOR<UserUpdateWithoutUserActivityLogsTodayInput, UserUncheckedUpdateWithoutUserActivityLogsTodayInput>
    create: XOR<UserCreateWithoutUserActivityLogsTodayInput, UserUncheckedCreateWithoutUserActivityLogsTodayInput>
  }

  export type UserUpdateWithoutUserActivityLogsTodayInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    nick?: StringFieldUpdateOperationsInput | string
    timezone?: IntFieldUpdateOperationsInput | number
    role?: EnumroleFieldUpdateOperationsInput | role
    levelRole?: EnumlevelRoleFieldUpdateOperationsInput | levelRole
    guilds?: GuildUpdateManyWithoutUsersNestedInput
    logsNow?: logsNowUpdateManyWithoutUserNestedInput
    historicLogs?: historicLogsUpdateManyWithoutUserNestedInput
    historicQuickLogs?: historicQuickLogsUpdateManyWithoutUserNestedInput
    logsToday?: logsTodayUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserActivityLogsTodayInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    nick?: StringFieldUpdateOperationsInput | string
    timezone?: IntFieldUpdateOperationsInput | number
    role?: EnumroleFieldUpdateOperationsInput | role
    levelRole?: EnumlevelRoleFieldUpdateOperationsInput | levelRole
    guilds?: GuildUncheckedUpdateManyWithoutUsersNestedInput
    logsNow?: logsNowUncheckedUpdateManyWithoutUserNestedInput
    historicLogs?: historicLogsUncheckedUpdateManyWithoutUserNestedInput
    historicQuickLogs?: historicQuickLogsUncheckedUpdateManyWithoutUserNestedInput
    logsToday?: logsTodayUncheckedUpdateManyWithoutUserNestedInput
  }

  export type GuildUpsertWithoutUserActivityLogsTodayInput = {
    update: XOR<GuildUpdateWithoutUserActivityLogsTodayInput, GuildUncheckedUpdateWithoutUserActivityLogsTodayInput>
    create: XOR<GuildCreateWithoutUserActivityLogsTodayInput, GuildUncheckedCreateWithoutUserActivityLogsTodayInput>
  }

  export type GuildUpdateWithoutUserActivityLogsTodayInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateManyWithoutGuildsNestedInput
    GuildPreferences?: GuildPreferencesUpdateOneWithoutGuildNestedInput
    preferenceID?: IntFieldUpdateOperationsInput | number
    logsNow?: logsNowUpdateManyWithoutGuildNestedInput
    historicLogs?: historicLogsUpdateManyWithoutGuildNestedInput
    historicQuickLogs?: historicQuickLogsUpdateManyWithoutGuildNestedInput
  }

  export type GuildUncheckedUpdateWithoutUserActivityLogsTodayInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    users?: UserUncheckedUpdateManyWithoutGuildsNestedInput
    GuildPreferences?: GuildPreferencesUncheckedUpdateOneWithoutGuildNestedInput
    preferenceID?: IntFieldUpdateOperationsInput | number
    logsNow?: logsNowUncheckedUpdateManyWithoutGuildNestedInput
    historicLogs?: historicLogsUncheckedUpdateManyWithoutGuildNestedInput
    historicQuickLogs?: historicQuickLogsUncheckedUpdateManyWithoutGuildNestedInput
  }

  export type ActivityUpsertWithoutUserActivityLogsTodayInput = {
    update: XOR<ActivityUpdateWithoutUserActivityLogsTodayInput, ActivityUncheckedUpdateWithoutUserActivityLogsTodayInput>
    create: XOR<ActivityCreateWithoutUserActivityLogsTodayInput, ActivityUncheckedCreateWithoutUserActivityLogsTodayInput>
  }

  export type ActivityUpdateWithoutUserActivityLogsTodayInput = {
    name?: StringFieldUpdateOperationsInput | string
    rewards?: ActivityRewardsUpdateOneWithoutActivityNestedInput
    logsNow?: logsNowUpdateManyWithoutActivityNestedInput
    historicLogs?: historicLogsUpdateManyWithoutActivityNestedInput
    historicQuickLogs?: historicQuickLogsUpdateManyWithoutActivityNestedInput
    logsToday?: logsTodayUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateWithoutUserActivityLogsTodayInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    rewards?: ActivityRewardsUncheckedUpdateOneWithoutActivityNestedInput
    logsNow?: logsNowUncheckedUpdateManyWithoutActivityNestedInput
    historicLogs?: historicLogsUncheckedUpdateManyWithoutActivityNestedInput
    historicQuickLogs?: historicQuickLogsUncheckedUpdateManyWithoutActivityNestedInput
    logsToday?: logsTodayUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type logsNowCreateManyUserInput = {
    id?: number
    timestamp?: Date | string
    type: ActivityType
    activityId: number
    guildId: string
  }

  export type historicLogsCreateManyUserInput = {
    id?: number
    date: Date | string
    type: ActivityType
    timeframe: Timeframe
    activityId: number
    guildId: string
  }

  export type historicQuickLogsCreateManyUserInput = {
    id?: number
    date: Date | string
    type: ActivityType
    start: Date | string
    end: Date | string
    activityId: number
    guildId: string
  }

  export type logsTodayCreateManyUserInput = {
    id?: number
    date: Date | string
    Type: string
    Timeframe: Timeframe
    minutes?: number
    activityId: number
  }

  export type UserActivityLogsTodayCreateManyUserInput = {
    id?: number
    type: ActivityType
    startedAt: Date | string
    endedAt: Date | string
    guildId: string
    activityId: number
  }

  export type GuildUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    GuildPreferences?: GuildPreferencesUpdateOneWithoutGuildNestedInput
    preferenceID?: IntFieldUpdateOperationsInput | number
    logsNow?: logsNowUpdateManyWithoutGuildNestedInput
    historicLogs?: historicLogsUpdateManyWithoutGuildNestedInput
    historicQuickLogs?: historicQuickLogsUpdateManyWithoutGuildNestedInput
    UserActivityLogsToday?: UserActivityLogsTodayUpdateManyWithoutGuildNestedInput
  }

  export type GuildUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    GuildPreferences?: GuildPreferencesUncheckedUpdateOneWithoutGuildNestedInput
    preferenceID?: IntFieldUpdateOperationsInput | number
    logsNow?: logsNowUncheckedUpdateManyWithoutGuildNestedInput
    historicLogs?: historicLogsUncheckedUpdateManyWithoutGuildNestedInput
    historicQuickLogs?: historicQuickLogsUncheckedUpdateManyWithoutGuildNestedInput
    UserActivityLogsToday?: UserActivityLogsTodayUncheckedUpdateManyWithoutGuildNestedInput
  }

  export type GuildUncheckedUpdateManyWithoutGuildsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    preferenceID?: IntFieldUpdateOperationsInput | number
  }

  export type logsNowUpdateWithoutUserInput = {
    activity?: ActivityUpdateOneRequiredWithoutLogsNowNestedInput
    guild?: GuildUpdateOneRequiredWithoutLogsNowNestedInput
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | ActivityType
  }

  export type logsNowUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | ActivityType
    activityId?: IntFieldUpdateOperationsInput | number
    guildId?: StringFieldUpdateOperationsInput | string
  }

  export type logsNowUncheckedUpdateManyWithoutLogsNowInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | ActivityType
    activityId?: IntFieldUpdateOperationsInput | number
    guildId?: StringFieldUpdateOperationsInput | string
  }

  export type historicLogsUpdateWithoutUserInput = {
    activity?: ActivityUpdateOneRequiredWithoutHistoricLogsNestedInput
    guild?: GuildUpdateOneRequiredWithoutHistoricLogsNestedInput
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | ActivityType
    timeframe?: EnumTimeframeFieldUpdateOperationsInput | Timeframe
  }

  export type historicLogsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | ActivityType
    timeframe?: EnumTimeframeFieldUpdateOperationsInput | Timeframe
    activityId?: IntFieldUpdateOperationsInput | number
    guildId?: StringFieldUpdateOperationsInput | string
  }

  export type historicLogsUncheckedUpdateManyWithoutHistoricLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | ActivityType
    timeframe?: EnumTimeframeFieldUpdateOperationsInput | Timeframe
    activityId?: IntFieldUpdateOperationsInput | number
    guildId?: StringFieldUpdateOperationsInput | string
  }

  export type historicQuickLogsUpdateWithoutUserInput = {
    activity?: ActivityUpdateOneRequiredWithoutHistoricQuickLogsNestedInput
    guild?: GuildUpdateOneRequiredWithoutHistoricQuickLogsNestedInput
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | ActivityType
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type historicQuickLogsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | ActivityType
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    activityId?: IntFieldUpdateOperationsInput | number
    guildId?: StringFieldUpdateOperationsInput | string
  }

  export type historicQuickLogsUncheckedUpdateManyWithoutHistoricQuickLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | ActivityType
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    activityId?: IntFieldUpdateOperationsInput | number
    guildId?: StringFieldUpdateOperationsInput | string
  }

  export type logsTodayUpdateWithoutUserInput = {
    activity?: ActivityUpdateOneRequiredWithoutLogsTodayNestedInput
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: StringFieldUpdateOperationsInput | string
    Timeframe?: EnumTimeframeFieldUpdateOperationsInput | Timeframe
    minutes?: IntFieldUpdateOperationsInput | number
  }

  export type logsTodayUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: StringFieldUpdateOperationsInput | string
    Timeframe?: EnumTimeframeFieldUpdateOperationsInput | Timeframe
    minutes?: IntFieldUpdateOperationsInput | number
    activityId?: IntFieldUpdateOperationsInput | number
  }

  export type logsTodayUncheckedUpdateManyWithoutLogsTodayInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: StringFieldUpdateOperationsInput | string
    Timeframe?: EnumTimeframeFieldUpdateOperationsInput | Timeframe
    minutes?: IntFieldUpdateOperationsInput | number
    activityId?: IntFieldUpdateOperationsInput | number
  }

  export type UserActivityLogsTodayUpdateWithoutUserInput = {
    type?: EnumActivityTypeFieldUpdateOperationsInput | ActivityType
    guild?: GuildUpdateOneRequiredWithoutUserActivityLogsTodayNestedInput
    activity?: ActivityUpdateOneRequiredWithoutUserActivityLogsTodayNestedInput
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserActivityLogsTodayUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumActivityTypeFieldUpdateOperationsInput | ActivityType
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guildId?: StringFieldUpdateOperationsInput | string
    activityId?: IntFieldUpdateOperationsInput | number
  }

  export type UserActivityLogsTodayUncheckedUpdateManyWithoutUserActivityLogsTodayInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumActivityTypeFieldUpdateOperationsInput | ActivityType
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guildId?: StringFieldUpdateOperationsInput | string
    activityId?: IntFieldUpdateOperationsInput | number
  }

  export type logsNowCreateManyGuildInput = {
    id?: number
    timestamp?: Date | string
    type: ActivityType
    userId: number
    activityId: number
  }

  export type historicLogsCreateManyGuildInput = {
    id?: number
    date: Date | string
    type: ActivityType
    timeframe: Timeframe
    userId: number
    activityId: number
  }

  export type historicQuickLogsCreateManyGuildInput = {
    id?: number
    date: Date | string
    type: ActivityType
    start: Date | string
    end: Date | string
    userId: number
    activityId: number
  }

  export type UserActivityLogsTodayCreateManyGuildInput = {
    id?: number
    type: ActivityType
    startedAt: Date | string
    endedAt: Date | string
    userId: number
    activityId: number
  }

  export type UserUpdateWithoutGuildsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    nick?: StringFieldUpdateOperationsInput | string
    timezone?: IntFieldUpdateOperationsInput | number
    role?: EnumroleFieldUpdateOperationsInput | role
    levelRole?: EnumlevelRoleFieldUpdateOperationsInput | levelRole
    logsNow?: logsNowUpdateManyWithoutUserNestedInput
    historicLogs?: historicLogsUpdateManyWithoutUserNestedInput
    historicQuickLogs?: historicQuickLogsUpdateManyWithoutUserNestedInput
    logsToday?: logsTodayUpdateManyWithoutUserNestedInput
    UserActivityLogsToday?: UserActivityLogsTodayUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGuildsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    nick?: StringFieldUpdateOperationsInput | string
    timezone?: IntFieldUpdateOperationsInput | number
    role?: EnumroleFieldUpdateOperationsInput | role
    levelRole?: EnumlevelRoleFieldUpdateOperationsInput | levelRole
    logsNow?: logsNowUncheckedUpdateManyWithoutUserNestedInput
    historicLogs?: historicLogsUncheckedUpdateManyWithoutUserNestedInput
    historicQuickLogs?: historicQuickLogsUncheckedUpdateManyWithoutUserNestedInput
    logsToday?: logsTodayUncheckedUpdateManyWithoutUserNestedInput
    UserActivityLogsToday?: UserActivityLogsTodayUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    nick?: StringFieldUpdateOperationsInput | string
    timezone?: IntFieldUpdateOperationsInput | number
    role?: EnumroleFieldUpdateOperationsInput | role
    levelRole?: EnumlevelRoleFieldUpdateOperationsInput | levelRole
  }

  export type logsNowUpdateWithoutGuildInput = {
    user?: UserUpdateOneRequiredWithoutLogsNowNestedInput
    activity?: ActivityUpdateOneRequiredWithoutLogsNowNestedInput
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | ActivityType
  }

  export type logsNowUncheckedUpdateWithoutGuildInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | ActivityType
    userId?: IntFieldUpdateOperationsInput | number
    activityId?: IntFieldUpdateOperationsInput | number
  }

  export type historicLogsUpdateWithoutGuildInput = {
    user?: UserUpdateOneRequiredWithoutHistoricLogsNestedInput
    activity?: ActivityUpdateOneRequiredWithoutHistoricLogsNestedInput
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | ActivityType
    timeframe?: EnumTimeframeFieldUpdateOperationsInput | Timeframe
  }

  export type historicLogsUncheckedUpdateWithoutGuildInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | ActivityType
    timeframe?: EnumTimeframeFieldUpdateOperationsInput | Timeframe
    userId?: IntFieldUpdateOperationsInput | number
    activityId?: IntFieldUpdateOperationsInput | number
  }

  export type historicQuickLogsUpdateWithoutGuildInput = {
    user?: UserUpdateOneRequiredWithoutHistoricQuickLogsNestedInput
    activity?: ActivityUpdateOneRequiredWithoutHistoricQuickLogsNestedInput
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | ActivityType
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type historicQuickLogsUncheckedUpdateWithoutGuildInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | ActivityType
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    activityId?: IntFieldUpdateOperationsInput | number
  }

  export type UserActivityLogsTodayUpdateWithoutGuildInput = {
    user?: UserUpdateOneRequiredWithoutUserActivityLogsTodayNestedInput
    type?: EnumActivityTypeFieldUpdateOperationsInput | ActivityType
    activity?: ActivityUpdateOneRequiredWithoutUserActivityLogsTodayNestedInput
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserActivityLogsTodayUncheckedUpdateWithoutGuildInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumActivityTypeFieldUpdateOperationsInput | ActivityType
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    activityId?: IntFieldUpdateOperationsInput | number
  }

  export type UserActivityLogsTodayCreateManyActivityInput = {
    id?: number
    type: ActivityType
    startedAt: Date | string
    endedAt: Date | string
    userId: number
    guildId: string
  }

  export type logsNowCreateManyActivityInput = {
    id?: number
    timestamp?: Date | string
    type: ActivityType
    userId: number
    guildId: string
  }

  export type historicLogsCreateManyActivityInput = {
    id?: number
    date: Date | string
    type: ActivityType
    timeframe: Timeframe
    userId: number
    guildId: string
  }

  export type historicQuickLogsCreateManyActivityInput = {
    id?: number
    date: Date | string
    type: ActivityType
    start: Date | string
    end: Date | string
    userId: number
    guildId: string
  }

  export type logsTodayCreateManyActivityInput = {
    id?: number
    date: Date | string
    Type: string
    Timeframe: Timeframe
    minutes?: number
    userId: number
  }

  export type UserActivityLogsTodayUpdateWithoutActivityInput = {
    user?: UserUpdateOneRequiredWithoutUserActivityLogsTodayNestedInput
    type?: EnumActivityTypeFieldUpdateOperationsInput | ActivityType
    guild?: GuildUpdateOneRequiredWithoutUserActivityLogsTodayNestedInput
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserActivityLogsTodayUncheckedUpdateWithoutActivityInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumActivityTypeFieldUpdateOperationsInput | ActivityType
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    guildId?: StringFieldUpdateOperationsInput | string
  }

  export type logsNowUpdateWithoutActivityInput = {
    user?: UserUpdateOneRequiredWithoutLogsNowNestedInput
    guild?: GuildUpdateOneRequiredWithoutLogsNowNestedInput
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | ActivityType
  }

  export type logsNowUncheckedUpdateWithoutActivityInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | ActivityType
    userId?: IntFieldUpdateOperationsInput | number
    guildId?: StringFieldUpdateOperationsInput | string
  }

  export type historicLogsUpdateWithoutActivityInput = {
    user?: UserUpdateOneRequiredWithoutHistoricLogsNestedInput
    guild?: GuildUpdateOneRequiredWithoutHistoricLogsNestedInput
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | ActivityType
    timeframe?: EnumTimeframeFieldUpdateOperationsInput | Timeframe
  }

  export type historicLogsUncheckedUpdateWithoutActivityInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | ActivityType
    timeframe?: EnumTimeframeFieldUpdateOperationsInput | Timeframe
    userId?: IntFieldUpdateOperationsInput | number
    guildId?: StringFieldUpdateOperationsInput | string
  }

  export type historicQuickLogsUpdateWithoutActivityInput = {
    user?: UserUpdateOneRequiredWithoutHistoricQuickLogsNestedInput
    guild?: GuildUpdateOneRequiredWithoutHistoricQuickLogsNestedInput
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | ActivityType
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type historicQuickLogsUncheckedUpdateWithoutActivityInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | ActivityType
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    guildId?: StringFieldUpdateOperationsInput | string
  }

  export type logsTodayUpdateWithoutActivityInput = {
    user?: UserUpdateOneRequiredWithoutLogsTodayNestedInput
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: StringFieldUpdateOperationsInput | string
    Timeframe?: EnumTimeframeFieldUpdateOperationsInput | Timeframe
    minutes?: IntFieldUpdateOperationsInput | number
  }

  export type logsTodayUncheckedUpdateWithoutActivityInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: StringFieldUpdateOperationsInput | string
    Timeframe?: EnumTimeframeFieldUpdateOperationsInput | Timeframe
    minutes?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}